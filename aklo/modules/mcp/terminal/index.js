#!/usr/bin/env node
/**
 * @aklo/mcp-terminal
 * 
 * Serveur MCP sp√©cialis√© pour la gestion du terminal dans l'√©cosyst√®me Aklo.
 * Fournit des outils s√©curis√©s et contextuels pour l'ex√©cution de commandes
 * en respectant les protocoles de s√©curit√© d√©finis dans la Charte IA.
 */

import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { 
  CallToolRequestSchema,
  ListToolsRequestSchema,
} from '@modelcontextprotocol/sdk/types.js';
import { spawn, exec } from 'child_process';
import { readFile, access } from 'fs/promises';
import { join, resolve } from 'path';
import { promisify } from 'util';

const execAsync = promisify(exec);

class AkloTerminalServer {
  constructor() {
    this.server = new Server(
      {
        name: '@aklo/mcp-terminal',
        version: '1.0.0',
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );
    
    this.setupToolHandlers();
    this.setupErrorHandling();
  }

  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: 'aklo_execute',
          description: 'Ex√©cute une commande aklo de mani√®re s√©curis√©e avec validation du contexte',
          inputSchema: {
            type: 'object',
            properties: {
              command: {
                type: 'string',
                description: 'Commande aklo √† ex√©cuter (ex: "init", "propose-pbi", "plan")',
              },
              args: {
                type: 'array',
                items: { type: 'string' },
                description: 'Arguments pour la commande aklo',
              },
              workdir: {
                type: 'string',
                description: 'R√©pertoire de travail (optionnel, utilise le r√©pertoire courant par d√©faut)',
              },
            },
            required: ['command'],
          },
        },
        {
          name: 'aklo_status',
          description: 'Affiche le statut actuel du projet Aklo (PBI, Tasks, configuration)',
          inputSchema: {
            type: 'object',
            properties: {
              workdir: {
                type: 'string',
                description: 'R√©pertoire du projet √† analyser',
              },
            },
          },
        },
        {
          name: 'safe_shell',
          description: 'Ex√©cute une commande shell s√©curis√©e avec restrictions Aklo',
          inputSchema: {
            type: 'object',
            properties: {
              command: {
                type: 'string',
                description: 'Commande shell √† ex√©cuter',
              },
              workdir: {
                type: 'string',
                description: 'R√©pertoire de travail',
              },
              timeout: {
                type: 'number',
                description: 'Timeout en millisecondes (d√©faut: 30000)',
                default: 30000,
              },
            },
            required: ['command'],
          },
        },
        {
          name: 'project_info',
          description: 'R√©cup√®re les informations sur le projet courant (package.json, git, aklo config)',
          inputSchema: {
            type: 'object',
            properties: {
              workdir: {
                type: 'string',
                description: 'R√©pertoire du projet',
              },
            },
          },
        },
      ],
    }));

    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      
      try {
        switch (name) {
          case 'aklo_execute':
            return await this.handleAkloExecute(args);
          case 'aklo_status':
            return await this.handleAkloStatus(args);
          case 'safe_shell':
            return await this.handleSafeShell(args);
          case 'project_info':
            return await this.handleProjectInfo(args);
          default:
            throw new Error(`Outil inconnu: ${name}`);
        }
      } catch (error) {
        return {
          content: [
            {
              type: 'text',
              text: `Erreur lors de l'ex√©cution de ${name}: ${error.message}`,
            },
          ],
          isError: true,
        };
      }
    });
  }

  async handleAkloExecute(args) {
    const { command, args: cmdArgs = [], workdir = process.cwd() } = args;
    
    // Validation des commandes aklo autoris√©es
    const allowedCommands = [
      // Commandes legacy
      'init', 'propose-pbi', 'pbi', 'plan', 'start-task', 'submit-task', 
      'merge-task', 'release', 'hotfix', 'new', 'get_config',
      
      // Commandes syst√®me (PHASE 1)
      'status', 'validate', 'mcp', 'template', 'install-ux',
      
      // Commandes d√©veloppement (PHASE 2)
      'arch', 'dev', 'debug', 'review', 'refactor',
      
      // Commandes qualit√© (PHASE 3)
      'optimize', 'security', 'diagnose', 'experiment', 'docs',
      
      // Commandes sp√©cialis√©es (PHASE 4)
      'analyze', 'track', 'onboard', 'deprecate', 'kb', 'fast', 'meta'
    ];
    
    if (!allowedCommands.includes(command)) {
      throw new Error(`Commande aklo non autoris√©e: ${command}`);
    }
    
    // Construire la commande compl√®te
    const akloPath = await this.findAkloScript(workdir);
    const fullCommand = [akloPath, command, ...cmdArgs].join(' ');
    
    try {
      const { stdout, stderr } = await execAsync(fullCommand, { 
        cwd: workdir,
        timeout: 30000,
      });
      
      return {
        content: [
          {
            type: 'text',
            text: `Commande: aklo ${command} ${cmdArgs.join(' ')}\n\nSortie:\n${stdout}${stderr ? `\nErreurs:\n${stderr}` : ''}`,
          },
        ],
      };
    } catch (error) {
      throw new Error(`√âchec de la commande aklo: ${error.message}`);
    }
  }

  async handleAkloStatus(args) {
    const { workdir = process.cwd() } = args;
    
    try {
      // V√©rifier si le projet est initialis√© avec Aklo
      const akloConfigPath = join(workdir, '.aklo.conf');
      const charteLink = join(workdir, 'docs', 'CHARTE_IA');
      
      let status = 'üìä Statut du Projet Aklo\n\n';
      
      // V√©rifier l'initialisation
      try {
        await access(akloConfigPath);
        await access(charteLink);
        status += '‚úÖ Projet initialis√© avec Aklo\n';
        
        // Lire la configuration
        const config = await readFile(akloConfigPath, 'utf-8');
        const workdirMatch = config.match(/PROJECT_WORKDIR=(.+)/);
        if (workdirMatch) {
          status += `üìÅ R√©pertoire de travail: ${workdirMatch[1]}\n`;
        }
      } catch {
        status += '‚ùå Projet non initialis√© avec Aklo\n';
        return {
          content: [{ type: 'text', text: status }],
        };
      }
      
      // Compter les PBI
      try {
        const { stdout } = await execAsync('find docs/backlog/00-pbi -name "PBI-*.md" 2>/dev/null | wc -l', { cwd: workdir });
        const pbiCount = parseInt(stdout.trim());
        status += `üìã PBI: ${pbiCount} d√©finis\n`;
      } catch {
        status += 'üìã PBI: Aucun r√©pertoire de backlog trouv√©\n';
      }
      
      // V√©rifier Git
      try {
        const { stdout } = await execAsync('git branch --show-current 2>/dev/null', { cwd: workdir });
        status += `üåø Branche Git actuelle: ${stdout.trim()}\n`;
      } catch {
        status += 'üåø Git: Non initialis√©\n';
      }
      
      return {
        content: [{ type: 'text', text: status }],
      };
    } catch (error) {
      throw new Error(`Erreur lors de la r√©cup√©ration du statut: ${error.message}`);
    }
  }

  async handleSafeShell(args) {
    const { command, workdir = process.cwd(), timeout = 30000 } = args;
    
    // Liste des commandes dangereuses interdites
    const dangerousCommands = [
      'rm -rf /', 'sudo', 'chmod 777', 'mv /', 'cp -r /', 
      'dd if=', 'mkfs', 'fdisk', 'format', 'del *', 'deltree'
    ];
    
    const isDangerous = dangerousCommands.some(dangerous => 
      command.toLowerCase().includes(dangerous.toLowerCase())
    );
    
    if (isDangerous) {
      throw new Error(`Commande potentiellement dangereuse refus√©e: ${command}`);
    }
    
    try {
      const { stdout, stderr } = await execAsync(command, { 
        cwd: workdir,
        timeout,
      });
      
      return {
        content: [
          {
            type: 'text',
            text: `Commande: ${command}\nR√©pertoire: ${workdir}\n\nSortie:\n${stdout}${stderr ? `\nErreurs:\n${stderr}` : ''}`,
          },
        ],
      };
    } catch (error) {
      throw new Error(`√âchec de la commande shell: ${error.message}`);
    }
  }

  async handleProjectInfo(args) {
    const { workdir = process.cwd() } = args;
    
    let info = 'üìÅ Informations du Projet\n\n';
    
    try {
      // Package.json
      const packagePath = join(workdir, 'package.json');
      try {
        const packageContent = await readFile(packagePath, 'utf-8');
        const packageJson = JSON.parse(packageContent);
        info += `üì¶ Nom: ${packageJson.name || 'Non d√©fini'}\n`;
        info += `üè∑Ô∏è  Version: ${packageJson.version || 'Non d√©finie'}\n`;
        info += `üìù Description: ${packageJson.description || 'Non d√©finie'}\n\n`;
      } catch {
        info += 'üì¶ package.json: Non trouv√©\n\n';
      }
      
      // Configuration Aklo
      const akloConfigPath = join(workdir, '.aklo.conf');
      try {
        const akloConfig = await readFile(akloConfigPath, 'utf-8');
        info += '‚öôÔ∏è  Configuration Aklo:\n';
        info += akloConfig.split('\n')
          .filter(line => line.trim() && !line.startsWith('#'))
          .map(line => `   ${line}`)
          .join('\n');
        info += '\n\n';
      } catch {
        info += '‚öôÔ∏è  Configuration Aklo: Non trouv√©e\n\n';
      }
      
      // Informations Git
      try {
        const { stdout: branch } = await execAsync('git branch --show-current 2>/dev/null', { cwd: workdir });
        const { stdout: status } = await execAsync('git status --porcelain 2>/dev/null', { cwd: workdir });
        info += `üåø Git - Branche: ${branch.trim()}\n`;
        info += `üåø Git - Fichiers modifi√©s: ${status.split('\n').filter(l => l.trim()).length}\n`;
      } catch {
        info += 'üåø Git: Non initialis√©\n';
      }
      
      return {
        content: [{ type: 'text', text: info }],
      };
    } catch (error) {
      throw new Error(`Erreur lors de la r√©cup√©ration des informations: ${error.message}`);
    }
  }

  async findAkloScript(workdir) {
    // Chercher le script aklo dans plusieurs emplacements possibles
    const possiblePaths = [
      join(workdir, 'aklo', 'bin', 'aklo'),
      join(process.env.HOME, 'Projets', 'dotfiles', 'aklo', 'bin', 'aklo'),
      join(process.env.HOME, '.dotfiles', 'aklo', 'bin', 'aklo'),
      join(process.env.HOME, 'dotfiles', 'aklo', 'bin', 'aklo'),
      'aklo', // Dans le PATH
    ];
    
    for (const path of possiblePaths) {
      try {
        await access(path);
        return path;
      } catch {
        continue;
      }
    }
    
    throw new Error('Script aklo introuvable. Assurez-vous qu\'Aklo est install√©.');
  }

  setupErrorHandling() {
    this.server.onerror = (error) => {
      console.error('[MCP Terminal Error]', error);
    };

    process.on('SIGINT', async () => {
      await this.server.close();
      process.exit(0);
    });
  }

  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.error('üñ•Ô∏è  Serveur MCP Terminal Aklo d√©marr√©');
  }
}

// D√©marrer le serveur
const server = new AkloTerminalServer();
server.start().catch(console.error);