#!/bin/bash
#==============================================================================
# The Aklo Protocol - Interface Unifi√©e
#
# Auteur: Human_Developer & AI_Agent
# Version: Interface compl√®te avec commits atomiques par protocole
#
# Impl√©mente l'interface unifi√©e aklo couvrant tous les protocoles
# d√©finie dans le META-IMPROVEMENT command-coverage-20250102.
#==============================================================================

# Configuration de base du Shell
set -e

# Configuration de base - Chemins des modules
# Remplacement de realpath pour une meilleure portabilit√© (macOS)
script_path="$0"
while [ -L "$script_path" ]; do
    script_dir="$(cd -P "$(dirname "$script_path")" >/dev/null 2>&1 && pwd)"
    script_path="$(readlink "$script_path")"
    [[ $script_path != /* ]] && script_path="$script_dir/$script_path"
done
script_dir="$(cd -P "$(dirname "$script_path")" >/dev/null 2>&1 && pwd)"
modules_dir="${script_dir}/../modules"

#==============================================================================
# ARCHITECTURE INTELLIGENTE FAIL-SAFE - TASK-13-4
#==============================================================================
# Remplacement complet du chargement syst√©matique par une architecture adaptative
# qui charge uniquement les modules n√©cessaires selon la commande et le contexte

# Variables globales pour le syst√®me intelligent
AKLO_START_TIME=$(date +%s.%N)
AKLO_COMMAND="${1:-help}"
AKLO_PROFILE=""
AKLO_MODULES_LOADED=()
AKLO_FALLBACK_MODE=false

# Configuration des profils de chargement (compatible bash 3.x)
# Fonction pour obtenir le profil d'une commande
get_command_profile() {
    local command="$1"
    case "$command" in
        "get_config"|"help"|"version") echo "MINIMAL" ;;
        "cache_stats"|"plan"|"dev"|"debug"|"review"|"propose-pbi"|"arch") echo "NORMAL" ;;
        "optimize"|"monitor"|"benchmark"|"security") echo "FULL" ;;
        *) echo "NORMAL" ;;
    esac
}

# Fonction pour obtenir les modules d'un profil
get_profile_modules() {
    local profile="$1"
    local command="$2"
    
    case "$profile" in
        "MINIMAL") echo "" ;;
        "NORMAL") 
            if [[ "$command" == "cache_stats" ]]; then
                echo "cache/cache_functions.sh,cache/regex_cache.sh"
            else
                echo "cache/cache_functions.sh"
            fi
            ;;
        "FULL") echo "cache/cache_functions.sh,cache/regex_cache.sh" ;;
        *) echo "cache/cache_functions.sh" ;;
    esac
}

# Fonction de chargement intelligent des modules
load_modules_for_profile() {
    local profile="$1"
    local modules_list=$(get_profile_modules "$profile" "$AKLO_COMMAND")
    
    # Pas de v√©rification car modules_list peut √™tre vide pour MINIMAL
    
    # Chargement des modules avec gestion d'erreur
    if [[ -n "$modules_list" ]]; then
        IFS=',' read -ra modules <<< "$modules_list"
        for module in "${modules[@]}"; do
            local module_path="${modules_dir}/${module}"
            
            if [[ -f "$module_path" ]]; then
                if source "$module_path" 2>/dev/null; then
                    AKLO_MODULES_LOADED+=("$module")
                else
                    echo "‚ö†Ô∏è  Erreur lors du chargement de $module - continuer sans ce module" >&2
                fi
            else
                echo "‚ö†Ô∏è  Module $module non trouv√© - continuer sans ce module" >&2
            fi
        done
    else
        echo "üì¶ Profil MINIMAL - aucun module √† charger" >&2
    fi
}

# Fonction de classification intelligente de la commande
classify_command() {
    local command="$1"
    
    # Utilisation de la fonction get_command_profile
    get_command_profile "$command"
}

# Fonction d'initialisation conditionnelle des modules
initialize_loaded_modules() {
    # Initialisation uniquement des modules charg√©s
    for module in "${AKLO_MODULES_LOADED[@]}"; do
        case "$module" in
            "cache/regex_cache.sh")
                command -v init_regex_cache >/dev/null 2>&1 && init_regex_cache
                ;;
            "io/io_monitoring.sh")
                command -v reset_io_metrics >/dev/null 2>&1 && reset_io_metrics
                command -v start_io_monitoring >/dev/null 2>&1 && start_io_monitoring
                ;;
            "cache/id_cache.sh")
                command -v reset_id_cache_metrics >/dev/null 2>&1 && reset_id_cache_metrics
                ;;
            "performance/performance_tuning.sh")
                command -v load_performance_config >/dev/null 2>&1 && load_performance_config
                ;;
            "core/metrics_engine.sh")
                command -v initialize_metrics_engine >/dev/null 2>&1 && initialize_metrics_engine
                ;;
        esac
    done
}

# Fonction de collecte des m√©triques de d√©marrage
collect_startup_metrics() {
    local command="$1"
    local profile="$2"
    local start_time="$3"
    
    if command -v collect_loading_metrics >/dev/null 2>&1; then
        local end_time=$(date +%s.%N)
        collect_loading_metrics "$command" "$profile" "cli" "$start_time" "$end_time"
    fi
}

# EX√âCUTION DE L'ARCHITECTURE INTELLIGENTE

# 1. Classification de la commande
AKLO_PROFILE=$(classify_command "$AKLO_COMMAND")

# 2. Mode de debug conditionnel (silencieux pour MINIMAL)
AKLO_DEBUG_MODE="${AKLO_DEBUG:-false}"
if [[ "$AKLO_PROFILE" != "MINIMAL" || "$AKLO_DEBUG_MODE" == "true" ]]; then
    echo "üöÄ Aklo - Architecture intelligente activ√©e" >&2
    echo "üìä Commande: $AKLO_COMMAND | Profil: $AKLO_PROFILE" >&2
fi

# 3. Chargement conditionnel des modules
load_modules_for_profile "$AKLO_PROFILE"

if [[ "$AKLO_PROFILE" != "MINIMAL" || "$AKLO_DEBUG_MODE" == "true" ]]; then
    if [[ ${#AKLO_MODULES_LOADED[@]} -eq 0 ]]; then
        echo "üì¶ Profil MINIMAL - aucun module √† charger" >&2
    else
        echo "üì¶ Modules charg√©s: ${#AKLO_MODULES_LOADED[@]} (${AKLO_MODULES_LOADED[*]})" >&2
    fi
fi

# 4. Initialisation des modules charg√©s
initialize_loaded_modules

# 5. Collecte des m√©triques de d√©marrage (uniquement si module disponible)
if [[ "$AKLO_PROFILE" != "MINIMAL" ]] && command -v collect_startup_metrics >/dev/null 2>&1; then
    collect_startup_metrics "$AKLO_COMMAND" "$AKLO_PROFILE" "$AKLO_START_TIME"
fi

# Message de fin uniquement pour profils non-MINIMAL ou en mode debug
if [[ "$AKLO_PROFILE" != "MINIMAL" || "$AKLO_DEBUG_MODE" == "true" ]]; then
    AKLO_END_TIME=$(date +%s.%N)
    AKLO_DURATION=$(echo "$AKLO_END_TIME - $AKLO_START_TIME" | bc -l 2>/dev/null || echo "0.0")
    echo "‚úÖ Initialisation termin√©e en ${AKLO_DURATION}s" >&2
fi

#==============================================================================
# PARSER G√âN√âRIQUE DE PROTOCOLES - SOURCE UNIQUE DE V√âRIT√â
#==============================================================================

# Fonction principale : Parser et g√©n√©rer un artefact depuis un protocole
# TASK-6-3: Version avec cache intelligent et fallback transparent
parse_and_generate_artefact() {
  local protocol_name="$1"        # Ex: "03-DEVELOPPEMENT"
  local artefact_type="$2"        # Ex: "PBI", "TASK"
  local assistance_level="$3"     # "full", "skeleton", "minimal"
  local output_file="$4"          # Chemin du fichier de sortie
  local context_vars="$5"         # Variables contextuelles
  
  # Configuration cache par d√©faut
  local AKLO_CACHE_ENABLED="${AKLO_CACHE_ENABLED:-true}"
  local AKLO_CACHE_DEBUG="${AKLO_CACHE_DEBUG:-false}"
  
  # Lire la configuration cache depuis .aklo.conf
  local config_file=".aklo.conf"
  if [ ! -f "$config_file" ]; then
    local script_dir="$(dirname "$(realpath "$0")")"
    config_file="${script_dir}/../config/.aklo.conf"
  fi
  
  if [ -f "$config_file" ]; then
    if grep -q "^CACHE_ENABLED=" "$config_file" 2>/dev/null; then
      AKLO_CACHE_ENABLED=$(grep "^CACHE_ENABLED=" "$config_file" | cut -d'=' -f2)
    fi
    if grep -q "^CACHE_DEBUG=" "$config_file" 2>/dev/null; then
      AKLO_CACHE_DEBUG=$(grep "^CACHE_DEBUG=" "$config_file" | cut -d'=' -f2)
    fi
  fi
  
  # Fonction utilitaire pour le logging cache
  log_cache_event() {
    local event="$1"
    local details="$2"
    if [ "$AKLO_CACHE_DEBUG" = "true" ]; then
      echo "[CACHE] $event: $details" >&2
    fi
  }
  
  # Construire le chemin du protocole (relatif au r√©pertoire racine)
  local protocol_file="./aklo/charte/PROTOCOLES/${protocol_name}.md"
  
  # Si pas trouv√© en relatif, essayer le chemin absolu depuis le script
  if [ ! -f "$protocol_file" ]; then
    local script_dir="$(dirname "$(realpath "$0")")"
    protocol_file="${script_dir}/../charte/PROTOCOLES/${protocol_name}.md"
  fi
  
  if [ ! -f "$protocol_file" ]; then
    echo "‚ùå Erreur : Protocole $protocol_name non trouv√© dans la charte." >&2
    echo "   Cherch√© dans: ./aklo/charte/PROTOCOLES/${protocol_name}.md" >&2
    echo "   Et dans: ${script_dir}/../charte/PROTOCOLES/${protocol_name}.md" >&2
    return 1
  fi
  
  local artefact_structure=""
  
  # NOUVEAU: Tentative d'utilisation du cache si activ√©
  if [ "$AKLO_CACHE_ENABLED" = "true" ]; then
    log_cache_event "CHECK" "V√©rification cache pour ${protocol_name}/${artefact_type}"
    
    # Optimisation: G√©n√©ration rapide du nom de fichier cache
    local cache_file="/tmp/aklo_cache/protocol_${protocol_name}_${artefact_type}.parsed"
    
    # Optimisation: V√©rification rapide de l'existence du cache
    if [ -f "$cache_file" ]; then
      # Obtenir le timestamp du protocole (optimis√©)
      local protocol_mtime
      if protocol_mtime=$(stat -f %m "$protocol_file" 2>/dev/null || stat -c %Y "$protocol_file" 2>/dev/null); then
        # V√©rifier la validit√© du cache (optimis√©)
        local cache_mtime
        if cache_mtime=$(stat -f %m "$cache_file" 2>/dev/null || stat -c %Y "$cache_file" 2>/dev/null); then
          if [ "$cache_mtime" -ge "$protocol_mtime" ]; then
            # Cache hit - lecture directe optimis√©e
            log_cache_event "HIT" "Cache valide trouv√©: $cache_file"
            if artefact_structure=$(cat "$cache_file" 2>/dev/null); then
              log_cache_event "SUCCESS" "Cache lu avec succ√®s"
              # TASK-6-4: Enregistrer m√©trique cache hit
              record_cache_metric "hit" 2>/dev/null || true
            else
              log_cache_event "ERROR" "√âchec lecture cache - fallback vers extraction"
              artefact_structure=""
            fi
          else
            # Cache miss - extraction et mise en cache
            log_cache_event "MISS" "Cache invalide ou inexistant"
            if artefact_structure=$(extract_artefact_structure "$protocol_file" "$artefact_type"); then
              # Mise en cache atomique
              mkdir -p "/tmp/aklo_cache"
              echo "$artefact_structure" > "$cache_file.tmp" && mv "$cache_file.tmp" "$cache_file"
              log_cache_event "CACHED" "Structure extraite et mise en cache"
              # TASK-6-4: Enregistrer m√©trique cache miss
              record_cache_metric "miss" 2>/dev/null || true
            else
              log_cache_event "ERROR" "√âchec extraction avec cache - fallback"
              artefact_structure=""
            fi
          fi
        fi
      else
        log_cache_event "ERROR" "Impossible d'obtenir mtime - fallback"
      fi
    else
      # Pas de cache existant - extraction et mise en cache
      log_cache_event "MISS" "Aucun cache trouv√©"
      if artefact_structure=$(extract_artefact_structure "$protocol_file" "$artefact_type"); then
        # Mise en cache atomique
        mkdir -p "/tmp/aklo_cache"
        echo "$artefact_structure" > "$cache_file.tmp" && mv "$cache_file.tmp" "$cache_file"
        log_cache_event "CACHED" "Structure extraite et mise en cache"
        # TASK-6-4: Enregistrer m√©trique cache miss
        record_cache_metric "miss" 2>/dev/null || true
      else
        log_cache_event "ERROR" "√âchec extraction - fallback"
        artefact_structure=""
      fi
    fi
  else
    log_cache_event "DISABLED" "Cache d√©sactiv√© par configuration"
  fi
  
  # Fallback vers m√©thode originale si cache √©choue ou d√©sactiv√©
  if [ -z "$artefact_structure" ]; then
    log_cache_event "FALLBACK" "Utilisation m√©thode originale"
    artefact_structure=$(extract_artefact_structure "$protocol_file" "$artefact_type")
    
    if [ -z "$artefact_structure" ]; then
      echo "‚ùå Erreur : Structure d'artefact $artefact_type non trouv√©e dans $protocol_name." >&2
      return 1
    fi
  fi
  
  # Appliquer le filtrage intelligent selon le niveau d'assistance
  local filtered_content
  if ! filtered_content=$(apply_intelligent_filtering "$artefact_structure" "$assistance_level" "$context_vars"); then
    echo "‚ùå Erreur : √âchec du filtrage intelligent." >&2
    return 1
  fi
  
  # √âcrire le r√©sultat dans le fichier de sortie
  if ! echo "$filtered_content" > "$output_file"; then
    echo "‚ùå Erreur : Impossible d'√©crire dans $output_file." >&2
    return 1
  fi
  
  log_cache_event "COMPLETE" "G√©n√©ration artefact termin√©e: $output_file"
  return 0
}

# Extraire la structure d'artefact depuis un protocole
extract_artefact_structure() {
  local protocol_file="$1"
  local artefact_type="$2"
  
  # TASK-7-4: Tracking I/O pour monitoring
  local start_time=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))
  
  # V√©rifier l'existence du fichier
  if [ ! -f "$protocol_file" ]; then
    # TASK-7-4: Tracker l'√©chec
    if command -v track_io_operation >/dev/null 2>&1; then
      local duration=$(($(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000))) - start_time))
      track_io_operation "file_read" "$protocol_file" "$duration" "error"
    fi
    return 1
  fi
  
  # Patterns de recherche selon le type d'artefact
  local start_pattern=""
  local end_pattern=""
  
  case "$artefact_type" in
    "PBI")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier PBI"
      end_pattern="^## SECTION 3"
      ;;
    "DEBUG")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Debug"
      end_pattern="^## SECTION 3"
      ;;
    "REFACTOR")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Refactor"
      end_pattern="^## SECTION 3"
      ;;
    "ARCH")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier ARCH"
      end_pattern="^## SECTION 3"
      ;;
    "TASK")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Task"
      end_pattern="^## SECTION 3"
      ;;
    "RELEASE")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Release"
      end_pattern="^## SECTION 3"
      ;;
    "JOURNAL")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Journal"
      end_pattern="^## SECTION 3"
      ;;
    "REVIEW")
      start_pattern="### 2\.2\. Structure Obligatoire Du Fichier Review"
      end_pattern="^## SECTION 3"
      ;;
    "HOTFIX")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Hotfix"
      end_pattern="^## SECTION 3"
      ;;
    "OPTIM")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Optim"
      end_pattern="^## SECTION 3"
      ;;
    "AUDIT")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier d'Audit"
      end_pattern="^## SECTION 3"
      ;;
    "EXPERIMENT")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Experiment"
      end_pattern="^## SECTION 3"
      ;;
    "USER-DOCS")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier de Documentation"
      end_pattern="^## SECTION 3"
      ;;
    "COMPETITION")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier d'Analyse"
      end_pattern="^## SECTION 3"
      ;;
    "TRACKING-PLAN")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier de Tracking"
      end_pattern="^## SECTION 3"
      ;;
    "ONBOARDING")
      start_pattern="### 2\.3\. : STRUCTURE DU RAPPORT D'ONBOARDING"
      end_pattern="^## SECTION 3"
      ;;
    "DEPRECATION")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier de D√©pr√©ciation"
      end_pattern="^## SECTION 3"
      ;;
    "KNOWLEDGE-BASE")
      start_pattern="### 2\.2\. Structure Recommand√©e du Fichier"
      end_pattern="^## SECTION 3"
      ;;
    "FAST-TRACK")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Fast-Track"
      end_pattern="^## SECTION 3"
      ;;
    "META-IMPROVEMENT")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Improve"
      end_pattern="^## SECTION 3"
      ;;
    *)
      echo "‚ùå Type d'artefact $artefact_type non support√©." >&2
      return 1
      ;;
  esac
  
  # Extraire la section entre les patterns
  local structure=$(sed -n "/$start_pattern/,/$end_pattern/p" "$protocol_file")
  
  # TASK-7-4: Tracker l'op√©ration de lecture
  if command -v track_io_operation >/dev/null 2>&1; then
    local end_time=$(date +%s%3N 2>/dev/null || echo $(($(date +%s) * 1000)))
    local duration=$((end_time - start_time))
    if [ -n "$structure" ]; then
      track_io_operation "file_read" "$protocol_file" "$duration" "success"
    else
      track_io_operation "file_read" "$protocol_file" "$duration" "no_match"
    fi
  fi
  
  # Si aucune section trouv√©e, retourner vide
  if [ -z "$structure" ]; then
    return 1
  fi
  
  # Supprimer la premi√®re ligne (pattern de d√©but)
  structure=$(echo "$structure" | tail -n +2)
  
  # Supprimer la derni√®re ligne si elle contient le pattern de fin
  if echo "$structure" | tail -n 1 | grep -q "^## SECTION 3"; then
    # Compter les lignes et supprimer la derni√®re
    local line_count=$(echo "$structure" | wc -l)
    local target_lines=$((line_count - 1))
    structure=$(echo "$structure" | head -n $target_lines)
  fi
  
  # Extraire uniquement le contenu markdown entre ```markdown et ```
  echo "$structure" | sed -n '/```markdown/,/```/p' | sed '1d;$d'
}

# Appliquer le filtrage intelligent selon le niveau d'assistance
apply_intelligent_filtering() {
  local content="$1"
  local assistance_level="$2"
  local context_vars="$3"
  
  # Parser les variables contextuelles (format simple key=value) - approche robuste
  # Remplacer les virgules par des newlines et parser ligne par ligne
  local vars_lines=$(echo "$context_vars" | sed 's/,/\n/g')
  local id_value=$(echo "$vars_lines" | grep '^id=' | cut -d'=' -f2 | tr -d '\n\r')
  local full_id_value=$(echo "$vars_lines" | grep '^full_id=' | cut -d'=' -f2 | tr -d '\n\r')
  local pbi_id_value=$(echo "$vars_lines" | grep '^pbi_id=' | cut -d'=' -f2 | tr -d '\n\r')
  local task_id_value=$(echo "$vars_lines" | grep '^task_id=' | cut -d'=' -f2 | tr -d '\n\r')
  local title_value=$(echo "$vars_lines" | grep '^title=' | cut -d'=' -f2 | tr -d '\n\r')
  local date_value=$(echo "$vars_lines" | grep '^date=' | cut -d'=' -f2 | tr -d '\n\r')
  local status_value=$(echo "$vars_lines" | grep '^status=' | cut -d'=' -f2 | tr -d '\n\r')
  local version_value=$(echo "$vars_lines" | grep '^version=' | cut -d'=' -f2 | tr -d '\n\r')
  local timestamp_value=$(echo "$vars_lines" | grep '^timestamp=' | cut -d'=' -f2 | tr -d '\n\r')
  
  # Appliquer les remplacements intelligents
  local filtered_content="$content"
  
  # Extraire PBI_ID et ARCH_ID depuis id_value (format: "1-4")
  local pbi_id_only="${id_value%%-*}"    # "1" depuis "1-4"
  local arch_id_only="${id_value##*-}"   # "4" depuis "1-4"
  

  
  # Remplacements de patterns selon le type d'artefact (ordre important!)
  # 1. Remplacements pour TASK (01-PLANIFICATION)
  if [ -n "$full_id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/TASK-\\[PBI_ID\\]-\\[Task_ID\\]/TASK-${full_id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/feature\\/task-\\[PBI_ID\\]-\\[Task_ID\\]/feature\\/task-${full_id_value}/g")
  fi
  if [ -n "$pbi_id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[PBI_ID\\]/${pbi_id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/PBI-\\[PBI_ID\\]/PBI-${pbi_id_value}/g")
  fi
  if [ -n "$task_id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[Task_ID\\]/${task_id_value}/g")
  fi
  
  # 2. Remplacements pour ARCH (02-ARCHITECTURE) 
  if [ -n "$id_value" ]; then
    # Extraire PBI_ID et ARCH_ID depuis id_value (format: "1-4")
    local pbi_id_only="${id_value%%-*}"    # "1" depuis "1-4"
    local arch_id_only="${id_value##*-}"   # "4" depuis "1-4"
    
    filtered_content=$(echo "$filtered_content" | sed "s/ARCH-\\[PBI_ID\\]-\\[ID\\]/ARCH-${id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/ARCH-42-1/ARCH-${id_value}/g")  # Remplacer l'exemple ARCH-42-1
    filtered_content=$(echo "$filtered_content" | sed "s/PBI-42/PBI-${pbi_id_only}/g")   # Remplacer l'exemple PBI-42
    filtered_content=$(echo "$filtered_content" | sed "s/\\[ID\\]/${arch_id_only}/g")
  fi
  
  # 3. Remplacements de patterns g√©n√©riques et titres
  if [ -n "$title_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[Titre d√©crivant le probl√®me architectural\\]/${title_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/\\[Titre technique de la t√¢che\\]/${title_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/%%TITLE%%/${title_value}/g")
  fi
  
  # 4. Remplacements d'ID g√©n√©riques
  if [ -n "$id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/%%ID%%/${id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/PBI-%%ID%%/PBI-${id_value}/g")
  fi
  
  # 5. Remplacements de version (RELEASE)
  if [ -n "$version_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[version\\]/${version_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/v\\[version\\]/v${version_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/vX\\.X\\.X/v${version_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/X\\.X\\.X/${version_value}/g")
  fi
  
  # 6. Remplacements de timestamp (JOURNAL)
  if [ -n "$timestamp_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/HH:MM/${timestamp_value}/g")
  fi
  
  # 7. Remplacements de dates (patterns YYYY-MM-DD et commandes date)
  if [ -n "$date_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/YYYY-MM-DD/${date_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}/${date_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/\$(date +[^)]*))/${date_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/\$(date +'[^']*')/${date_value}/g")
  fi
  
  # Remplacements de statuts
  if [ -n "$status_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/PROPOSED/${status_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/INVESTIGATING/${status_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/ANALYSIS/${status_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/DRAFT/${status_value}/g")
  fi
  
  # Adaptation selon le niveau d'assistance
  case "$assistance_level" in
    "full")
      # Garder tout le contenu avec exemples et instructions
      ;;
    "skeleton")
      # Supprimer les exemples et instructions d√©taill√©es, garder la structure
      filtered_content=$(echo "$filtered_content" | sed 's/(Ex: [^)]*)//g')
      filtered_content=$(echo "$filtered_content" | sed 's/_√Ä compl√©ter[^_]*_/_√Ä compl√©ter_/g')
      ;;
    "minimal")
      # Garder seulement la structure de base, supprimer les d√©tails
      filtered_content=$(echo "$filtered_content" | sed 's/(.*)//')
      filtered_content=$(echo "$filtered_content" | sed 's/_[^_]*_//g')
      filtered_content=$(echo "$filtered_content" | sed '/^$/N;/^\n$/d')
      ;;
  esac
  
  echo "$filtered_content"
}

# Fonction utilitaire : D√©tecter le type d'ID selon le protocole
detect_id_pattern() {
  local protocol_name="$1"
  local base_value="$2"  # Valeur de base (ex: titre pour DEBUG, PBI_ID pour ARCH)
  
  case "$protocol_name" in
    "00-PRODUCT-OWNER")
      # PBI: ID num√©rique simple
      echo "$base_value"
      ;;
    "04-DEBOGAGE")
      # DEBUG: titre-slugifi√©-YYYYMMDD
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "05-REFACTORING")
      # REFACTOR: titre-slugifi√©-YYYYMMDD (m√™me pattern que DEBUG)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "02-ARCHITECTURE")
      # ARCH: PBI_ID-SEQ-STATUS (ex: 1-1-DRAFT)
      echo "$base_value"  # D√©j√† format√© par la commande appelante
      ;;
    "01-PLANIFICATION")
      # TASK: PBI_ID-TASK_SEQ (ex: 1-1)
      echo "$base_value"  # D√©j√† format√© par la commande appelante
      ;;
    "09-RELEASE")
      # RELEASE: Version s√©mantique (ex: 1.2.0)
      echo "$base_value"  # Version d√©j√† format√©e
      ;;
    "18-JOURNAL")
      # JOURNAL: Date YYYY-MM-DD (ex: 2025-01-02)
      echo "$base_value"  # Date d√©j√† format√©e
      ;;
    "07-REVUE-DE-CODE")
      # REVIEW: ID de task ou PR (ex: task-42-1, pr-123)
      echo "$base_value"  # ID d√©j√† format√© par la commande appelante
      ;;
    "10-HOTFIX")
      # HOTFIX: description-slugifi√©e-YYYYMMDD (ex: bug-login-prod-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "06-OPTIMISATION")
      # OPTIM: description-slugifi√©e-YYYYMMDD (ex: api-users-performance-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "13-SECURITE-AUDIT")
      # AUDIT-SECURITY: YYYY-MM-DD (ex: 2025-06-28)
      echo "$(date +%Y-%m-%d)"
      ;;
    "11-EXPERIMENTATION")
      # EXPERIMENT: description-slugifi√©e-YYYYMMDD (ex: button-cta-color-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "17-USER-DOCS")
      # USER-DOCS: description-slugifi√©e-YYYYMMDD (ex: new-payment-feature-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "12-ANALYSE-CONCURRENCE")
      # COMPETITION: description-slugifi√©e-YYYYMMDD (ex: auth-methods-competitors-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "16-TRACKING-PLAN")
      # TRACKING-PLAN: ID du PBI ou de la fonctionnalit√© (ex: PBI-42 ou feature-login)
      echo "$base_value"
      ;;
    "14-ONBOARDING")
      # ONBOARDING: Date au format AAAA-MM-DD
      date +%Y-%m-%d
      ;;
    "15-DEPRECATION")
      # DEPRECATION: description-slugifi√©e-YYYYMMDD (ex: old-billing-api-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "20-FAST-TRACK")
      # FAST-TRACK: description-slugifi√©e-YYYYMMDD (ex: fix-typo-homepage-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "21-META-IMPROVEMENT")
      # META-IMPROVEMENT: description-slugifi√©e-YYYYMMDD (ex: improve-debug-protocol-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    *)
      echo "$base_value"
      ;;
  esac
}

#==============================================================================
# SECTION 1 : FONCTIONS UTILITAIRES H√âRIT√âES
#==============================================================================

# R√©utilisation des fonctions existantes
# TASK-7-3: Version optimis√©e avec cache intelligent
get_next_id() {
  local search_path="$1"
  local prefix="$2"
  
  # Utiliser la version cach√©e si disponible, sinon fallback vers l'ancienne
  if command -v get_next_id_cached >/dev/null 2>&1; then
    get_next_id_cached "$search_path" "$prefix"
  else
    # Fallback vers l'ancienne impl√©mentation
    local last_id
    last_id=$(ls "${search_path}/${prefix}"*-*.md 2>/dev/null | sed -n "s/.*${prefix}-\([0-9]*\)-.*/\1/p" | sort -n | tail -1)
    if [ -z "$last_id" ]; then
      last_id=0
    fi
    local next_id=$((last_id + 1))
    echo "$next_id"
  fi
}

get_config() {
  KEY="$1"
  GLOBAL_CONFIG_FILE="$(dirname "$(realpath "$0")")/../config/.aklo.conf"
  
  find_local_config() {
    local current_dir="$(pwd)"
    while [ "$current_dir" != "/" ]; do
      if [ -f "$current_dir/.aklo.conf" ]; then
        echo "$current_dir/.aklo.conf"
        return 0
      fi
      current_dir="$(dirname "$current_dir")"
    done
    return 1
  }
  
  CONFIG_FILE=$(find_local_config) || CONFIG_FILE="$GLOBAL_CONFIG_FILE"
  if [ ! -f "$CONFIG_FILE" ]; then
    echo "Erreur : Fichier de configuration introuvable." >&2
    exit 1
  fi
  
  sed -n "/^${KEY}=/s/^[^=]*=//p" "$CONFIG_FILE" | tr -d '"'
}

#==============================================================================
# SECTION 2 : FONCTIONS JOURNAL ATOMIQUE
#==============================================================================

# Fonction: update_journal
# R√¥le: Met √† jour le journal quotidien avec une entr√©e de protocole
# Usage: update_journal "PROTOCOLE" "Action" "Description" "Artefacts"
update_journal() {
  PROTOCOL="$1"
  ACTION="$2"
  DESCRIPTION="$3"
  ARTEFACTS="$4"
  
  JOURNAL_DIR="./$(get_config "JOURNAL_DIR")"
  TODAY=$(date +%Y-%m-%d)
  JOURNAL_FILE="${JOURNAL_DIR}/JOURNAL-${TODAY}.md"
  TIMESTAMP=$(date +%H:%M)
  
  # Cr√©er le r√©pertoire journal si n√©cessaire
  mkdir -p "$JOURNAL_DIR"
  
  # Cr√©er le fichier journal du jour si n√©cessaire avec le parser g√©n√©rique
  if [ ! -f "$JOURNAL_FILE" ]; then
    local context_vars="date=${TODAY},timestamp=${TIMESTAMP}"
    parse_and_generate_artefact "18-JOURNAL" "JOURNAL" "full" "$JOURNAL_FILE" "$context_vars"
    
    if [ $? -ne 0 ]; then
      echo "‚ö†Ô∏è Fallback vers g√©n√©ration statique JOURNAL" >&2
      # Fallback statique si le parser √©choue
      cat > "$JOURNAL_FILE" << EOF
# JOURNAL DE TRAVAIL : ${TODAY}
---
**Responsable:** Human_Developer
**Objectif(s) de la journ√©e:** [√Ä d√©finir]
---

## Entr√©es Chronologiques

### ${TIMESTAMP} - D√©but de session

- **Action :** Ouverture du journal quotidien
- **Contexte :** Premi√®re utilisation du syst√®me de journal int√©gr√©

EOF
    fi
  fi
  
  # Ajouter l'entr√©e de protocole (structure extraite du protocole)
  cat >> "$JOURNAL_FILE" << EOF
### ${TIMESTAMP} - [${PROTOCOL}] ${ACTION}

- **Action :** ${DESCRIPTION}
- **Artefacts :** ${ARTEFACTS}
- **Timestamp :** ${TODAY} ${TIMESTAMP}

EOF
}

#==============================================================================
# SECTION 2.5 : FONCTIONS TDD ET COMMITS ATOMIQUES
#==============================================================================

# Fonction centralis√©e de validation TDD
validate_tdd() {
  local validation_level="$1"  # "full", "basic", "optional"
  local protocol_name="$2"     # Pour les logs
  
  echo "üîç Validation TDD ($validation_level) pour protocole $protocol_name..."
  
  local validation_failed=false
  local validate_linter=$(get_config "VALIDATE_LINTER")
  local validate_tests=$(get_config "VALIDATE_TESTS") 
  local validate_build=$(get_config "VALIDATE_BUILD")
  
  # Validation linter (si activ√©e et commande disponible)
  if [ "$validate_linter" = "true" ]; then
    local linter_cmd=$(get_config "LINTER_COMMAND")
    if command -v ${linter_cmd%% *} >/dev/null 2>&1; then
      echo "  üìã Validation linter..."
      if ! eval "$linter_cmd" >/dev/null 2>&1; then
        if [ "$validation_level" = "optional" ]; then
          echo "  ‚ö†Ô∏è  Linter √©chou√© (ignor√© en mode optional)"
        else
          echo "  ‚ùå Linter √©chou√©"
          validation_failed=true
        fi
      else
        echo "  ‚úÖ Linter valid√©"
      fi
    else
      echo "  ‚ö†Ô∏è  Commande linter non trouv√©e: $linter_cmd"
    fi
  fi
  
  # Validation tests (si activ√©e et commande disponible)
  if [ "$validate_tests" = "true" ]; then
    local test_cmd=$(get_config "TEST_COMMAND")
    if command -v ${test_cmd%% *} >/dev/null 2>&1; then
      echo "  üß™ Validation tests..."
      if ! eval "$test_cmd" >/dev/null 2>&1; then
        if [ "$validation_level" = "optional" ]; then
          echo "  ‚ö†Ô∏è  Tests √©chou√©s (ignor√©s en mode optional)"
        else
          echo "  ‚ùå Tests √©chou√©s"
          validation_failed=true
        fi
      else
        echo "  ‚úÖ Tests valid√©s"
      fi
    else
      echo "  ‚ö†Ô∏è  Commande tests non trouv√©e: $test_cmd"
    fi
  fi
  
  # Validation build (uniquement pour niveau "full")
  if [ "$validation_level" = "full" ] && [ "$validate_build" = "true" ]; then
    local build_cmd=$(get_config "BUILD_COMMAND")
    if command -v ${build_cmd%% *} >/dev/null 2>&1; then
      echo "  üèóÔ∏è  Validation build..."
      if ! eval "$build_cmd" >/dev/null 2>&1; then
        echo "  ‚ùå Build √©chou√©"
        validation_failed=true
      else
        echo "  ‚úÖ Build valid√©"
      fi
    else
      echo "  ‚ö†Ô∏è  Commande build non trouv√©e: $build_cmd"
    fi
  fi
  
  if [ "$validation_failed" = "true" ]; then
    echo "‚ùå Validation TDD √©chou√©e pour $protocol_name"
    return 1
  else
    echo "‚úÖ Validation TDD r√©ussie pour $protocol_name"
    return 0
  fi
}

# Fonction centralis√©e pour les commits atomiques
handle_auto_backup() {
  local commit_message="$1"
  local protocol_name="$2"
  local auto_backup="${PARSED_AUTO_BACKUP:-$(get_config "AUTO_BACKUP")}"
  
  echo "üîç DEBUG: PARSED_AUTO_BACKUP='$PARSED_AUTO_BACKUP', auto_backup='$auto_backup'"
  
  if [ "$auto_backup" = "true" ]; then
    echo "ü§ñ Mode automatique activ√© - Commit atomique en cours..."
    git add .
    if git commit -m "$commit_message"; then
      echo "‚úÖ Commit atomique effectu√© automatiquement"
      echo "   Message: $commit_message"
      return 0
    else
      echo "‚ùå √âchec du commit automatique"
      return 1
    fi
  else
    echo "üë§ Mode validation humaine - Pr√©sentation du diff..."
    echo ""
    echo "üìã DIFF √Ä VALIDER :"
    echo "=================="
    git add .
    git diff --cached
    echo ""
    echo "üí¨ Message de commit propos√© :"
    echo "   $commit_message"
    echo ""
    echo "‚ùì Voulez-vous proc√©der au commit ? (y/N)"
    read -r response
    case "$response" in
      [yY]|[yY][eE][sS])
        if git commit -m "$commit_message"; then
          echo "‚úÖ Commit atomique valid√© et effectu√©"
          return 0
        else
          echo "‚ùå √âchec du commit"
          return 1
        fi
        ;;
      *)
        echo "‚ùå Commit annul√© par l'utilisateur"
        git reset HEAD .
        return 1
        ;;
    esac
  fi
}

# Fonction pour parser les arguments de validation et backup
parse_validation_args() {
  local default_validation="$1"  # "full", "basic", "optional", "none"
  local validation_level="$default_validation"
  local auto_backup=$(get_config "AUTO_BACKUP")
  local skip_validation=false
  
  # Parser les arguments CLI
  while [ $# -gt 0 ]; do
    case "$1" in
      --no-validation)
        skip_validation=true
        validation_level="none"
        ;;
      --force-validation)
        skip_validation=false
        validation_level="full"
        ;;
      --auto-commit)
        auto_backup="true"
        ;;
      --manual-commit)
        auto_backup="false"
        ;;
      *)
        # Argument non reconnu, le laisser pour le parsing principal
        break
        ;;
    esac
    shift
  done
  
  # Exporter les variables pour utilisation dans les commandes
  export PARSED_VALIDATION_LEVEL="$validation_level"
  export PARSED_AUTO_BACKUP="$auto_backup"
  export PARSED_SKIP_VALIDATION="$skip_validation"
}

#==============================================================================
# SECTION 3 : COMMANDES AVEC COMMITS ATOMIQUES
#==============================================================================

# Commande: init (Nouvelle impl√©mentation)
# Initialise le projet Aklo dans le r√©pertoire courant
command_init() {
  echo "üîß Initialisation du projet Aklo..."

  CONFIG_FILE=".aklo.conf"
  GITIGNORE_FILE=".gitignore"
  DEFAULT_CONFIG_FILE="${script_dir}/../config/.aklo.conf"

  # 1. G√©rer .aklo.conf
  if [ -f "$CONFIG_FILE" ]; then
    echo "Un fichier .aklo.conf existe d√©j√†. Voulez-vous l'√©craser ? (y/N)"
    read -r response
    if [[ ! "$response" =~ ^([yY][eE][sS]|[yY])$ ]]; then
      echo "‚ùå Initialisation annul√©e."
      exit 1
    fi
  fi
  
  if [ -f "$DEFAULT_CONFIG_FILE" ]; then
    cp "$DEFAULT_CONFIG_FILE" "$CONFIG_FILE"
    echo "‚úÖ Fichier .aklo.conf cr√©√©."
  else
    echo "‚ùå Fichier de configuration par d√©faut non trouv√©: $DEFAULT_CONFIG_FILE"
    exit 1
  fi

  # 2. G√©rer .gitignore
  echo "üîí Configuration de .gitignore..."
  touch "$GITIGNORE_FILE"
  
  gitignore_patterns=(
    ".aklo.conf"
    "*.log"
    "/docs/backlog/19-scratchpad/*"
    "!.gitkeep"
  )
  
  for pattern in "${gitignore_patterns[@]}"; do
    if ! grep -qF -- "$pattern" "$GITIGNORE_FILE"; then
      echo "$pattern" >> "$GITIGNORE_FILE"
      echo "  + Ajout de '$pattern' √† .gitignore"
    fi
  done
  echo "‚úÖ .gitignore configur√©."
  
  echo "üéâ Projet Aklo initialis√© avec succ√®s."
}

# Commande: plan (Version 2.0 - Commit Atomique)
# Impl√©mente le protocole PLANIFICATION avec commit atomique unique
command_plan() {
  if [ -z "$1" ]; then
    echo "Erreur : L'ID du PBI est requis (ex: 42)." >&2
    exit 1
  fi
  PBI_ID="$1"
  
  # D√©tection du niveau d'assistance
  AGENT_ASSISTANCE=$(get_config "AGENT_ASSISTANCE")
  AUTO_JOURNAL=$(get_config "AUTO_JOURNAL")
  
  # Parsing des arguments
  shift
  while [ $# -gt 0 ]; do
    case "$1" in
      --no-agent)
        AGENT_ASSISTANCE="skeleton"
        ;;
      --no-journal)
        AUTO_JOURNAL="false"
        ;;
      *)
        echo "Argument inconnu: $1" >&2
        exit 1
        ;;
    esac
    shift
  done
  
  # Override depuis la configuration si pr√©sente
  CONFIG_ASSISTANCE=$(get_config "AGENT_ASSISTANCE" 2>/dev/null || echo "")
  CONFIG_JOURNAL=$(get_config "AUTO_JOURNAL" 2>/dev/null || echo "")
  
  if [ -n "$CONFIG_ASSISTANCE" ]; then
    AGENT_ASSISTANCE="$CONFIG_ASSISTANCE"
  fi
  if [ -n "$CONFIG_JOURNAL" ]; then
    AUTO_JOURNAL="$CONFIG_JOURNAL"
  fi
  
  echo "--- PLANIFICATION v2.0 (Commit Atomique) ---"
  echo "‚Ä∫ PBI: ${PBI_ID}"
  echo "‚Ä∫ Assistance: ${AGENT_ASSISTANCE}"
  echo "‚Ä∫ Journal automatique: ${AUTO_JOURNAL}"
  echo ""
  
  # Validation du PBI
  PBI_FILE=$(ls ./docs/backlog/00-pbi/PBI-${PBI_ID}-*.md 2>/dev/null | head -1)
  if [ ! -f "$PBI_FILE" ]; then
    echo "Erreur : PBI ${PBI_ID} introuvable." >&2
    exit 1
  fi
  
  # Pr√©paration des variables pour le commit atomique
  CREATED_TASKS=""
  MODIFIED_FILES=""
  TASK_COUNT=0
  
  echo "--- Phase 1: Cr√©ation des Tasks ---"
  
  case "$AGENT_ASSISTANCE" in
    "full")
      echo "Mode FULL: L'IA va g√©n√©rer le contenu complet des tasks."
      echo "TODO: Int√©gration avec le serveur MCP pour g√©n√©ration automatique"
      ;;
    "skeleton")
      echo "Mode SKELETON: Cr√©ation de la structure des tasks √† compl√©ter."
      ;;
    "minimal")
      echo "Mode MINIMAL: Cr√©ation des fichiers avec IDs uniquement."
      ;;
  esac
  
  # Boucle de cr√©ation interactive (simplifi√©e pour la d√©mo)
  while true; do
    printf "  ‚Ä∫ Titre de la nouvelle t√¢che (vide pour terminer): "
    read -r TASK_TITLE
    
    if [ -z "$TASK_TITLE" ]; then
      break
    fi
    
    TASK_COUNT=$((TASK_COUNT + 1))
    TASK_ID=$(printf "%02d" $TASK_COUNT)
    TASK_FILENAME="TASK-${PBI_ID}-${TASK_ID}-TODO.md"
    TASK_PATH="./docs/backlog/01-tasks/${TASK_FILENAME}"
    
    # Cr√©ation du fichier Task selon le niveau d'assistance
    mkdir -p "./docs/backlog/01-tasks"
    
    # G√©n√©ration dynamique depuis le protocole PLANIFICATION
    local task_full_id="${PBI_ID}-${TASK_ID}"
    local context_vars="pbi_id=${PBI_ID},task_id=${TASK_ID},full_id=${task_full_id},title=${TASK_TITLE},status=TODO"
    
    parse_and_generate_artefact "01-PLANIFICATION" "TASK" "$AGENT_ASSISTANCE" "$TASK_PATH" "$context_vars"
    
    # V√©rification du succ√®s de g√©n√©ration
    if [ $? -ne 0 ]; then
      echo "‚ùå Erreur : √âchec de g√©n√©ration TASK depuis le protocole PLANIFICATION" >&2
      echo "   V√©rifiez l'int√©grit√© du protocole et r√©essayez" >&2
      return 1
    fi
    
    CREATED_TASKS="${CREATED_TASKS}${TASK_FILENAME} "
    MODIFIED_FILES="${MODIFIED_FILES}${TASK_PATH} "
    echo "  ‚úì Task cr√©√©e: ${TASK_FILENAME}"
  done
  
  if [ $TASK_COUNT -eq 0 ]; then
    echo "Aucune task cr√©√©e. Abandon."
    exit 0
  fi
  
  echo ""
  echo "--- Phase 2: Mise √† jour du PBI ---"
  
  # Mise √† jour du PBI avec la liste des tasks
  cp "$PBI_FILE" "${PBI_FILE}.backup"
  
  # Ajout de la section Tasks si elle n'existe pas
  if ! grep -q "## Tasks Associ√©es" "$PBI_FILE"; then
    cat >> "$PBI_FILE" << EOF

## Tasks Associ√©es

EOF
  fi
  
  # Ajout des tasks cr√©√©es
  for task_file in $CREATED_TASKS; do
    task_id=$(echo "$task_file" | sed 's/TASK-\([^-]*-[^-]*\)-.*/\1/')
    echo "- TASK-${task_id}: [Cr√©√©e]" >> "$PBI_FILE"
  done
  
  MODIFIED_FILES="${MODIFIED_FILES}${PBI_FILE} "
  echo "  ‚úì PBI mis √† jour avec ${TASK_COUNT} tasks"
  
  # Phase 3: Mise √† jour du journal
  if [ "$AUTO_JOURNAL" = "true" ]; then
    echo ""
    echo "--- Phase 3: Mise √† jour du journal ---"
    
    JOURNAL_DESCRIPTION="D√©composition PBI-${PBI_ID} en ${TASK_COUNT} tasks techniques (mode: ${AGENT_ASSISTANCE})"
    JOURNAL_ARTEFACTS="PBI-${PBI_ID} mis √† jour, ${TASK_COUNT} tasks cr√©√©es: ${CREATED_TASKS}"
    
    update_journal "PLANIFICATION" "D√©composition PBI" "$JOURNAL_DESCRIPTION" "$JOURNAL_ARTEFACTS"
    
    JOURNAL_FILE="./docs/backlog/15-journal/JOURNAL-$(date +%Y-%m-%d).md"
    MODIFIED_FILES="${MODIFIED_FILES}${JOURNAL_FILE} "
    echo "  ‚úì Journal mis √† jour"
  fi
  
  # Phase 4: Validation et commit atomique
  echo ""
  echo "--- Phase 4: Pr√©paration du commit atomique ---"
  echo "Fichiers √† committer:"
  for file in $MODIFIED_FILES; do
    echo "  - $file"
  done
  echo ""
  
  printf "Voulez-vous cr√©er le commit atomique de planification ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Commit annul√©. Fichiers conserv√©s pour r√©vision manuelle."
    exit 0
  fi
  
  # Cr√©ation du commit atomique
  git add $MODIFIED_FILES
  
  COMMIT_MSG="feat(planning): D√©composition PBI-${PBI_ID} en ${TASK_COUNT} tasks

- Cr√©ation de ${TASK_COUNT} tasks techniques (mode: ${AGENT_ASSISTANCE})
- PBI-${PBI_ID} mis √† jour avec la liste des tasks associ√©es"

  if [ "$AUTO_JOURNAL" = "true" ]; then
    COMMIT_MSG="${COMMIT_MSG}
- Journal mis √† jour avec le processus de planification"
  fi

  COMMIT_MSG="${COMMIT_MSG}

Tasks cr√©√©es:"
  for task_file in $CREATED_TASKS; do
    task_title=$(head -1 "./docs/backlog/01-tasks/$task_file" | sed 's/# //')
    COMMIT_MSG="${COMMIT_MSG}
- $task_title"
  done

  COMMIT_MSG="${COMMIT_MSG}

Prochaine √©tape: DEVELOPPEMENT"
  
  git commit -m "$COMMIT_MSG"
  
  echo ""
  echo "üéâ Planification termin√©e avec commit atomique !"
  echo "   ${TASK_COUNT} tasks cr√©√©es pour PBI-${PBI_ID}"
  echo "   Commit: $(git rev-parse --short HEAD)"
}

#==============================================================================
# SECTION 4 : COMMANDE RELEASE V2.0
#==============================================================================

# Commande: release (Version 2.0 - Workflow S√©quentiel + Commit Atomique)
command_release() {
  if [ -z "$1" ]; then
    echo "Erreur : Le type de release est requis (major, minor, patch)." >&2
    exit 1
  fi
  BUMP_TYPE="$1"
  
  # Parser les arguments de validation et backup
  parse_validation_args "full" "$@"
  
  echo "--- RELEASE v2.0 (Workflow S√©quentiel + Commit Atomique) ---"
  
  # Phase 1: Pr√©paration locale (sans commit)
  echo "--- Phase 1: Pr√©paration locale ---"
  
  CURRENT_VERSION=$(grep '"version"' package.json | sed 's/.*"version": "\([^"]*\)".*/\1/' || echo "0.0.0")
  
  case "$BUMP_TYPE" in
    "major")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print ($1+1)".0.0"}')
      ;;
    "minor")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print $1"."($2+1)".0"}')
      ;;
    "patch")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print $1"."$2"."($3+1)}')
      ;;
    *)
      echo "Erreur : Type de release invalide. Utilisez major, minor ou patch." >&2
      exit 1
      ;;
  esac
  
  echo "  ‚Ä∫ Version actuelle: ${CURRENT_VERSION}"
  echo "  ‚Ä∫ Nouvelle version: ${NEW_VERSION}"
  
  # Pr√©paration des fichiers (sans commit)
  RELEASE_DIR="./$(get_config "RELEASES_DIR")"
  mkdir -p "$RELEASE_DIR"
  RELEASE_FILE="${RELEASE_DIR}/RELEASE-${NEW_VERSION}-AWAITING_DEPLOYMENT.md"
  
  # G√©n√©ration dynamique depuis le protocole RELEASE
  local context_vars="version=${NEW_VERSION},type=${BUMP_TYPE},date=$(date +%Y-%m-%d),status=AWAITING_DEPLOYMENT"
  
  parse_and_generate_artefact "09-RELEASE" "RELEASE" "full" "$RELEASE_FILE" "$context_vars"
  
  # V√©rification du succ√®s de g√©n√©ration
  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration RELEASE depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole 09-RELEASE" >&2
    return 1
  fi
  
  # Mise √† jour du CHANGELOG (simplifi√©)
  if [ ! -f "CHANGELOG.md" ]; then
    echo "# CHANGELOG" > CHANGELOG.md
    echo "" >> CHANGELOG.md
  fi
  
  # Ajout de la nouvelle version au CHANGELOG
  sed -i.bak "2i\\
\\
## [${NEW_VERSION}] - $(date +%Y-%m-%d)\\
\\
### Added\\
- [√Ä compl√©ter]\\
\\
### Changed\\
- [√Ä compl√©ter]\\
\\
### Fixed\\
- [√Ä compl√©ter]\\
" CHANGELOG.md
  
  # Mise √† jour de la version dans package.json
  if [ -f "package.json" ]; then
    sed -i.bak "s/\"version\": \"${CURRENT_VERSION}\"/\"version\": \"${NEW_VERSION}\"/" package.json
  fi
  
  echo "  ‚úì Rapport de release cr√©√©"
  echo "  ‚úì CHANGELOG.md mis √† jour"
  echo "  ‚úì Version mise √† jour dans package.json"
  
  # Phase 2: Validation technique TDD (sans commit)
  echo ""
  echo "--- Phase 2: Validation technique TDD ---"
  
  # Validation TDD compl√®te pour release (obligatoire)
  if [ "$PARSED_VALIDATION_LEVEL" != "none" ]; then
    if ! validate_tdd "$PARSED_VALIDATION_LEVEL" "RELEASE"; then
      echo "‚ùå Validation TDD √©chou√©e pour la release"
      echo "   La release ne peut pas continuer sans validation compl√®te"
      exit 1
    fi
  else
    echo "‚ö†Ô∏è  Validation TDD d√©sactiv√©e (--no-validation)"
    echo "   ATTENTION: Release sans validation compl√®te"
  fi
  
  echo "  ‚úì Validation technique TDD r√©ussie"
  
  # Phase 3: Mise √† jour du journal
  echo ""
  echo "--- Phase 3: Mise √† jour du journal ---"
  
  JOURNAL_DESCRIPTION="Pr√©paration release v${NEW_VERSION} (type: ${BUMP_TYPE})"
  JOURNAL_ARTEFACTS="RELEASE-${NEW_VERSION}, CHANGELOG.md, package.json"
  
  update_journal "RELEASE" "Pr√©paration release" "$JOURNAL_DESCRIPTION" "$JOURNAL_ARTEFACTS"
  echo "  ‚úì Journal mis √† jour"
  
  # Phase 4: Commit atomique intelligent
  echo ""
  echo "--- Phase 4: Commit atomique de release ---"
  
  COMMIT_MSG="release: Version ${NEW_VERSION}

Release ${BUMP_TYPE} v${NEW_VERSION} pr√©par√©e et valid√©e.

- Rapport RELEASE-${NEW_VERSION} finalis√©
- CHANGELOG.md mis √† jour avec nouvelles fonctionnalit√©s
- Version mise √† jour : ${CURRENT_VERSION} ‚Üí ${NEW_VERSION}
- Journal mis √† jour avec le processus de release
- Tous les tests passent, build de production valid√©

Type de release: ${BUMP_TYPE}
- Validation TDD: ${PARSED_VALIDATION_LEVEL}"

  # Utiliser la fonction centralis√©e pour le commit atomique
  if ! handle_auto_backup "$COMMIT_MSG" "RELEASE"; then
    echo "‚ùå √âchec du commit atomique de release"
    exit 1
  fi
  
  # Cr√©ation du tag (apr√®s commit r√©ussi)
  git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
  
  echo ""
  echo "üéâ Release v${NEW_VERSION} cr√©√©e avec succ√®s !"
  echo "   Commit: $(git rev-parse --short HEAD)"
  echo "   Tag: v${NEW_VERSION}"
  echo ""
  echo "Prochaines √©tapes:"
  echo "  1. git push origin main"
  echo "  2. git push origin v${NEW_VERSION}"
  echo "  3. D√©ploiement en production"
}

# Commande: scratch - Cr√©ation de scratchpad pour brainstorming
command_scratch() {
  local topic="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$topic" in
    "--help"|"help"|"")
      echo "Usage: aklo scratch \"<sujet>\" [--template=TYPE]"
      echo ""
      echo "Cr√©ation de scratchpad pour brainstorming selon le protocole SCRATCHPAD."
      echo ""
      echo "Arguments:"
      echo "  sujet        Sujet du brainstorming (requis)"
      echo ""
      echo "Options:"
      echo "  --template=TYPE    Type de template (brainstorm|analysis|problem)"
      echo "  --no-agent         Assistance minimale (skeleton)"
      echo "  --no-journal       D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo scratch \"Optimisation performance login\""
      echo "  aklo scratch \"Architecture microservices\" --template=analysis"
      echo "  aklo scratch \"Bug intermittent cache\" --template=problem"
      echo ""
      echo "Templates disponibles:"
      echo "  brainstorm - Session de brainstorming libre"
      echo "  analysis   - Analyse structur√©e d'un probl√®me"
      echo "  problem    - R√©solution de probl√®me complexe"
      echo ""
      echo "Workflow:"
      echo "  1. Cr√©ation du fichier SCRATCHPAD-[ID]-[TOPIC].md"
      echo "  2. Structure selon template choisi"
      echo "  3. Brainstorming et documentation"
      echo "  4. Extraction d'actions concr√®tes (PBI/TASK)"
      return 0
      ;;
  esac

  # Parsing des arguments
  shift
  local template_type="brainstorm"
  while [ $# -gt 0 ]; do
    case "$1" in
      --template=*)
        template_type="${1#--template=}"
        ;;
      --no-agent)
        agent_assistance="skeleton"
        ;;
      --no-journal)
        auto_journal="false"
        ;;
      *)
        echo "Argument inconnu: $1" >&2
        return 1
        ;;
    esac
    shift
  done

  # Validation du template
  case "$template_type" in
    brainstorm|analysis|problem)
      # Templates valides
      ;;
    *)
      echo "‚ùå Template invalide: $template_type"
      echo "   Templates disponibles: brainstorm, analysis, problem"
      return 1
      ;;
  esac

  # Configuration et g√©n√©ration d'ID
  local scratchpad_dir="./$(get_config "SCRATCHPAD_DIR")"
  local date_id=$(date +%Y%m%d)
  local topic_clean=$(echo "$topic" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
  local scratchpad_id="${date_id}-${topic_clean}"
  local scratchpad_file="${scratchpad_dir}/SCRATCHPAD-${scratchpad_id}.md"
  
  # Cr√©er le r√©pertoire si n√©cessaire
  mkdir -p "$scratchpad_dir"
  
  if [ -f "$scratchpad_file" ]; then
    echo "‚ö†Ô∏è  Le scratchpad existe d√©j√†: $scratchpad_file"
    echo "   Ouverture du fichier existant..."
    return 0
  fi

  echo "üß† Cr√©ation du scratchpad: SCRATCHPAD-${scratchpad_id}"
  echo "üìã Sujet: $topic"
  echo "üéØ Template: $template_type"

  # G√©n√©ration du contenu selon template et niveau d'assistance
  local today=$(date +%Y-%m-%d)
  local context_vars="id=${scratchpad_id},topic=${topic},template=${template_type},date=${today}"
  
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole SCRATCHPAD..."
      parse_and_generate_artefact "19-SCRATCHPAD" "SCRATCHPAD" "full" "$scratchpad_file" "$context_vars"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      parse_and_generate_artefact "19-SCRATCHPAD" "SCRATCHPAD" "skeleton" "$scratchpad_file" "$context_vars"
      ;;
    "minimal")
      echo "üß† Structure minimale selon protocole..."
      parse_and_generate_artefact "19-SCRATCHPAD" "SCRATCHPAD" "minimal" "$scratchpad_file" "$context_vars"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "SCRATCHPAD" "Brainstorming: $topic" "Template: $template_type" "SCRATCHPAD-${scratchpad_id}.md"
  fi

  echo ""
  echo "‚úÖ SCRATCHPAD-${scratchpad_id}.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $scratchpad_file"
  echo ""
  echo "üß† Prochaines √©tapes:"
  echo "  1. Ouvrir le fichier: $scratchpad_file"
  echo "  2. Documenter vos r√©flexions et id√©es"
  echo "  3. Identifier les actions concr√®tes"
  echo "  4. Cr√©er des PBI/TASK pour les actions retenues"
  echo ""
  echo "üí° RAPPEL: Le scratchpad est temporaire, extrayez les actions importantes !"
}

#==============================================================================
# SECTION 4 : COMMANDES SYST√àME (P1 - Priorit√© maximale)
#==============================================================================

# Commande: status - Tableau de bord complet du projet
command_status() {
  local mode="${1:-standard}"
  local script_dir="$(dirname "$(realpath "$0")")"
  
  case "$mode" in
    "--help")
      echo "Usage: aklo status [--brief|--detailed|--json]"
      echo ""
      echo "Affiche le tableau de bord complet du projet aklo."
      echo ""
      echo "Options:"
      echo "  --brief, -b     Affichage condens√©"
      echo "  --detailed, -d  Affichage d√©taill√© avec m√©triques"
      echo "  --json          Sortie au format JSON"
      exit 0
      ;;
    *)
      # D√©l√©guer au script sp√©cialis√© pour tous les modes
      # Optimisation TASK-7-2: Utiliser batch_check_existence pour v√©rifier les scripts UX
      local status_script="$script_dir/../modules/ux/status-command.sh"
      if command -v batch_check_existence >/dev/null 2>&1; then
        local check_result=$(batch_check_existence "$status_script")
        if echo "$check_result" | grep -q "exists"; then
          . "$status_script"
          aklo_status "${mode:-standard}"
        else
          echo "Erreur : Script status-command.sh introuvable." >&2
          exit 1
        fi
      else
        # Fallback classique si batch I/O non disponible
        if [ -f "$status_script" ]; then
          . "$status_script"
          aklo_status "${mode:-standard}"
        else
          echo "Erreur : Script status-command.sh introuvable." >&2
          exit 1
        fi
      fi
      ;;
  esac
}

# Commande: mcp - Gestion des serveurs MCP
command_mcp() {
  local action="$1"
  local script_dir="$(dirname "$(realpath "$0")")"
  
  # Optimisation TASK-7-2: V√©rification batch des scripts MCP
  local mcp_scripts=(
    "$script_dir/../modules/mcp/setup-mcp.sh"
    "$script_dir/../modules/mcp/restart-mcp.sh"
    "$script_dir/../modules/mcp/watch-mcp.sh"
  )
  
  local mcp_check_result=""
  if command -v batch_check_existence >/dev/null 2>&1; then
    mcp_check_result=$(batch_check_existence "${mcp_scripts[@]}")
  fi

  case "$action" in
    "setup")
      echo "üîß Configuration des serveurs MCP..."
      if [ -n "$mcp_check_result" ] && echo "$mcp_check_result" | grep -q "setup-mcp.sh exists"; then
        "${mcp_scripts[0]}"
      elif [ -f "${mcp_scripts[0]}" ]; then
        "${mcp_scripts[0]}"
      else
        echo "Erreur : Script setup-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "restart")
      echo "üîÑ Red√©marrage des serveurs MCP..."
      if [ -n "$mcp_check_result" ] && echo "$mcp_check_result" | grep -q "restart-mcp.sh exists"; then
        "${mcp_scripts[1]}"
      elif [ -f "${mcp_scripts[1]}" ]; then
        "${mcp_scripts[1]}"
      else
        echo "Erreur : Script restart-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "watch")
      echo "üëÅÔ∏è Surveillance des serveurs MCP..."
      if [ -n "$mcp_check_result" ] && echo "$mcp_check_result" | grep -q "watch-mcp.sh exists"; then
        "${mcp_scripts[2]}"
      elif [ -f "${mcp_scripts[2]}" ]; then
        "${mcp_scripts[2]}"
      else
        echo "Erreur : Script watch-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo mcp <action>"
      echo ""
      echo "Gestion des serveurs MCP (Model Context Protocol)."
      echo ""
      echo "Actions:"
      echo "  setup     Configuration initiale des serveurs MCP"
      echo "  restart   Red√©marrage des serveurs apr√®s modification"
      echo "  watch     Surveillance en temps r√©el des serveurs"
      echo ""
      echo "Exemples:"
      echo "  aklo mcp setup      # Configuration initiale"
      echo "  aklo mcp restart    # Apr√®s modification du code MCP"
      echo "  aklo mcp watch      # Surveillance continue"
      exit 0
      ;;
    *)
      echo "Erreur : Action MCP inconnue '$action'." >&2
      echo "Utilisez 'aklo mcp help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: validate - Validation de projets et artefacts
command_validate() {
  local target="${1:-.}"
  local script_dir="$(dirname "$(realpath "$0")")"
  
  case "$target" in
    "--help")
      echo "Usage: aklo validate [path]"
      echo ""
      echo "Valide la structure et la coh√©rence du projet aklo."
      echo ""
      echo "Arguments:"
      echo "  path    Chemin √† valider (d√©faut: r√©pertoire courant)"
      echo ""
      echo "Validations effectu√©es:"
      echo "  ‚Ä¢ Structure des r√©pertoires aklo"
      echo "  ‚Ä¢ Coh√©rence des artefacts (PBI, TASK, etc.)"
      echo "  ‚Ä¢ Respect des protocoles de la charte"
      echo "  ‚Ä¢ Configuration .aklo.conf"
      exit 0
      ;;
    *)
      echo "üîç Validation du projet aklo..."
      if [ -f "$script_dir/../modules/ux/validation.sh" ]; then
        "$script_dir/../modules/ux/validation.sh" "$target"
      else
        echo "Erreur : Script validation.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: cache - Gestion du cache intelligent (TASK-6-4)
command_cache() {
  local action="$1"
  
  case "$action" in
    "status")
      show_cache_status
      ;;
    "clear")
      clear_cache
      ;;
    "benchmark")
      benchmark_cache
      ;;
    "dashboard")
      # TASK-7-4: Dashboard I/O monitoring
      if command -v show_io_dashboard >/dev/null 2>&1; then
        show_io_dashboard
      else
        echo "‚ùå Dashboard I/O non disponible - module monitoring non charg√©" >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo cache <action>"
      echo ""
      echo "Gestion du cache intelligent du parser aklo."
      echo ""
      echo "Actions:"
      echo "  status      Affiche les statistiques du cache"
      echo "  clear       Vide compl√®tement le cache"
      echo "  benchmark   Teste les performances avec/sans cache"
      echo "  dashboard   Affiche le dashboard de monitoring I/O"
      echo "  --help      Affiche cette aide"
      echo ""
      echo "Configuration:"
      echo "  Le cache est configur√© dans .aklo.conf"
      echo "  Section [cache] avec enabled, cache_dir, ttl_days, etc."
      echo ""
      echo "Exemples:"
      echo "  aklo cache status      # Voir les statistiques"
      echo "  aklo cache clear       # Vider le cache"
      echo "  aklo cache benchmark   # Tester les performances"
      echo "  aklo cache dashboard   # Dashboard monitoring I/O"
      ;;
    *)
      echo "Action inconnue: $action" >&2
      echo "Utilisez 'aklo cache --help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: config - Gestion de la configuration de performance
command_config() {
  local action="$1"
  
  case "$action" in
    "tune")
      echo "üîß Auto-tuning des param√®tres de performance..."
      if command -v auto_tune_performance >/dev/null 2>&1; then
        auto_tune_performance
        echo "‚úÖ Auto-tuning termin√©"
        echo "üìä Utiliser 'aklo config diagnose' pour voir les r√©sultats"
      else
        echo "‚ùå Syst√®me de tuning non disponible" >&2
        exit 1
      fi
      ;;
    "profile")
      local profile="$2"
      if [[ -z "$profile" ]]; then
        echo "‚ùå Profil requis: dev, test, ou prod" >&2
        echo "Usage: aklo config profile <dev|test|prod>"
        exit 1
      fi
      echo "üéØ Application du profil: $profile"
      if command -v apply_performance_profile >/dev/null 2>&1; then
        apply_performance_profile "$profile"
        echo "‚úÖ Profil $profile appliqu√©"
      else
        echo "‚ùå Syst√®me de profils non disponible" >&2
        exit 1
      fi
      ;;
    "diagnose")
      echo "üîç Diagnostic m√©moire et performance..."
      if command -v get_memory_diagnostics >/dev/null 2>&1; then
        get_memory_diagnostics
      else
        echo "‚ùå Syst√®me de diagnostic non disponible" >&2
        exit 1
      fi
      ;;
    "validate")
      echo "‚úÖ Validation de la configuration..."
      if command -v validate_performance_config >/dev/null 2>&1; then
        if validate_performance_config; then
          echo "‚úÖ Configuration valide"
        else
          echo "‚ùå Configuration invalide"
          exit 1
        fi
      else
        echo "‚ùå Syst√®me de validation non disponible" >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo config <action>"
      echo ""
      echo "Gestion de la configuration de performance et tuning."
      echo ""
      echo "Actions:"
      echo "  tune              Auto-tuning selon l'environnement"
      echo "  profile <env>     Appliquer un profil (dev|test|prod)"
      echo "  diagnose          Diagnostic m√©moire et performance"
      echo "  validate          Valider la configuration actuelle"
      echo ""
      echo "Exemples:"
      echo "  aklo config tune"
      echo "  aklo config profile prod"
      echo "  aklo config diagnose"
      echo "  aklo config validate"
      exit 0
      ;;
    *)
      echo "Action inconnue: $action" >&2
      echo "Utilisez 'aklo config --help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: monitor - Monitoring et m√©triques de performance
command_monitor() {
  local action="$1"
  
  case "$action" in
    "dashboard"|"dash")
      echo "üìä Dashboard I/O Monitoring..."
      if command -v show_io_dashboard >/dev/null 2>&1; then
        show_io_dashboard
      else
        echo "‚ùå Dashboard I/O non disponible - module monitoring non charg√©" >&2
        exit 1
      fi
      ;;
    "memory"|"mem")
      echo "üß† Diagnostic m√©moire..."
      if command -v get_memory_diagnostics >/dev/null 2>&1; then
        get_memory_diagnostics
      else
        echo "‚ùå Diagnostic m√©moire non disponible" >&2
        exit 1
      fi
      ;;
    "performance"|"perf")
      echo "‚ö° M√©triques de performance..."
      # Combinaison dashboard + m√©moire
      if command -v show_io_dashboard >/dev/null 2>&1 && command -v get_memory_diagnostics >/dev/null 2>&1; then
        echo ""
        echo "‚ïê‚ïê‚ïê I/O MONITORING ‚ïê‚ïê‚ïê"
        show_io_dashboard
        echo ""
        echo "‚ïê‚ïê‚ïê MEMORY DIAGNOSTICS ‚ïê‚ïê‚ïê"
        get_memory_diagnostics
      else
        echo "‚ùå Modules de monitoring non disponibles" >&2
        exit 1
      fi
      ;;
    "cleanup")
      echo "üßπ Nettoyage des m√©triques anciennes..."
      if command -v cleanup_old_metrics >/dev/null 2>&1; then
        cleanup_old_metrics
        echo "‚úÖ Nettoyage termin√©"
      else
        echo "‚ùå Fonction de nettoyage non disponible" >&2
        exit 1
      fi
      ;;
    "reset")
      echo "üîÑ Reset complet du monitoring..."
      local monitoring_dir="${AKLO_CACHE_DIR:-$HOME/.aklo/cache}/monitoring"
      if [ -d "$monitoring_dir" ]; then
        rm -rf "$monitoring_dir"
        echo "‚úÖ Monitoring reset"
        if command -v start_io_monitoring >/dev/null 2>&1; then
          start_io_monitoring
          echo "‚úÖ Monitoring red√©marr√©"
        fi
      else
        echo "‚ö†Ô∏è  Aucun monitoring √† reset"
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo monitor <action>"
      echo ""
      echo "Monitoring et m√©triques de performance du syst√®me aklo."
      echo ""
      echo "Actions:"
      echo "  dashboard     Dashboard I/O en temps r√©el"
      echo "  memory        Diagnostic m√©moire et caches"
      echo "  performance   Vue compl√®te (I/O + m√©moire)"
      echo "  cleanup       Nettoyer les m√©triques anciennes"
      echo "  reset         Reset complet du monitoring"
      echo ""
      echo "Alias:"
      echo "  dash, mem, perf peuvent √™tre utilis√©s"
      echo ""
      echo "Exemples:"
      echo "  aklo monitor dashboard    # Dashboard I/O"
      echo "  aklo monitor mem         # Diagnostic m√©moire"
      echo "  aklo monitor perf        # Vue compl√®te"
      echo "  aklo monitor cleanup     # Nettoyage"
      exit 0
      ;;
    *)
      echo "Action inconnue: $action" >&2
      echo "Utilisez 'aklo monitor --help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: template - Gestion des templates
command_template() {
  local action="$1"
  local script_dir="$(dirname "$(realpath "$0")")"
  
  case "$action" in
    "list")
      echo "üìã Templates disponibles..."
      if [ -f "$script_dir/../modules/ux/templates.sh" ]; then
        . "$script_dir/../modules/ux/templates.sh"
        list_templates
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "create")
      shift
      echo "üÜï Cr√©ation d'un nouveau template..."
      if [ -f "$script_dir/../modules/ux/templates.sh" ]; then
        . "$script_dir/../modules/ux/templates.sh"
        create_template "$@"
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "apply")
      shift
      echo "üìù Application d'un template..."
      if [ -f "$script_dir/../modules/ux/templates.sh" ]; then
        . "$script_dir/../modules/ux/templates.sh"
        apply_template "$@"
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo template <action> [args...]"
      echo ""
      echo "Gestion des templates de projet aklo."
      echo ""
      echo "Actions:"
      echo "  list              Liste les templates disponibles"
      echo "  create <name>     Cr√©e un nouveau template"
      echo "  apply <name>      Applique un template au projet"
      echo ""
      echo "Exemples:"
      echo "  aklo template list"
      echo "  aklo template create mon-template"
      echo "  aklo template apply web-app"
      exit 0
      ;;
    *)
      echo "Erreur : Action template inconnue '$action'." >&2
      echo "Utilisez 'aklo template help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: install-ux - Installation des am√©liorations UX
command_install_ux() {
  local script_dir="$(dirname "$(realpath "$0")")"
  
  case "${1:-}" in
    "--help")
      echo "Usage: aklo install-ux"
      echo ""
      echo "Installe les am√©liorations d'exp√©rience utilisateur aklo :"
      echo "  ‚Ä¢ Autocompl√©tion shell (bash/zsh)"
      echo "  ‚Ä¢ Aliases et raccourcis"
      echo "  ‚Ä¢ Configuration optimis√©e"
      echo "  ‚Ä¢ Int√©gration avec les √©diteurs"
      exit 0
      ;;
    *)
      echo "üé® Installation des am√©liorations UX..."
      if [ -f "$script_dir/../modules/ux/install-ux.sh" ]; then
        "$script_dir/../modules/ux/install-ux.sh"
      else
        echo "Erreur : Script install-ux.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: propose-pbi - Cr√©ation d'un Product Backlog Item
command_propose_pbi() {
  local title="$1"
  local template="${2:-default}"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$title" in
    "--help"|"help"|"")
      echo "Usage: aklo propose-pbi \"<titre>\" [--template=<type>]"
      echo ""
      echo "Cr√©e un nouveau Product Backlog Item selon le protocole PRODUCT-OWNER."
      echo ""
      echo "Arguments:"
      echo "  titre       Titre descriptif du PBI (requis, entre guillemets)"
      echo ""
      echo "Options:"
      echo "  --template=<type>  Type de template (default|feature|bug|improvement)"
      echo "  --no-agent         Mode skeleton (structure vide √† compl√©ter)"
      echo "  --no-journal       Pas de mise √† jour automatique du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo propose-pbi \"Ajouter authentification OAuth\""
      echo "  aklo propose-pbi \"Corriger bug de validation\" --template=bug"
      echo "  aklo pbi \"Optimiser temps de chargement\" --no-agent"
      exit 0
      ;;
    --no-agent)
      agent_assistance="skeleton"
      title="$2"
      template="${3:-default}"
      ;;
    --no-journal)
      auto_journal="false"
      title="$2"
      template="${3:-default}"
      ;;
  esac
  
  if [ -z "$title" ]; then
    echo "Erreur : Le titre du PBI est requis." >&2
    echo "Usage: aklo propose-pbi \"<titre>\""
    echo "Utilisez 'aklo propose-pbi --help' pour plus d'informations."
    exit 1
  fi
  
  # G√©n√©ration de l'ID unique
  PBI_DIR="./$(get_config "PBI_DIR")"
  mkdir -p "$PBI_DIR"
  
  PBI_ID=$(get_next_id "$PBI_DIR" "PBI")
  PBI_FILE="${PBI_DIR}/PBI-${PBI_ID}-PROPOSED.md"
  TODAY=$(date +%Y-%m-%d)
  
  echo "üéØ Cr√©ation du PBI-${PBI_ID}: \"$title\""
  
  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole PRODUCT-OWNER..."
      generate_pbi_from_protocol "$PBI_FILE" "$PBI_ID" "$title" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_pbi_from_protocol "$PBI_FILE" "$PBI_ID" "$title" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_pbi_from_protocol "$PBI_FILE" "$PBI_ID" "$title" "$TODAY" "minimal"
      ;;
  esac
  
  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "PRODUCT-OWNER" "Cr√©ation PBI" "Nouveau PBI-${PBI_ID}: $title" "PBI-${PBI_ID}-PROPOSED.md"
  fi
  
  echo ""
  echo "‚úÖ PBI-${PBI_ID}-PROPOSED.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $PBI_FILE"
  echo ""
  echo "Prochaines √©tapes:"
  echo "  1. R√©viser et compl√©ter le PBI"
  echo "  2. Valider avec l'√©quipe"
  echo "  3. aklo plan ${PBI_ID} (pour d√©composer en t√¢ches)"
}

# Fonction de g√©n√©ration PBI - Parser dynamique du protocole PRODUCT-OWNER
generate_pbi_from_protocol() {
  local file="$1"
  local id="$2"
  local title="$3"
  local date="$4"
  local assistance_level="$5"
  
  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="id=${id},title=${title},date=${date},status=PROPOSED"
  
  # G√©n√©ration dynamique depuis le protocole
  parse_and_generate_artefact "00-PRODUCT-OWNER" "PBI" "$assistance_level" "$file" "$context_vars"
  
  # Si le parser g√©n√©rique √©choue, afficher une erreur explicite
  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration PBI depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole PRODUCT-OWNER" >&2
    return 1
  fi
}

# ===== FONCTION PBI STATIC_FALLBACK SUPPRIM√âE =====
# La fonction generate_pbi_static_fallback a √©t√© supprim√©e car remplac√©e 
# par le parser g√©n√©rique dynamique.

# Commande: arch - Conception d'architecture logicielle
command_arch() {
  local pbi_id="$1"
  local review_flag="$2"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$pbi_id" in
    "--help"|"help"|"")
      echo "Usage: aklo arch <PBI_ID> [--review]"
      echo ""
      echo "Conception d'architecture logicielle selon le protocole ARCHITECTURE."
      echo ""
      echo "Arguments:"
      echo "  PBI_ID      ID du PBI n√©cessitant une architecture (requis)"
      echo ""
      echo "Options:"
      echo "  --review    R√©vision d'une architecture existante"
      echo "  --no-agent  Mode skeleton (structure vide √† compl√©ter)"
      echo "  --no-journal Pas de mise √† jour automatique du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo arch 42            # Nouvelle architecture pour PBI-42"
      echo "  aklo arch 42 --review   # R√©vision de l'architecture PBI-42"
      echo "  aklo arch 42 --no-agent # Mode skeleton"
      exit 0
      ;;
    --no-agent)
      agent_assistance="skeleton"
      pbi_id="$2"
      review_flag="$3"
      ;;
    --no-journal)
      auto_journal="false"
      pbi_id="$2"
      review_flag="$3"
      ;;
  esac
  
  if [ -z "$pbi_id" ]; then
    echo "Erreur : L'ID du PBI est requis." >&2
    echo "Usage: aklo arch <PBI_ID>"
    echo "Utilisez 'aklo arch --help' pour plus d'informations."
    exit 1
  fi
  
  # Validation de l'existence du PBI
  PBI_DIR="./$(get_config "PBI_DIR")"
  PBI_FILE=$(find "$PBI_DIR" -name "PBI-${pbi_id}-*.md" 2>/dev/null | head -1)
  
  if [ -z "$PBI_FILE" ]; then
    echo "Erreur : PBI-${pbi_id} introuvable dans $PBI_DIR" >&2
    echo "V√©rifiez que le PBI existe avant de cr√©er son architecture."
    echo "Fichiers PBI disponibles:"
    ls -la "$PBI_DIR"/ 2>/dev/null | grep "PBI-" || echo "  Aucun fichier PBI trouv√©"
    exit 1
  fi
  
  # G√©n√©ration de l'ID d'architecture
  ARCH_DIR="./$(get_config "ARCH_DIR")"
  mkdir -p "$ARCH_DIR"
  
  # Trouver le prochain ID d'architecture pour ce PBI
  ARCH_ID=1
  while [ -f "${ARCH_DIR}/ARCH-${pbi_id}-${ARCH_ID}-"*".md" ]; do
    ARCH_ID=$((ARCH_ID + 1))
  done
  
  if [ "$review_flag" = "--review" ]; then
    # Mode r√©vision : chercher l'architecture existante
    EXISTING_ARCH=$(find "$ARCH_DIR" -name "ARCH-${pbi_id}-*-VALIDATED.md" 2>/dev/null | head -1)
    if [ -z "$EXISTING_ARCH" ]; then
      echo "Erreur : Aucune architecture valid√©e trouv√©e pour PBI-${pbi_id}" >&2
      echo "Utilisez 'aklo arch ${pbi_id}' pour cr√©er une nouvelle architecture."
      exit 1
    fi
    echo "üîÑ R√©vision de l'architecture existante : $(basename "$EXISTING_ARCH")"
  fi
  
  ARCH_FILE="${ARCH_DIR}/ARCH-${pbi_id}-${ARCH_ID}-DRAFT.md"
  TODAY=$(date +%Y-%m-%d)
  
  echo "üèóÔ∏è  Cr√©ation de l'architecture ARCH-${pbi_id}-${ARCH_ID} pour PBI-${pbi_id}"
  
  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole ARCHITECTURE..."
      generate_arch_from_protocol "$ARCH_FILE" "$pbi_id" "$ARCH_ID" "$TODAY" "$PBI_FILE" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_arch_from_protocol "$ARCH_FILE" "$pbi_id" "$ARCH_ID" "$TODAY" "$PBI_FILE" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_arch_from_protocol "$ARCH_FILE" "$pbi_id" "$ARCH_ID" "$TODAY" "$PBI_FILE" "minimal"
      ;;
  esac
  
  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "ARCHITECTURE" "Cr√©ation document" "Architecture ARCH-${pbi_id}-${ARCH_ID} pour PBI-${pbi_id}" "ARCH-${pbi_id}-${ARCH_ID}-DRAFT.md"
  fi
  
  echo ""
  echo "‚úÖ ARCH-${pbi_id}-${ARCH_ID}-DRAFT.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $ARCH_FILE"
  echo ""
  echo "Prochaines √©tapes:"
  echo "  1. Analyser le probl√®me architectural"
  echo "  2. √âvaluer 2-3 options d'architecture"
  echo "  3. Documenter les compromis (trade-offs)"
  echo "  4. Soumettre pour validation"
  echo "  5. Mettre √† jour les Tasks apr√®s validation"
}

# ===== FONCTIONS ARCH OBSOL√àTES SUPPRIM√âES =====
# Les fonctions generate_arch_full, generate_arch_skeleton, generate_arch_minimal
# ont √©t√© supprim√©es car remplac√©es par le parser g√©n√©rique dynamique.

# Fonction de g√©n√©ration ARCH - Parser dynamique du protocole ARCHITECTURE
generate_arch_from_protocol() {
  local file="$1"
  local pbi_id="$2"
  local arch_id="$3"
  local date="$4"
  local pbi_file="$5"
  local assistance_level="$6"
  
  # Extraire le titre du PBI (nettoyer les caract√®res sp√©ciaux) - TASK-7-1: Cache regex
  local pbi_pattern="PBI-[0-9]*"
  if command -v use_regex_pattern >/dev/null 2>&1; then
    pbi_pattern=$(use_regex_pattern "PBI_ID" "PBI-[0-9]*")
  fi
  local pbi_title=$(grep "^# PBI-${pbi_id}" "$pbi_file" 2>/dev/null | sed "s/^# ${pbi_pattern} : //" | tr -d '\n\r' || echo "Architecture pour PBI-${pbi_id}")
  
  # Variables contextuelles pour le parser g√©n√©rique
  local arch_full_id="${pbi_id}-${arch_id}"
  local context_vars="id=${arch_full_id},title=${pbi_title},date=${date},status=DRAFT,pbi_id=${pbi_id},arch_id=${arch_id}"
  

  
  # G√©n√©ration dynamique depuis le protocole
  parse_and_generate_artefact "02-ARCHITECTURE" "ARCH" "$assistance_level" "$file" "$context_vars"
  
  # Si le parser g√©n√©rique √©choue, afficher une erreur explicite
  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration ARCH depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole ARCHITECTURE" >&2
    return 1
  fi
}

# ===== FONCTION ARCH STATIC_FALLBACK SUPPRIM√âE =====
# La fonction generate_arch_static_fallback a √©t√© supprim√©e car remplac√©e 
# par le parser g√©n√©rique dynamique.

# Commande: dev - D√©veloppement TDD d'une Task
command_dev() {
  local task_id="$1"
  
  # Parser les arguments de validation et backup
  parse_validation_args "full" "$@"
  
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$task_id" in
    "--help"|"help"|"")
      echo "Usage: aklo dev <TASK_ID>"
      echo ""
      echo "D√©marre le d√©veloppement TDD d'une Task selon le protocole D√âVELOPPEMENT."
      echo ""
      echo "Arguments:"
      echo "  TASK_ID    ID de la task (format: PBI_ID-TASK_ID, ex: 1-2)"
      echo ""
      echo "Options:"
      echo "  --no-agent         Assistance minimale (skeleton)"
      echo "  --no-journal       D√©sactiver la mise √† jour du journal"
      echo "  --no-validation    D√©sactiver validation TDD (linter/tests/build)"
      echo "  --force-validation Forcer validation TDD m√™me si d√©sactiv√©e"
      echo "  --auto-commit      Commit automatique sans validation humaine"
      echo "  --manual-commit    Demander validation humaine avant commit"
      echo ""
      echo "Exemples:"
      echo "  aklo dev 1-1              # D√©velopper TASK-1-1"
      echo "  aklo dev 2-3 --no-agent   # D√©velopper TASK-2-3 en mode minimal"
      echo ""
      echo "Pr√©requis:"
      echo "  - La Task doit exister avec le statut TODO"
      echo "  - Le r√©pertoire doit √™tre un projet Git"
      echo ""
      echo "Workflow:"
      echo "  1. Validation de la Task (statut TODO)"
      echo "  2. Cr√©ation de la branche feature/task-[PBI_ID]-[TASK_ID]"
      echo "  3. Changement de statut TODO ‚Üí IN_PROGRESS"
      echo "  4. Pr√©sentation du plan de vol d√©veloppement TDD"
      echo "  5. Guidage dans le cycle TDD (RED-GREEN-BLUE)"
      return 0
      ;;
  esac

  # Validation du format TASK_ID
  if [[ ! "$task_id" =~ ^[0-9]+-[0-9]+$ ]]; then
    echo "‚ùå Erreur : Format TASK_ID invalide."
    echo "   Format attendu: PBI_ID-TASK_ID (ex: 1-2)"
    echo "   Re√ßu: '$task_id'"
    return 1
  fi

  # Extraction PBI_ID et TASK_SEQ
  local pbi_id=$(echo "$task_id" | cut -d'-' -f1)
  local task_seq=$(echo "$task_id" | cut -d'-' -f2)
  
  # Recherche de la Task
  local tasks_dir="./$(get_config "TASKS_DIR")"
  local task_file=$(find "$tasks_dir" -name "TASK-${pbi_id}-${task_seq}-TODO.md" 2>/dev/null | head -1)
  
  if [ -z "$task_file" ]; then
    echo "‚ùå Erreur : Task TASK-${pbi_id}-${task_seq} introuvable avec statut TODO."
    echo "   R√©pertoire recherch√©: $tasks_dir"
    echo "   Fichier attendu: TASK-${pbi_id}-${task_seq}-TODO.md"
    echo ""
    echo "V√©rifiez que:"
    echo "  1. La Task existe"
    echo "  2. Elle a le statut TODO (pas IN_PROGRESS ou DONE)"
    echo "  3. Le r√©pertoire TASKS_DIR est correct dans .aklo.conf"
    return 1
  fi

  echo "üöÄ D√©marrage du d√©veloppement TDD pour TASK-${pbi_id}-${task_seq}"
  echo "üìÅ Task trouv√©e: $task_file"
  
  # V√©rification que nous sommes dans un repo Git
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "‚ùå Erreur : Ce r√©pertoire n'est pas un d√©p√¥t Git."
    echo "   Le d√©veloppement TDD n√©cessite Git pour la gestion des branches."
    return 1
  fi

  # Cr√©ation de la branche feature
  local branch_name="feature/task-${pbi_id}-${task_seq}"
  echo "üåø Cr√©ation de la branche: $branch_name"
  
  if git show-ref --verify --quiet refs/heads/$branch_name; then
    echo "‚ö†Ô∏è  La branche $branch_name existe d√©j√†."
    echo "   Basculement vers la branche existante..."
    git checkout $branch_name
  else
    git checkout -b $branch_name
    if [ $? -ne 0 ]; then
      echo "‚ùå Erreur : Impossible de cr√©er la branche $branch_name"
      return 1
    fi
  fi

  # Changement de statut TODO ‚Üí IN_PROGRESS
  local new_task_file="${tasks_dir}/TASK-${pbi_id}-${task_seq}-IN_PROGRESS.md"
  echo "üìù Mise √† jour du statut: TODO ‚Üí IN_PROGRESS"
  
  mv "$task_file" "$new_task_file"
  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : Impossible de changer le statut de la Task"
    git checkout -
    return 1
  fi

  # Mise √† jour du journal si activ√©
  if [ "$auto_journal" = "true" ]; then
    update_journal "D√âVELOPPEMENT" "D√©marrage d√©veloppement TDD TASK-${pbi_id}-${task_seq}" "Branche: $branch_name, Statut: TODO ‚Üí IN_PROGRESS" "TASK-${pbi_id}-${task_seq}-IN_PROGRESS.md"
  fi

  echo ""
  echo "‚úÖ Environnement de d√©veloppement TDD pr√©par√© !"
  echo ""
  echo "üìã PLAN DE VOL D√âVELOPPEMENT TDD"
  echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
  echo "üéØ Objectif: Impl√©menter TASK-${pbi_id}-${task_seq} selon m√©thodologie TDD"
  echo ""
  echo "üìÅ Fichiers:"
  echo "   ‚Ä¢ Task: $new_task_file"
  echo "   ‚Ä¢ Branche: $branch_name"
  echo "   ‚Ä¢ Statut: IN_PROGRESS"
  echo ""
  echo "üîÑ Cycle TDD √† suivre:"
  echo "   1. üî¥ RED:   √âcrire un test qui √©choue"
  echo "   2. üü¢ GREEN: √âcrire le code minimum pour r√©ussir"
  echo "   3. üîµ BLUE:  Refactoriser et valider la qualit√©"
  echo "   4. ‚ôªÔ∏è  IT√âRER: R√©p√©ter jusqu'√† completion"
  echo ""
  echo "üìã Validation finale requise:"
  echo "   ‚Ä¢ Definition of Done compl√®tement coch√©e"
  echo "   ‚Ä¢ Tous les tests passent"
  echo "   ‚Ä¢ Linter et typage sans erreur"
  echo "   ‚Ä¢ Code review et approbation"
  echo ""
  echo "üéØ Prochaines √©tapes:"
  echo "   1. Lire la Task: cat '$new_task_file'"
  echo "   2. Identifier la premi√®re fonctionnalit√© √† impl√©menter"
  echo "   3. Commencer le cycle TDD"
  echo "   4. Utiliser 'aklo submit-task' quand termin√©"
  echo ""
  echo "üí° Conseils:"
  echo "   ‚Ä¢ Restez sur la branche $branch_name"
  echo "   ‚Ä¢ Commitez r√©guli√®rement vos avanc√©es"
  echo "   ‚Ä¢ Respectez les principes SOLID"
  echo "   ‚Ä¢ Documentez votre code (JSDoc/TSDoc)"
}

# Commande: debug - Diagnostic et correction de bugs
command_debug() {
  local title="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$title" in
    "--help"|"help"|"")
      echo "Usage: aklo debug \"<titre du probl√®me>\""
      echo ""
      echo "Diagnostic et correction de bugs selon le protocole DEBOGAGE."
      echo ""
      echo "Arguments:"
      echo "  titre      Description du probl√®me √† diagnostiquer (requis)"
      echo ""
      echo "Options:"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo debug \"Login impossible avec utilisateur admin\""
      echo "  aklo debug \"Timeout API payment\" --no-agent"
      echo ""
      echo "Workflow:"
      echo "  1. Cr√©ation du rapport DEBUG-[ID]-INVESTIGATING.md"
      echo "  2. Documentation du probl√®me et √©tapes de reproduction"
      echo "  3. Formulation d'hypoth√®ses initiales"
      echo "  4. Investigation it√©rative avec instrumentation"
      echo "  5. Analyse de la cause racine (root cause)"
      echo "  6. Plan de correction et validation"
      echo "  7. Impl√©mentation via protocole D√âVELOPPEMENT"
      return 0
      ;;
    --no-agent)
      agent_assistance="skeleton"
      title="$2"
      ;;
    --no-journal)
      auto_journal="false"
      title="$2"
      ;;
  esac

  if [ -z "$title" ]; then
    echo "‚ùå Erreur : Le titre du probl√®me est requis." >&2
    echo "Usage: aklo debug \"<titre du probl√®me>\""
    echo "Utilisez 'aklo debug --help' pour plus d'informations."
    return 1
  fi

  # G√©n√©ration de l'ID unique bas√© sur le titre et la date
  local date_id=$(date +%Y%m%d)
  local title_slug=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
  local debug_id="${title_slug}-${date_id}"
  
  # Pr√©paration des r√©pertoires
  local debug_dir="$(get_config "DEBUG_DIR" || echo "docs/backlog/03-debug")"
  
  # Assurer que le r√©pertoire existe (chemin absolu si besoin)
  if [ ! -d "$debug_dir" ]; then
    mkdir -p "$debug_dir" 2>/dev/null || true
  fi
  
  local debug_file="${debug_dir}/DEBUG-${debug_id}-INVESTIGATING.md"
  local today=$(date +%Y-%m-%d)
  
  # V√©rification si le rapport existe d√©j√†
  if [ -f "$debug_file" ]; then
    echo "‚ö†Ô∏è  Un rapport de d√©bogage existe d√©j√† pour ce probl√®me :"
    echo "   üìÅ $debug_file"
    echo ""
    echo "Options :"
    echo "  1. Modifier le titre pour cr√©er un nouveau rapport"
    echo "  2. Continuer avec le rapport existant"
    return 1
  fi

  echo "üêõ Cr√©ation du rapport de d√©bogage DEBUG-${debug_id}"
  echo "üìÅ Probl√®me: $title"
  
  # G√©n√©ration du rapport selon le niveau d'assistance
  generate_debug_from_protocol "$debug_file" "$debug_id" "$title" "$today" "$agent_assistance"
  
  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "DEBOGAGE" "Initialisation investigation DEBUG-${debug_id}" "Probl√®me: $title" "DEBUG-${debug_id}-INVESTIGATING.md"
  fi

  echo ""
  echo "‚úÖ DEBUG-${debug_id}-INVESTIGATING.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $debug_file"
  echo ""
  echo "üîç Prochaines √©tapes:"
  echo "  1. Documenter les √©tapes de reproduction"
  echo "  2. Formuler les hypoth√®ses initiales"
  echo "  3. Commencer l'investigation it√©rative"
  echo "  4. Identifier la cause racine"
  echo "  5. Proposer un plan de correction"
  echo "  6. Impl√©menter via 'aklo dev' apr√®s validation"
}

# Commande: review - Revue de code assist√©e
command_review() {
  local target="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$target" in
    "--help"|"help"|"")
      echo "Usage: aklo review <TASK_ID|COMMIT|PR> [--checklist]"
      echo ""
      echo "Revue de code assist√©e selon le protocole REVUE-DE-CODE."
      echo ""
      echo "Arguments:"
      echo "  TASK_ID    ID de la task √† r√©viser (format: PBI_ID-TASK_ID, ex: 1-2)"
      echo "  COMMIT     Hash du commit √† r√©viser (ex: abc123f)"
      echo "  PR         Num√©ro de PR √† r√©viser (ex: pr-42)"
      echo ""
      echo "Options:"
      echo "  --checklist    Mode checklist d√©taill√©e pour validation"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo review 1-2              # R√©viser la Task 1-2"
      echo "  aklo review abc123f          # R√©viser un commit sp√©cifique"
      echo "  aklo review pr-42            # R√©viser une Pull Request"
      echo "  aklo review 1-2 --checklist  # Mode checklist d√©taill√©e"
      echo ""
      echo "Workflow:"
      echo "  1. Analyse du diff de code"
      echo "  2. V√©rification conformit√© protocole D√âVELOPPEMENT"
      echo "  3. √âvaluation principes SOLID et qualit√©"
      echo "  4. G√©n√©ration rapport REVIEW-[ID].md"
      echo "  5. Classification des observations (CRITICAL/MAJOR/MINOR)"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local checklist_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --checklist)
            checklist_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$target" ]; then
    echo "Erreur : Cible de revue requise (TASK_ID, COMMIT ou PR)." >&2
    echo "Utilisez 'aklo review --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID de review
  REVIEW_DIR="./$(get_config "REVIEWS_DIR" || echo "docs/backlog/03-reviews")"
  mkdir -p "$REVIEW_DIR"

  # D√©terminer le type de cible et formater l'ID
  local review_id=""
  if [[ "$target" =~ ^[0-9]+-[0-9]+$ ]]; then
    # Format TASK_ID (ex: 1-2)
    review_id="task-${target}"
  elif [[ "$target" =~ ^pr-[0-9]+$ ]]; then
    # Format PR (ex: pr-42)
    review_id="$target"
  elif [[ "$target" =~ ^[a-f0-9]{6,40}$ ]]; then
    # Format commit hash
    review_id="commit-${target:0:7}"
  else
    # Format libre
    review_id="$target"
  fi

  REVIEW_FILE="${REVIEW_DIR}/REVIEW-${review_id}.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üîç Cr√©ation de la revue REVIEW-${review_id} pour: $target"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole REVUE-DE-CODE..."
      generate_review_from_protocol "$REVIEW_FILE" "$review_id" "$target" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_review_from_protocol "$REVIEW_FILE" "$review_id" "$target" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_review_from_protocol "$REVIEW_FILE" "$review_id" "$target" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "REVIEW" "Revue de code: $target" "REVIEW-${review_id}.md"
  fi

  echo ""
  echo "‚úÖ REVIEW-${review_id}.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $REVIEW_FILE"
  echo ""
  echo "üîç Prochaines √©tapes:"
  echo "  1. Analyser le diff de code concern√©"
  echo "  2. Remplir la checklist de conformit√©"
  echo "  3. Documenter les observations par criticit√©"
  echo "  4. Pr√©senter le rapport au d√©veloppeur"
  echo "  5. Fusionner apr√®s corrections (aklo merge-task)"
}

# Commande: refactor - Refactoring s√©curis√© de code
command_refactor() {
  local scope="$1"
  
  # Parser les arguments de validation et backup
  parse_validation_args "basic" "$@"
  
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$scope" in
    "--help"|"help"|"")
      echo "Usage: aklo refactor \"<description>\" [--safe]"
      echo ""
      echo "Refactoring s√©curis√© de code selon le protocole REFACTORING."
      echo ""
      echo "Arguments:"
      echo "  description  Description du refactoring √† effectuer (requis)"
      echo ""
      echo "Options:"
      echo "  --safe             Mode s√©curis√© avec validation continue"
      echo "  --no-agent         Assistance minimale (skeleton)"
      echo "  --no-journal       D√©sactiver la mise √† jour du journal"
      echo "  --no-validation    D√©sactiver validation TDD (tests de non-r√©gression)"
      echo "  --force-validation Forcer validation TDD m√™me si d√©sactiv√©e"
      echo "  --auto-commit      Commit automatique sans validation humaine"
      echo "  --manual-commit    Demander validation humaine avant commit"
      echo ""
      echo "Exemples:"
      echo "  aklo refactor \"Extraire logique m√©tier en service\""
      echo "  aklo refactor \"Simplifier fonction de validation\" --safe"
      echo "  aklo refactor \"R√©organiser structure des classes\""
      echo ""
      echo "Workflow:"
      echo "  1. Diagnostic du code smell et probl√®me identifi√©"
      echo "  2. Strat√©gie de refactoring avec plan d'action"
      echo "  3. V√©rification couverture de tests (pr√©requis)"
      echo "  4. Ex√©cution par micro-changements avec validation"
      echo "  5. Preuve de non-r√©gression et finalisation"
      echo ""
      echo "Statuts:"
      echo "  ANALYSIS     - Diagnostic en cours"
      echo "  REFACTORING  - Ex√©cution du plan approuv√©"
      echo "  DONE         - Refactoring termin√© et valid√©"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local safe_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --safe)
            safe_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$scope" ]; then
    echo "Erreur : Description du refactoring requise." >&2
    echo "Utilisez 'aklo refactor --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID de refactoring
  REFACTOR_DIR="./$(get_config "REFACTOR_DIR" || echo "docs/backlog/05-refactor")"
  mkdir -p "$REFACTOR_DIR"

  # G√©n√©rer l'ID selon le protocole (titre-slugifi√©-YYYYMMDD)
  refactor_id=$(detect_id_pattern "05-REFACTORING" "$scope")
  REFACTOR_FILE="${REFACTOR_DIR}/REFACTOR-${refactor_id}-ANALYSIS.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üîß Cr√©ation du refactoring REFACTOR-${refactor_id}"
  echo "üìã Description: $scope"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole REFACTORING..."
      generate_refactor_from_protocol "$REFACTOR_FILE" "$refactor_id" "$scope" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_refactor_from_protocol "$REFACTOR_FILE" "$refactor_id" "$scope" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_refactor_from_protocol "$REFACTOR_FILE" "$refactor_id" "$scope" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "REFACTOR" "Refactoring: $scope" "REFACTOR-${refactor_id}-ANALYSIS.md"
  fi

  echo ""
  echo "‚úÖ REFACTOR-${refactor_id}-ANALYSIS.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $REFACTOR_FILE"
  echo ""
  echo "üîß Prochaines √©tapes:"
  echo "  1. Diagnostiquer le code smell identifi√©"
  echo "  2. D√©finir la strat√©gie et plan d'action"
  echo "  3. V√©rifier la couverture de tests (OBLIGATOIRE)"
  echo "  4. Soumettre le plan pour validation"
  echo "  5. Ex√©cuter le refactoring par micro-changements"
  echo ""
  echo "‚ö†Ô∏è  RAPPEL: La couverture de tests est un pr√©requis non n√©gociable"
}

# Commande: hotfix - Correction d'urgence en production
command_hotfix() {
  local issue="$1"
  
  # Parser les arguments de validation et backup (hotfix = validation full obligatoire)
  parse_validation_args "full" "$@"
  
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$issue" in
    "--help"|"help"|"")
      echo "Usage: aklo hotfix \"<description du bug critique>\" [--emergency]"
      echo ""
      echo "Correction d'urgence en production selon le protocole HOTFIX."
      echo ""
      echo "Arguments:"
      echo "  description  Description du bug critique en production (requis)"
      echo ""
      echo "Options:"
      echo "  --emergency        Mode urgence avec validation acc√©l√©r√©e"
      echo "  --no-agent         Assistance minimale (skeleton)"
      echo "  --no-journal       D√©sactiver la mise √† jour du journal"
      echo "  --auto-commit      Commit automatique sans validation humaine"
      echo "  --manual-commit    Demander validation humaine avant commit"
      echo ""
      echo "‚ö†Ô∏è  IMPORTANT: Validation TDD obligatoire pour hotfix (s√©curit√© production)"
      echo ""
      echo "Exemples:"
      echo "  aklo hotfix \"Login impossible pour nouveaux utilisateurs\""
      echo "  aklo hotfix \"Panier d'achat inaccessible\" --emergency"
      echo "  aklo hotfix \"API payment timeout en production\""
      echo ""
      echo "Workflow d'urgence:"
      echo "  1. Validation de l'urgence r√©elle (production bloqu√©e)"
      echo "  2. Cr√©ation branche hotfix depuis tag de production"
      echo "  3. Diagnostic rapide de la cause racine"
      echo "  4. Correction minimale et cibl√©e"
      echo "  5. D√©ploiement d'urgence avec nouveau tag de patch"
      echo "  6. Planification post-mortem et synchronisation"
      echo ""
      echo "Statuts:"
      echo "  INVESTIGATING - Analyse cause racine en cours"
      echo "  AWAITING_FIX  - Plan de correction en attente de validation"
      echo "  DEPLOYING     - Correctif valid√©, d√©ploiement en cours"
      echo "  RESOLVED      - Hotfix en production, post-mortem planifi√©"
      echo ""
      echo "‚ö†Ô∏è  ATTENTION: R√©serv√© aux bugs critiques bloquant la production"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local emergency_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --emergency)
            emergency_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$issue" ]; then
    echo "Erreur : Description du bug critique requise." >&2
    echo "Utilisez 'aklo hotfix --help' pour plus d'informations."
    exit 1
  fi

  # Validation de l'urgence
  echo "üö® HOTFIX D'URGENCE D√âTECT√â"
  echo "üìã Bug critique: $issue"
  echo ""
  echo "‚ö†Ô∏è  VALIDATION REQUISE:"
  echo "   Ce bug bloque-t-il r√©ellement la production ?"
  echo "   Cause-t-il une perte de revenus imm√©diate ?"
  echo "   Les utilisateurs sont-ils impact√©s de mani√®re critique ?"
  echo ""
  read -p "Confirmer l'urgence r√©elle (y/N): " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo "‚ùå Hotfix annul√©. Utilisez 'aklo debug' pour un diagnostic normal."
    exit 1
  fi

  # G√©n√©ration de l'ID de hotfix
  HOTFIX_DIR="./$(get_config "HOTFIX_DIR" || echo "docs/backlog/08-hotfixes")"
  mkdir -p "$HOTFIX_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  hotfix_id=$(detect_id_pattern "10-HOTFIX" "$issue")
  HOTFIX_FILE="${HOTFIX_DIR}/HOTFIX-${hotfix_id}.md"
  TODAY=$(date +%Y-%m-%d)
  TIME=$(date +%H:%M)

  echo ""
  echo "üö® Cr√©ation du hotfix HOTFIX-${hotfix_id}"
  echo "‚è∞ Urgence confirm√©e - Proc√©dure acc√©l√©r√©e activ√©e"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole HOTFIX..."
      generate_hotfix_from_protocol "$HOTFIX_FILE" "$hotfix_id" "$issue" "$TODAY" "$TIME" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_hotfix_from_protocol "$HOTFIX_FILE" "$hotfix_id" "$issue" "$TODAY" "$TIME" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_hotfix_from_protocol "$HOTFIX_FILE" "$hotfix_id" "$issue" "$TODAY" "$TIME" "minimal"
      ;;
  esac

  # Validation TDD critique pour hotfix (obligatoire)
  echo ""
  echo "üîç Validation TDD critique pour HOTFIX..."
  if [ "$PARSED_VALIDATION_LEVEL" = "none" ]; then
    echo "‚ö†Ô∏è  ATTENTION: Validation TDD d√©sactiv√©e pour un HOTFIX critique !"
    echo "   Ceci est fortement d√©conseill√© en production"
    read -p "Continuer malgr√© tout ? (y/N): " force_continue
    if [[ ! "$force_continue" =~ ^[Yy]$ ]]; then
      echo "‚ùå Hotfix annul√© pour s√©curit√©"
      exit 1
    fi
  else
    if ! validate_tdd "$PARSED_VALIDATION_LEVEL" "HOTFIX"; then
      echo "‚ùå Validation TDD √©chou√©e pour HOTFIX critique"
      echo "   La s√©curit√© production exige une validation compl√®te"
      exit 1
    fi
  fi

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "HOTFIX" "URGENCE: $issue" "HOTFIX-${hotfix_id}.md"
  fi

  # Commit atomique pour tra√ßabilit√© d'urgence
  local commit_msg="hotfix: ${issue}

HOTFIX critique HOTFIX-${hotfix_id}

- Urgence production confirm√©e
- Validation TDD: ${PARSED_VALIDATION_LEVEL}
- Artefact: HOTFIX-${hotfix_id}.md
- Protocole: HOTFIX"

  if ! handle_auto_backup "$commit_msg" "HOTFIX"; then
    echo "‚ùå √âchec du commit atomique hotfix"
    exit 1
  fi

  echo ""
  echo "‚úÖ HOTFIX-${hotfix_id} cr√©√© et committ√© avec succ√®s !"
  echo "üìç Fichier: $HOTFIX_FILE"
  echo ""
  echo "üö® PROC√âDURE D'URGENCE - Prochaines √©tapes:"
  echo "  1. Identifier le tag de production actuellement d√©ploy√©"
  echo "  2. Cr√©er branche hotfix depuis ce tag"
  echo "  3. Diagnostiquer rapidement la cause racine"
  echo "  4. Impl√©menter la correction MINIMALE"
  echo "  5. D√©ployer d'urgence avec nouveau tag de patch"
  echo "  6. Planifier le post-mortem (PBI/TASK de correction d√©finitive)"
  echo ""
  echo "‚ö° RAPPEL: Correction minimale uniquement - Pas de refactoring !"
  echo "‚ö° RAPPEL: Planifier le post-mortem apr√®s stabilisation"
}

# Commande: optimize - Optimisation de performance
command_optimize() {
  local scope="$1"
  
  # Parser les arguments de validation et backup (optimize = validation basic par d√©faut)
  parse_validation_args "basic" "$@"
  
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$scope" in
    "--help"|"help"|"")
      echo "Usage: aklo optimize \"<objectif de performance>\" [--profile]"
      echo ""
      echo "Optimisation de performance selon le protocole OPTIMISATION."
      echo ""
      echo "Arguments:"
      echo "  objectif     Objectif de performance √† atteindre (requis)"
      echo ""
      echo "Options:"
      echo "  --profile          Mode profiling avec outils d'analyse"
      echo "  --no-agent         Assistance minimale (skeleton)"
      echo "  --no-journal       D√©sactiver la mise √† jour du journal"
      echo "  --no-validation    D√©sactiver validation TDD (d√©conseill√©)"
      echo "  --force-validation Forcer validation TDD compl√®te"
      echo "  --auto-commit      Commit automatique sans validation humaine"
      echo "  --manual-commit    Demander validation humaine avant commit"
      echo ""
      echo "Exemples:"
      echo "  aklo optimize \"R√©duire temps de r√©ponse API users < 100ms\""
      echo "  aklo optimize \"Optimiser consommation m√©moire < 512MB\" --profile"
      echo "  aklo optimize \"Acc√©l√©rer rendu page d'accueil < 2s\""
      echo ""
      echo "Workflow scientifique:"
      echo "  1. D√©finition objectif de performance chiffr√©"
      echo "  2. Mise en place protocole de benchmark reproductible"
      echo "  3. Mesure initiale des performances (baseline)"
      echo "  4. Analyse scientifique du goulet d'√©tranglement"
      echo "  5. Strat√©gie d'optimisation cibl√©e"
      echo "  6. Impl√©mentation et mesure finale"
      echo ""
      echo "Statuts:"
      echo "  BENCHMARKING - Mesure et analyse en cours"
      echo "  AWAITING_FIX - Solution propos√©e en attente de validation"
      echo "  DONE         - Optimisation impl√©ment√©e et valid√©e"
      echo ""
      echo "üî¨ PRINCIPE: Mesurer d'abord, optimiser ensuite"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local profile_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --profile)
            profile_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$scope" ]; then
    echo "Erreur : Objectif de performance requis." >&2
    echo "Utilisez 'aklo optimize --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID d'optimisation
  OPTIM_DIR="./$(get_config "OPTIM_DIR" || echo "docs/backlog/06-optim")"
  mkdir -p "$OPTIM_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  optim_id=$(detect_id_pattern "06-OPTIMISATION" "$scope")
  OPTIM_FILE="${OPTIM_DIR}/OPTIM-${optim_id}-BENCHMARKING.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üî¨ Cr√©ation de l'optimisation OPTIM-${optim_id}"
  echo "üéØ Objectif: $scope"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole OPTIMISATION..."
      generate_optim_from_protocol "$OPTIM_FILE" "$optim_id" "$scope" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_optim_from_protocol "$OPTIM_FILE" "$optim_id" "$scope" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_optim_from_protocol "$OPTIM_FILE" "$optim_id" "$scope" "$TODAY" "minimal"
      ;;
  esac

  # Validation TDD pour optimisation (tests de performance)
  if [ "$PARSED_VALIDATION_LEVEL" != "none" ]; then
    echo ""
    echo "üß™ Validation TDD pour optimisation..."
    if ! validate_tdd "$PARSED_VALIDATION_LEVEL" "OPTIMISATION"; then
      echo "‚ùå Validation TDD √©chou√©e pour optimisation"
      echo "   Les tests de performance sont recommand√©s"
      read -p "Continuer sans validation ? (y/N): " continue_without
      if [[ ! "$continue_without" =~ ^[Yy]$ ]]; then
        exit 1
      fi
    fi
  fi

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "OPTIM" "Optimisation: $scope" "OPTIM-${optim_id}-BENCHMARKING.md"
  fi

  # Commit atomique pour tra√ßabilit√© de l'optimisation
  local commit_msg="optimize: ${scope}

Optimisation OPTIM-${optim_id} initialis√©e

- Objectif: ${scope}
- Validation TDD: ${PARSED_VALIDATION_LEVEL}
- Artefact: OPTIM-${optim_id}-BENCHMARKING.md
- Protocole: OPTIMISATION"

  if ! handle_auto_backup "$commit_msg" "OPTIMISATION"; then
    echo "‚ùå √âchec du commit atomique optimisation"
    exit 1
  fi

  echo ""
  echo "‚úÖ OPTIM-${optim_id} cr√©√© et committ√© avec succ√®s !"
  echo "üìç Fichier: $OPTIM_FILE"
  echo ""
  echo "üî¨ Prochaines √©tapes (m√©thode scientifique):"
  echo "  1. D√©finir la m√©trique cibl√©e avec objectif chiffr√©"
  echo "  2. Mettre en place un protocole de benchmark reproductible"
  echo "  3. Effectuer la mesure initiale (baseline)"
  echo "  4. Analyser scientifiquement le goulet d'√©tranglement"
  echo "  5. Proposer une strat√©gie d'optimisation cibl√©e"
  echo "  6. Impl√©menter et mesurer l'am√©lioration"
  echo ""
  echo "üìä RAPPEL: Mesurer d'abord, optimiser ensuite !"
}

# Commande: security - Audit de s√©curit√©
command_security() {
  local scope="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$scope" in
    "--help"|"help"|"")
      echo "Usage: aklo security [<p√©rim√®tre>] [--scan-only]"
      echo ""
      echo "Audit de s√©curit√© selon le protocole SECURITE-AUDIT."
      echo ""
      echo "Arguments:"
      echo "  p√©rim√®tre    P√©rim√®tre d'audit (optionnel, par d√©faut: complet)"
      echo ""
      echo "Options:"
      echo "  --scan-only    Mode scan uniquement (sans triage)"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo security                                # Audit complet"
      echo "  aklo security \"D√©pendances NPM\"              # Audit cibl√©"
      echo "  aklo security \"API d'authentification\" --scan-only"
      echo ""
      echo "Workflow d'audit:"
      echo "  1. Scan automatis√© avec outils de s√©curit√©"
      echo "  2. Triage et analyse manuelle des vuln√©rabilit√©s"
      echo "  3. √âvaluation de criticit√© et impact r√©el"
      echo "  4. Plan d'action avec tasks/PBI de correction"
      echo "  5. Validation et cl√¥ture de l'audit"
      echo ""
      echo "Statuts:"
      echo "  SCANNING  - Analyse automatis√©e en cours"
      echo "  TRIAGE    - Priorisation des vuln√©rabilit√©s"
      echo "  CONCLUDED - Audit termin√© avec plan d'action"
      echo ""
      echo "üîí PRINCIPE: S√©curit√© proactive et syst√©matique"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local scan_only=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --scan-only)
            scan_only=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  # G√©n√©ration de l'ID d'audit de s√©curit√©
  SECURITY_DIR="./$(get_config "SECURITY_DIR" || echo "docs/backlog/11-security")"
  mkdir -p "$SECURITY_DIR"

  # G√©n√©rer l'ID selon le protocole (YYYY-MM-DD)
  audit_id=$(detect_id_pattern "13-SECURITE-AUDIT" "audit")
  AUDIT_FILE="${SECURITY_DIR}/AUDIT-SECURITY-${audit_id}-SCANNING.md"
  TODAY=$(date +%Y-%m-%d)
  
  # D√©finir le p√©rim√®tre par d√©faut
  if [ -z "$scope" ]; then
    scope="Audit de s√©curit√© complet"
  fi

  echo "üîí Cr√©ation de l'audit de s√©curit√© AUDIT-SECURITY-${audit_id}"
  echo "üéØ P√©rim√®tre: $scope"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole SECURITE-AUDIT..."
      generate_security_from_protocol "$AUDIT_FILE" "$audit_id" "$scope" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_security_from_protocol "$AUDIT_FILE" "$audit_id" "$scope" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_security_from_protocol "$AUDIT_FILE" "$audit_id" "$scope" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "SECURITY" "Audit de s√©curit√©: $scope" "AUDIT-SECURITY-${audit_id}-SCANNING.md"
  fi

  echo ""
  echo "‚úÖ AUDIT-SECURITY-${audit_id}-SCANNING.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $AUDIT_FILE"
  echo ""
  echo "üîí Prochaines √©tapes (m√©thode syst√©matique):"
  echo "  1. Ex√©cuter les outils d'analyse de s√©curit√© automatis√©s"
  echo "  2. Compiler les r√©sultats bruts dans le rapport"
  echo "  3. Effectuer le triage et l'analyse manuelle"
  echo "  4. √âvaluer l'impact r√©el et assigner les criticit√©s"
  echo "  5. Cr√©er le plan d'action avec tasks/PBI de correction"
  echo "  6. Valider et cl√¥turer l'audit"
  echo ""
  echo "üõ°Ô∏è RAPPEL: S√©curit√© proactive et syst√©matique !"
}

# Commande: diagnose - Diagnostic de l'environnement
command_diagnose() {
  local error_msg="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$error_msg" in
    "--help"|"help"|"")
      echo "Usage: aklo diagnose [\"<message d'erreur>\"] [--interactive]"
      echo ""
      echo "Diagnostic d'environnement selon le protocole DIAGNOSTIC-ENV."
      echo ""
      echo "Arguments:"
      echo "  erreur       Message d'erreur √† diagnostiquer (optionnel)"
      echo ""
      echo "Options:"
      echo "  --interactive  Mode interactif avec checklist guid√©e"
      echo "  --no-agent     Assistance minimale (liste seule)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo diagnose                                    # Diagnostic g√©n√©ral"
      echo "  aklo diagnose \"npm error Tracker already exists\" # Erreur sp√©cifique"
      echo "  aklo diagnose \"Cannot find module 'X'\" --interactive"
      echo ""
      echo "Proc√©dure de diagnostic:"
      echo "  1. Halte et identification de l'erreur"
      echo "  2. Consultation du catalogue des erreurs connues"
      echo "  3. Application de la solution sp√©cifique ou checklist g√©n√©rale"
      echo "  4. Validation et correction de l'environnement"
      echo ""
      echo "Erreurs catalogu√©es:"
      echo "  ‚Ä¢ npm error Tracker \"idealTree\" already exists"
      echo "  ‚Ä¢ 'npm' is not recognized as internal command"
      echo "  ‚Ä¢ Error: EPERM/EACCES permission denied"
      echo "  ‚Ä¢ Error: Cannot find module 'X'"
      echo ""
      echo "üîß PRINCIPE: Diagnostic syst√©matique avant correction"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local interactive_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --interactive)
            interactive_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  echo "üîß D√©marrage du diagnostic d'environnement"
  if [ -n "$error_msg" ]; then
    echo "üéØ Erreur rapport√©e: $error_msg"
  else
    echo "üéØ Mode: Diagnostic g√©n√©ral de l'environnement"
  fi
  echo ""

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    local journal_msg="Diagnostic d'environnement"
    if [ -n "$error_msg" ]; then
      journal_msg="Diagnostic: $error_msg"
    fi
    update_journal "DIAGNOSE" "$journal_msg" "Diagnostic en cours"
  fi

  # Analyse de l'erreur selon le catalogue
  echo "üìã √âTAPE 1: Identification et classification de l'erreur"
  echo ""
  
  local error_type="unknown"
  local solution_found=false

  if [ -n "$error_msg" ]; then
    # Catalogue des erreurs connues
    case "$error_msg" in
      *"idealTree"*"already exists"*)
        error_type="npm_tracker"
        solution_found=true
        echo "‚úÖ ERREUR CATALOGU√âE: CAS N¬∞1 - npm error Tracker 'idealTree' already exists"
        echo ""
        echo "üîç DIAGNOSTIC:"
        echo "   Conflit de processus npm ou ex√©cution depuis un mauvais r√©pertoire (WORKDIR)"
        echo ""
        echo "üõ†Ô∏è PROC√âDURE DE R√âSOLUTION:"
        echo "   1. V√©rifier qu'aucun autre processus npm n'est en cours"
        echo "   2. Forcer la re-validation du WORKDIR √† la racine du projet"
        echo "   3. Ex√©cuter 'npm cache clean --force' depuis la racine"
        echo "   4. Relancer la commande initiale"
        ;;
      *"npm"*"not recognized"*|*"npm"*"command not found"*)
        error_type="npm_missing"
        solution_found=true
        echo "‚úÖ ERREUR CATALOGU√âE: CAS N¬∞2 - 'npm' is not recognized"
        echo ""
        echo "üîç DIAGNOSTIC:"
        echo "   Probl√®me de variable d'environnement PATH. Node.js/npm non accessible"
        echo ""
        echo "üõ†Ô∏è PROC√âDURE DE R√âSOLUTION:"
        echo "   ‚ùå LIMITATION: Ce probl√®me ne peut pas √™tre r√©solu par l'agent"
        echo "   üìû ACTION REQUISE: Informer le Human_Developer que l'environnement"
        echo "      d'ex√©cution est mal configur√© et que la variable PATH doit √™tre inspect√©e"
        ;;
      *"EPERM"*|*"EACCES"*|*"permission denied"*)
        error_type="permission"
        solution_found=true
        echo "‚úÖ ERREUR CATALOGU√âE: CAS N¬∞3 - Error: EPERM/EACCES permission denied"
        echo ""
        echo "üîç DIAGNOSTIC:"
        echo "   Tentative d'√©criture/modification sans droits n√©cessaires"
        echo ""
        echo "üõ†Ô∏è PROC√âDURE DE R√âSOLUTION:"
        echo "   1. Identifier pr√©cis√©ment le fichier/dossier concern√©"
        echo "   üìû ACTION REQUISE: Informer le Human_Developer du probl√®me"
        echo "      de permission. Les permissions doivent √™tre ajust√©es manuellement"
        ;;
      *"Cannot find module"*)
        error_type="module_missing"
        solution_found=true
        echo "‚úÖ ERREUR CATALOGU√âE: CAS N¬∞4 - Error: Cannot find module"
        echo ""
        echo "üîç DIAGNOSTIC:"
        echo "   Commande lanc√©e depuis un sous-r√©pertoire au lieu de la racine,"
        echo "   ou installation de d√©pendances corrompue"
        echo ""
        echo "üõ†Ô∏è PROC√âDURE DE R√âSOLUTION:"
        echo "   1. Forcer la re-validation du WORKDIR √† la racine du projet"
        echo "   2. Relancer la commande depuis cette racine"
        echo "   3. Si l'erreur persiste: supprimer node_modules et package-lock.json"
        echo "   4. Relancer 'npm install' depuis la racine"
        ;;
    esac
  fi

  if [ "$solution_found" = false ]; then
    echo "‚ùì ERREUR NON CATALOGU√âE - Application de la checklist g√©n√©rale"
    echo ""
    echo "üìã √âTAPE 3: Checklist de diagnostic de base"
    echo ""
    echo "üîç 1. VALIDATION DU R√âPERTOIRE DE TRAVAIL (WORKDIR):"
    echo "   ‚ö†Ô∏è  Cause la plus fr√©quente de probl√®mes"
    echo "   üìç R√©pertoire actuel: $(pwd)"
    echo "   ‚úÖ V√©rifier que toutes les commandes sont lanc√©es depuis la racine absolue du projet"
    echo ""
    echo "üîç 2. V√âRIFICATION DES PERMISSIONS:"
    if [ -n "$error_msg" ]; then
      if echo "$error_msg" | grep -q -E "(EPERM|EACCES|permission)"; then
        echo "   ‚ùå L'erreur indique un probl√®me de permission"
      else
        echo "   ‚úÖ Aucun indicateur de probl√®me de permission d√©tect√©"
      fi
    else
      echo "   ‚ùì V√©rifier les permissions sur les fichiers/dossiers critiques"
    fi
    echo ""
    echo "üîç 3. √âTAT DES D√âPENDANCES:"
    if [ -n "$error_msg" ]; then
      if echo "$error_msg" | grep -q -E "(module|dependency|package)"; then
        echo "   ‚ùå L'erreur semble li√©e aux d√©pendances/modules"
      else
        echo "   ‚úÖ Aucun indicateur de probl√®me de d√©pendances d√©tect√©"
      fi
    else
      echo "   ‚ùì V√©rifier l'√©tat des node_modules et package-lock.json"
    fi
  fi

  echo ""
  echo "üìã √âTAPE 4: Actions recommand√©es"
  echo ""

  case "$error_type" in
    "npm_tracker")
      echo "üöÄ ACTIONS IMM√âDIATES:"
      echo "   1. V√©rifier les processus npm: ps aux | grep npm"
      echo "   2. Valider le WORKDIR: cd \$(git rev-parse --show-toplevel)"
      echo "   3. Nettoyer le cache: npm cache clean --force"
      echo "   4. Relancer la commande originale"
      ;;
    "npm_missing")
      echo "üö® ESCALADE REQUISE:"
      echo "   Configuration d'environnement requise par l'administrateur syst√®me"
      ;;
    "permission")
      echo "üö® ESCALADE REQUISE:"
      echo "   Ajustement des permissions requis par l'administrateur syst√®me"
      ;;
    "module_missing")
      echo "üöÄ ACTIONS IMM√âDIATES:"
      echo "   1. Valider le WORKDIR: cd \$(git rev-parse --show-toplevel)"
      echo "   2. Relancer depuis la racine"
      echo "   3. Si √©chec: rm -rf node_modules package-lock.json"
      echo "   4. R√©installer: npm install"
      ;;
    "unknown")
      echo "ü§î DIAGNOSTIC MANUEL REQUIS:"
      echo "   1. Corriger le WORKDIR si n√©cessaire"
      echo "   2. V√©rifier les permissions sur les ressources critiques"
      echo "   3. V√©rifier l'√©tat des d√©pendances"
      echo "   4. Pr√©senter les r√©sultats au Human_Developer"
      ;;
  esac

  echo ""
  echo "‚úÖ Diagnostic d'environnement termin√©"
  echo "üîß RAPPEL: Diagnostic syst√©matique avant correction !"
}

# Commande: experiment - Gestion d'exp√©rimentation A/B
command_experiment() {
  local hypothesis="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$hypothesis" in
    "--help"|"help"|"")
      echo "Usage: aklo experiment \"<hypoth√®se>\" [--ab-test]"
      echo ""
      echo "Gestion d'exp√©rimentation A/B selon le protocole EXPERIMENTATION."
      echo ""
      echo "Arguments:"
      echo "  hypoth√®se    Hypoth√®se √† valider par exp√©rimentation (requis)"
      echo ""
      echo "Options:"
      echo "  --ab-test      Mode A/B test complet avec m√©triques"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo experiment \"Bouton CTA rouge augmente conversion\""
      echo "  aklo experiment \"Nouveau onboarding r√©duit churn\" --ab-test"
      echo "  aklo experiment \"Feature X am√©liore engagement utilisateur\""
      echo ""
      echo "Workflow d'exp√©rimentation:"
      echo "  1. Planification et d√©finition de l'hypoth√®se"
      echo "  2. Impl√©mentation technique (feature flags, tracking)"
      echo "  3. Ex√©cution et monitoring des m√©triques"
      echo "  4. Analyse des r√©sultats et significativit√© statistique"
      echo "  5. D√©cision et cl√¥ture (g√©n√©raliser ou abandonner)"
      echo ""
      echo "Statuts:"
      echo "  PLANNING              - D√©finition hypoth√®se et m√©triques"
      echo "  AWAITING_IMPLEMENTATION - Plan valid√©, en attente dev"
      echo "  RUNNING               - Exp√©rience en ligne collectant donn√©es"
      echo "  COMPLETED             - Exp√©rience termin√©e, en attente analyse"
      echo "  CONCLUDED             - Analyse termin√©e avec d√©cision prise"
      echo ""
      echo "üß™ PRINCIPE: Validation scientifique bas√©e sur les donn√©es"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local ab_test_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --ab-test)
            ab_test_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$hypothesis" ]; then
    echo "Erreur : Hypoth√®se d'exp√©rimentation requise." >&2
    echo "Utilisez 'aklo experiment --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID d'exp√©rimentation
  EXPERIMENTS_DIR="./$(get_config "EXPERIMENTS_DIR" || echo "docs/backlog/09-experiments")"
  mkdir -p "$EXPERIMENTS_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  experiment_id=$(detect_id_pattern "11-EXPERIMENTATION" "$hypothesis")
  EXPERIMENT_FILE="${EXPERIMENTS_DIR}/EXPERIMENT-${experiment_id}-PLANNING.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üß™ Cr√©ation de l'exp√©rimentation EXPERIMENT-${experiment_id}"
  echo "üéØ Hypoth√®se: $hypothesis"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole EXPERIMENTATION..."
      generate_experiment_from_protocol "$EXPERIMENT_FILE" "$experiment_id" "$hypothesis" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_experiment_from_protocol "$EXPERIMENT_FILE" "$experiment_id" "$hypothesis" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_experiment_from_protocol "$EXPERIMENT_FILE" "$experiment_id" "$hypothesis" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "EXPERIMENT" "Exp√©rimentation: $hypothesis" "EXPERIMENT-${experiment_id}-PLANNING.md"
  fi

  echo ""
  echo "‚úÖ EXPERIMENT-${experiment_id}-PLANNING.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $EXPERIMENT_FILE"
  echo ""
  echo "üß™ Prochaines √©tapes (m√©thode scientifique):"
  echo "  1. D√©finir l'hypoth√®se avec crit√®res de succ√®s mesurables"
  echo "  2. Concevoir les variantes A (contr√¥le) et B (test)"
  echo "  3. Planifier l'impl√©mentation technique (feature flags, tracking)"
  echo "  4. Valider le plan avant impl√©mentation"
  echo "  5. Ex√©cuter l'exp√©rience et monitorer les m√©triques"
  echo "  6. Analyser les r√©sultats avec significativit√© statistique"
  echo "  7. Prendre une d√©cision bas√©e sur les donn√©es"
  echo ""
  echo "üìä RAPPEL: Validation scientifique bas√©e sur les donn√©es !"
}

# Commande: docs - Documentation utilisateur
command_docs() {
  local topic="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$topic" in
    "--help"|"help"|"")
      echo "Usage: aklo docs \"<sujet de documentation>\" [--guide]"
      echo ""
      echo "Documentation utilisateur selon le protocole USER-DOCS."
      echo ""
      echo "Arguments:"
      echo "  sujet        Sujet de la documentation √† cr√©er (requis)"
      echo ""
      echo "Options:"
      echo "  --guide        Mode guide utilisateur d√©taill√©"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo docs \"Nouvelle fonctionnalit√© de paiement\""
      echo "  aklo docs \"Guide d'utilisation avanc√©e\" --guide"
      echo "  aklo docs \"FAQ mise √† jour limites de compte\""
      echo ""
      echo "Workflow de documentation:"
      echo "  1. Identification du besoin de documentation"
      echo "  2. R√©daction du contenu (plan et contenu brut)"
      echo "  3. Relecture et validation par Human_Developer"
      echo "  4. Publication sur la plateforme de documentation"
      echo ""
      echo "Statuts:"
      echo "  DRAFT           - R√©daction en cours"
      echo "  AWAITING_REVIEW - Pr√™t pour relecture et validation"
      echo "  PUBLISHED       - Documentation mise en ligne"
      echo ""
      echo "Audiences cibles:"
      echo "  ‚Ä¢ Nouveaux utilisateurs"
      echo "  ‚Ä¢ Administrateurs de compte"
      echo "  ‚Ä¢ Tous les utilisateurs"
      echo ""
      echo "üìö PRINCIPE: Documentation claire et synchronis√©e"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local guide_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --guide)
            guide_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$topic" ]; then
    echo "Erreur : Sujet de documentation requis." >&2
    echo "Utilisez 'aklo docs --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID de documentation
  USER_DOCS_DIR="./$(get_config "USER_DOCS_DIR" || echo "docs/backlog/14-user-docs")"
  mkdir -p "$USER_DOCS_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  docs_id=$(detect_id_pattern "17-USER-DOCS" "$topic")
  DOCS_FILE="${USER_DOCS_DIR}/USER-DOCS-${docs_id}-DRAFT.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üìö Cr√©ation de la documentation USER-DOCS-${docs_id}"
  echo "üéØ Sujet: $topic"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole USER-DOCS..."
      generate_docs_from_protocol "$DOCS_FILE" "$docs_id" "$topic" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_docs_from_protocol "$DOCS_FILE" "$docs_id" "$topic" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_docs_from_protocol "$DOCS_FILE" "$docs_id" "$topic" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "DOCS" "Documentation: $topic" "USER-DOCS-${docs_id}-DRAFT.md"
  fi

  echo ""
  echo "‚úÖ USER-DOCS-${docs_id}-DRAFT.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $DOCS_FILE"
  echo ""
  echo "üìö Prochaines √©tapes (processus de documentation):"
  echo "  1. D√©finir l'objectif et l'audience cible de la documentation"
  echo "  2. √âlaborer le plan de contenu avec structure claire"
  echo "  3. R√©diger le contenu en langage simple et accessible"
  echo "  4. Soumettre pour relecture et validation"
  echo "  5. Publier sur la plateforme de documentation"
  echo ""
  echo "‚úçÔ∏è RAPPEL: Documentation claire et synchronis√©e !"
}

# Commande: analyze - Analyse de la concurrence
command_analyze() {
  local subject="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$subject" in
    "--help"|"help"|"")
      echo "Usage: aklo analyze \"<sujet d'analyse>\" [--features]"
      echo ""
      echo "Analyse de la concurrence selon le protocole ANALYSE-CONCURRENCE."
      echo ""
      echo "Arguments:"
      echo "  sujet        Sujet de l'analyse concurrentielle (requis)"
      echo ""
      echo "Options:"
      echo "  --features     Mode analyse de fonctionnalit√©s sp√©cifiques"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo analyze \"M√©thodes d'authentification concurrentes\""
      echo "  aklo analyze \"Interfaces de paiement\" --features"
      echo "  aklo analyze \"Strat√©gies de pricing des concurrents\""
      echo ""
      echo "Workflow d'analyse:"
      echo "  1. Cadrage de l'analyse et identification des concurrents"
      echo "  2. Recherche et synth√®se des informations"
      echo "  3. Analyse d√©taill√©e par concurrent"
      echo "  4. Recommandations et plan d'action"
      echo "  5. Validation et cr√©ation des PBI de suivi"
      echo ""
      echo "Statuts:"
      echo "  ANALYSIS  - Recherche et r√©daction en cours"
      echo "  CONCLUDED - Analyse termin√©e avec actions de suivi"
      echo ""
      echo "Livrables:"
      echo "  ‚Ä¢ Rapport d'analyse concurrentielle complet"
      echo "  ‚Ä¢ Propositions de PBI d√©coulant des conclusions"
      echo "  ‚Ä¢ Recommandations actionnables"
      echo ""
      echo "üîç PRINCIPE: Analyse structur√©e pour opportunit√©s actionnables"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local features_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --features)
            features_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$subject" ]; then
    echo "Erreur : Sujet d'analyse concurrentielle requis." >&2
    echo "Utilisez 'aklo analyze --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID d'analyse
  COMPETITION_DIR="./$(get_config "COMPETITION_DIR" || echo "docs/backlog/10-competition")"
  mkdir -p "$COMPETITION_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  analysis_id=$(detect_id_pattern "12-ANALYSE-CONCURRENCE" "$subject")
  ANALYSIS_FILE="${COMPETITION_DIR}/COMPETITION-${analysis_id}-ANALYSIS.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üîç Cr√©ation de l'analyse concurrentielle COMPETITION-${analysis_id}"
  echo "üéØ Sujet: $subject"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole ANALYSE-CONCURRENCE..."
      generate_analysis_from_protocol "$ANALYSIS_FILE" "$analysis_id" "$subject" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_analysis_from_protocol "$ANALYSIS_FILE" "$analysis_id" "$subject" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_analysis_from_protocol "$ANALYSIS_FILE" "$analysis_id" "$subject" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "ANALYZE" "Analyse concurrentielle: $subject" "COMPETITION-${analysis_id}-ANALYSIS.md"
  fi

  echo ""
  echo "‚úÖ COMPETITION-${analysis_id}-ANALYSIS.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $ANALYSIS_FILE"
  echo ""
  echo "üîç Prochaines √©tapes (analyse structur√©e):"
  echo "  1. Identifier clairement les concurrents √† analyser"
  echo "  2. Mener la recherche sur le sujet d√©fini"
  echo "  3. Synth√©tiser les observations par concurrent"
  echo "  4. Formuler des recommandations actionnables"
  echo "  5. Valider et cr√©er les PBI de suivi"
  echo ""
  echo "üìä RAPPEL: Analyse structur√©e pour opportunit√©s actionnables !"
}

# Commande: track - Plan de tracking
command_track() {
  local feature_id="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$feature_id" in
    "--help"|"help"|"")
      echo "Usage: aklo track <PBI_ID|feature_name> [--plan]"
      echo ""
      echo "Plan de tracking selon le protocole TRACKING-PLAN."
      echo ""
      echo "Arguments:"
      echo "  feature_id   ID du PBI ou nom de la fonctionnalit√© (requis)"
      echo ""
      echo "Options:"
      echo "  --plan         Mode plan d√©taill√© avec m√©triques"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo track PBI-42                    # Tracking pour PBI-42"
      echo "  aklo track \"feature-login\" --plan    # Plan d√©taill√©"
      echo "  aklo track \"new-payment-flow\""
      echo ""
      echo "Workflow de tracking:"
      echo "  1. D√©finition des objectifs de collecte"
      echo "  2. D√©finition des √©v√©nements et m√©triques"
      echo "  3. Validation du plan par Human_Developer"
      echo "  4. Int√©gration au d√©veloppement (Tasks)"
      echo ""
      echo "Statuts:"
      echo "  DRAFT                 - D√©finition du plan en cours"
      echo "  AWAITING_IMPLEMENTATION - Plan valid√©, pr√™t pour dev"
      echo "  IMPLEMENTED           - Plan impl√©ment√© en production"
      echo ""
      echo "Types de donn√©es:"
      echo "  ‚Ä¢ √âv√©nements utilisateur (Analytics)"
      echo "  ‚Ä¢ M√©triques de performance (Observability)"
      echo "  ‚Ä¢ Logs techniques (Debugging)"
      echo ""
      echo "üìä PRINCIPE: Collecte intentionnelle et structur√©e"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local plan_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --plan)
            plan_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$feature_id" ]; then
    echo "Erreur : ID de fonctionnalit√© ou PBI requis." >&2
    echo "Utilisez 'aklo track --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID de tracking
  TRACKING_DIR="./$(get_config "TRACKING_DIR" || echo "docs/backlog/13-tracking")"
  mkdir -p "$TRACKING_DIR"

  # G√©n√©rer l'ID selon le protocole (ID du PBI ou de la fonctionnalit√©)
  tracking_id=$(detect_id_pattern "16-TRACKING-PLAN" "$feature_id")
  TRACKING_FILE="${TRACKING_DIR}/TRACKING-PLAN-${tracking_id}-DRAFT.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üìä Cr√©ation du plan de tracking TRACKING-PLAN-${tracking_id}"
  echo "üéØ Fonctionnalit√©: $feature_id"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole TRACKING-PLAN..."
      generate_tracking_from_protocol "$TRACKING_FILE" "$tracking_id" "$feature_id" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_tracking_from_protocol "$TRACKING_FILE" "$tracking_id" "$feature_id" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_tracking_from_protocol "$TRACKING_FILE" "$tracking_id" "$feature_id" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "TRACK" "Plan de tracking: $feature_id" "TRACKING-PLAN-${tracking_id}-DRAFT.md"
  fi

  echo ""
  echo "‚úÖ TRACKING-PLAN-${tracking_id}-DRAFT.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $TRACKING_FILE"
  echo ""
  echo "üìä Prochaines √©tapes (plan de tracking):"
  echo "  1. D√©finir les objectifs de collecte de donn√©es"
  echo "  2. Sp√©cifier les √©v√©nements, m√©triques et logs"
  echo "  3. Pr√©ciser les destinations et outils concern√©s"
  echo "  4. Valider le plan avec Human_Developer"
  echo "  5. Int√©grer dans les Tasks de d√©veloppement"
  echo ""
  echo "üìà RAPPEL: Collecte intentionnelle et structur√©e !"
}

# Commande: onboard - Onboarding de projet
command_onboard() {
  local user_role="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$user_role" in
    "--help"|"help"|"")
      echo "Usage: aklo onboard [<user_role>] [--role]"
      echo ""
      echo "Onboarding de projet selon le protocole ONBOARDING."
      echo ""
      echo "Arguments:"
      echo "  user_role    R√¥le du nouvel utilisateur (optionnel)"
      echo ""
      echo "Options:"
      echo "  --role         Mode sp√©cialis√© par r√¥le utilisateur"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo onboard                         # Onboarding g√©n√©ral"
      echo "  aklo onboard \"developer\" --role      # Onboarding d√©veloppeur"
      echo "  aklo onboard \"product-manager\""
      echo ""
      echo "Workflow d'onboarding:"
      echo "  1. Cadrage de l'intention d'onboarding"
      echo "  2. Collecte d'informations projet"
      echo "  3. R√©daction du rapport de synth√®se"
      echo "  4. Livraison du r√©sum√© d'onboarding"
      echo ""
      echo "Contenu du rapport:"
      echo "  ‚Ä¢ Mission et objectif du projet"
      echo "  ‚Ä¢ Concepts m√©tier cl√©s (glossaire)"
      echo "  ‚Ä¢ Vue d'ensemble de l'architecture"
      echo "  ‚Ä¢ D√©marrage rapide (quick start)"
      echo "  ‚Ä¢ Points d'entr√©e du code"
      echo ""
      echo "Livrable:"
      echo "  ‚Ä¢ ONBOARDING-SUMMARY-YYYY-MM-DD.md"
      echo ""
      echo "üëã PRINCIPE: Int√©gration rapide et contexte global"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local role_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --role)
            role_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  # G√©n√©ration de l'ID d'onboarding (date)
  ONBOARDING_DIR="./$(get_config "ONBOARDING_DIR" || echo "docs/project")"
  mkdir -p "$ONBOARDING_DIR"

  # G√©n√©rer l'ID selon le protocole (date AAAA-MM-DD)
  onboarding_id=$(detect_id_pattern "14-ONBOARDING" "")
  ONBOARDING_FILE="${ONBOARDING_DIR}/ONBOARDING-SUMMARY-${onboarding_id}.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üëã Cr√©ation du rapport d'onboarding ONBOARDING-SUMMARY-${onboarding_id}"
  if [ -n "$user_role" ]; then
    echo "üéØ R√¥le cible: $user_role"
  else
    echo "üéØ Onboarding g√©n√©ral"
  fi

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole ONBOARDING..."
      generate_onboarding_from_protocol "$ONBOARDING_FILE" "$onboarding_id" "$user_role" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_onboarding_from_protocol "$ONBOARDING_FILE" "$onboarding_id" "$user_role" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_onboarding_from_protocol "$ONBOARDING_FILE" "$onboarding_id" "$user_role" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "ONBOARD" "Onboarding projet: $user_role" "ONBOARDING-SUMMARY-${onboarding_id}.md"
  fi

  echo ""
  echo "‚úÖ ONBOARDING-SUMMARY-${onboarding_id}.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $ONBOARDING_FILE"
  echo ""
  echo "üëã Prochaines √©tapes (onboarding):"
  echo "  1. R√©viser la mission et les objectifs du projet"
  echo "  2. Compl√©ter le glossaire des concepts m√©tier"
  echo "  3. Valider l'architecture et les points d'entr√©e"
  echo "  4. Tester les instructions de d√©marrage rapide"
  echo "  5. Pr√©senter le rapport au nouveau membre"
  echo ""
  echo "üöÄ RAPPEL: Int√©gration rapide et contexte global !"
}

# Commande: deprecate - D√©pr√©ciation de fonctionnalit√©
command_deprecate() {
  local feature="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$feature" in
    "--help"|"help"|"")
      echo "Usage: aklo deprecate \"<fonctionnalit√©>\" [--timeline]"
      echo ""
      echo "D√©pr√©ciation de fonctionnalit√© selon le protocole DEPRECATION."
      echo ""
      echo "Arguments:"
      echo "  feature      Nom de la fonctionnalit√© √† d√©pr√©cier (requis)"
      echo ""
      echo "Options:"
      echo "  --timeline     Mode avec timeline d√©taill√©e"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo deprecate \"API v1 billing\""
      echo "  aklo deprecate \"Legacy auth system\" --timeline"
      echo "  aklo deprecate \"Old dashboard module\""
      echo ""
      echo "Workflow de d√©pr√©ciation:"
      echo "  1. Analyse et planification du retrait"
      echo "  2. Ex√©cution de la suppression technique"
      echo "  3. Communication et cl√¥ture"
      echo ""
      echo "Statuts:"
      echo "  ANALYSIS          - Analyse d'impact en cours"
      echo "  AWAITING_EXECUTION - Plan valid√©, pr√™t pour suppression"
      echo "  EXECUTED          - Code retir√©, version pr√™te"
      echo "  COMMUNICATED      - Suppression communiqu√©e (fini)"
      echo ""
      echo "Livrables:"
      echo "  ‚Ä¢ Plan de d√©pr√©ciation complet"
      echo "  ‚Ä¢ Commits de suppression"
      echo "  ‚Ä¢ Communication utilisateur (si applicable)"
      echo ""
      echo "üìâ PRINCIPE: Retrait s√©curis√© et contr√¥l√©"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local timeline_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --timeline)
            timeline_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$feature" ]; then
    echo "Erreur : Nom de la fonctionnalit√© √† d√©pr√©cier requis." >&2
    echo "Utilisez 'aklo deprecate --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID de d√©pr√©ciation
  DEPRECATION_DIR="./$(get_config "DEPRECATION_DIR" || echo "docs/backlog/12-deprecations")"
  mkdir -p "$DEPRECATION_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  deprecation_id=$(detect_id_pattern "15-DEPRECATION" "$feature")
  DEPRECATION_FILE="${DEPRECATION_DIR}/DEPRECATION-${deprecation_id}-ANALYSIS.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üìâ Cr√©ation du plan de d√©pr√©ciation DEPRECATION-${deprecation_id}"
  echo "üéØ Fonctionnalit√©: $feature"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole DEPRECATION..."
      generate_deprecation_from_protocol "$DEPRECATION_FILE" "$deprecation_id" "$feature" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_deprecation_from_protocol "$DEPRECATION_FILE" "$deprecation_id" "$feature" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_deprecation_from_protocol "$DEPRECATION_FILE" "$deprecation_id" "$feature" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "DEPRECATE" "D√©pr√©ciation: $feature" "DEPRECATION-${deprecation_id}-ANALYSIS.md"
  fi

  echo ""
  echo "‚úÖ DEPRECATION-${deprecation_id}-ANALYSIS.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $DEPRECATION_FILE"
  echo ""
  echo "üìâ Prochaines √©tapes (d√©pr√©ciation):"
  echo "  1. Analyser l'impact utilisateur et technique"
  echo "  2. D√©finir le plan d'action technique"
  echo "  3. Planifier la communication si n√©cessaire"
  echo "  4. Valider le plan avec Human_Developer"
  echo "  5. Ex√©cuter la suppression (Tasks)"
  echo ""
  echo "‚ö†Ô∏è  RAPPEL: Retrait s√©curis√© et contr√¥l√© !"
}

# Commande: kb - Knowledge Base
command_kb() {
  local action="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$action" in
    "--help"|"help"|"")
      echo "Usage: aklo kb <action> [arguments]"
      echo ""
      echo "Gestion de la base de connaissances selon le protocole KNOWLEDGE-BASE."
      echo ""
      echo "Actions:"
      echo "  search <query>       Rechercher dans la base de connaissances"
      echo "  add <subject>        Ajouter une nouvelle connaissance"
      echo "  update <KB-ID>       Mettre √† jour une entr√©e existante"
      echo ""
      echo "Options globales:"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo kb search \"performance\""
      echo "  aklo kb add \"Probl√®me avec Redis clustering\""
      echo "  aklo kb update KB-003"
      echo ""
      echo "Workflow Knowledge Base:"
      echo "  1. D√©tection d'une connaissance critique"
      echo "  2. Proposition d'ajout √† la base"
      echo "  3. Validation par Human_Developer"
      echo "  4. Mise √† jour du fichier KNOWLEDGE-BASE.md"
      echo ""
      echo "Structure des entr√©es:"
      echo "  ‚Ä¢ ID unique (KB-XXX)"
      echo "  ‚Ä¢ Sujet et statut"
      echo "  ‚Ä¢ Connaissance acquise"
      echo "  ‚Ä¢ Analyse d'impact"
      echo "  ‚Ä¢ Recommandation actionnable"
      echo ""
      echo "üìö PRINCIPE: Capitalisation des apprentissages"
      exit 0
      ;;
    "search")
      shift
      kb_search "$@"
      ;;
    "add")
      shift
      kb_add "$@"
      ;;
    "update")
      shift
      kb_update "$@"
      ;;
    *)
      echo "Action inconnue: $action" >&2
      echo "Utilisez 'aklo kb --help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Sous-commande: kb search
kb_search() {
  local query="$1"
  
  if [ -z "$query" ]; then
    echo "Erreur : Terme de recherche requis." >&2
    echo "Usage: aklo kb search <query>"
    exit 1
  fi

  KB_FILE="./$(get_config "KB_FILE" || echo "docs/KNOWLEDGE-BASE.md")"
  
  if [ ! -f "$KB_FILE" ]; then
    echo "üìö Base de connaissances non trouv√©e: $KB_FILE"
    echo "Utilisez 'aklo kb add' pour cr√©er la premi√®re entr√©e."
    exit 1
  fi

  echo "üîç Recherche dans la base de connaissances: '$query'"
  echo "üìç Fichier: $KB_FILE"
  echo ""

  # Recherche avec contexte (3 lignes avant et apr√®s)
  if grep -i -A 3 -B 3 "$query" "$KB_FILE" > /dev/null 2>&1; then
    echo "üìö R√©sultats trouv√©s:"
    echo "===================="
    grep -i -A 10 -B 2 --color=always "$query" "$KB_FILE" | head -50
    echo ""
    echo "üí° Utilisez 'less $KB_FILE' pour voir le fichier complet."
  else
    echo "‚ùå Aucun r√©sultat trouv√© pour '$query'"
    echo ""
    echo "üí° Suggestions:"
    echo "  ‚Ä¢ V√©rifiez l'orthographe du terme"
    echo "  ‚Ä¢ Essayez des mots-cl√©s plus g√©n√©raux"
    echo "  ‚Ä¢ Consultez le fichier complet: less $KB_FILE"
  fi
}

# Sous-commande: kb add
kb_add() {
  local subject="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  if [ -z "$subject" ]; then
    echo "Erreur : Sujet de la connaissance requis." >&2
    echo "Usage: aklo kb add \"<sujet>\""
    exit 1
  fi

  KB_FILE="./$(get_config "KB_FILE" || echo "docs/KNOWLEDGE-BASE.md")"
  KB_DIR=$(dirname "$KB_FILE")
  mkdir -p "$KB_DIR"

  echo "üìö Ajout d'une nouvelle connaissance √† la base"
  echo "üéØ Sujet: $subject"

  # G√©n√©rer le prochain ID KB-XXX
  next_id="KB-001"
  if [ -f "$KB_FILE" ]; then
    # Trouver le dernier ID et incr√©menter
    last_id=$(grep -o "ID: KB-[0-9]*" "$KB_FILE" | tail -1 | sed 's/ID: KB-//')
    if [ -n "$last_id" ]; then
      next_num=$((last_id + 1))
      next_id=$(printf "KB-%03d" $next_num)
    fi
  fi

  TODAY=$(date +%Y-%m-%d)

  # Cr√©er ou enrichir le fichier selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te de l'entr√©e $next_id..."
      kb_generate_entry "$KB_FILE" "$next_id" "$subject" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure d'entr√©e √† compl√©ter..."
      kb_generate_entry "$KB_FILE" "$next_id" "$subject" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale..."
      kb_generate_entry "$KB_FILE" "$next_id" "$subject" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "KB_ADD" "Ajout KB: $subject" "$next_id dans KNOWLEDGE-BASE.md"
  fi

  echo ""
  echo "‚úÖ Entr√©e $next_id ajout√©e avec succ√®s !"
  echo "üìç Fichier: $KB_FILE"
  echo ""
  echo "üìö Prochaines √©tapes:"
  echo "  1. Compl√©ter l'analyse d'impact"
  echo "  2. Pr√©ciser la recommandation actionnable"
  echo "  3. Valider avec Human_Developer"
  echo "  4. Commit: git commit -m \"docs(kb): add $next_id - $subject\""
  echo ""
  echo "üß† RAPPEL: Capitalisation des apprentissages !"
}

# Sous-commande: kb update (placeholder)
kb_update() {
  local kb_id="$1"
  
  if [ -z "$kb_id" ]; then
    echo "Erreur : ID de l'entr√©e requis." >&2
    echo "Usage: aklo kb update <KB-ID>"
    exit 1
  fi

  echo "üîß Mise √† jour de l'entr√©e $kb_id"
  echo "üìù Fonctionnalit√© en cours de d√©veloppement..."
  echo ""
  echo "üí° Pour l'instant, √©ditez manuellement le fichier:"
  echo "   $(get_config "KB_FILE" || echo "docs/KNOWLEDGE-BASE.md")"
}

# G√©n√©ration d'entr√©e KB
kb_generate_entry() {
  local file="$1"
  local kb_id="$2"
  local subject="$3"
  local date="$4"
  local assistance_level="$5"

  # Cr√©er le fichier de base s'il n'existe pas
  if [ ! -f "$file" ]; then
    cat > "$file" << 'EOF'
# BASE DE CONNAISSANCES DU PROJET
---
*Ce document est la source de v√©rit√© pour les d√©cisions techniques r√©currentes et les le√ßons apprises. Il doit √™tre consult√© avant toute d√©cision d'architecture ou de choix de d√©pendance.*

---
EOF
  fi

  # Template d'entr√©e selon le niveau d'assistance
  case "$assistance_level" in
    "full")
      cat >> "$file" << EOF
## ID: $kb_id
**Sujet:** $subject
**Statut:** Actif
**Date d'ajout:** $date
**Source:** [√Ä compl√©ter - lien vers l'artefact source]

#### Connaissance
[D√©crire la connaissance critique acquise - que s'est-il pass√© ?]

#### Analyse d'Impact
- **Impact Direct :** [Comment cela affecte-t-il le projet actuellement ?]
- **Risque :** [Quel risque si cette connaissance n'est pas appliqu√©e ?]

#### Recommandation Actionnable
1. **ACTION 1 :** [Que faut-il faire concr√®tement ?]
2. **ACTION 2 :** [Autre action recommand√©e]
3. **VALIDATION :** [Comment valider que la recommandation est suivie ?]

---
EOF
      ;;
    "skeleton")
      cat >> "$file" << EOF
## ID: $kb_id
**Sujet:** $subject
**Statut:** Actif
**Date d'ajout:** $date
**Source:** [√Ä compl√©ter]

#### Connaissance
[√Ä compl√©ter]

#### Analyse d'Impact
- **Impact Direct :** [√Ä compl√©ter]
- **Risque :** [√Ä compl√©ter]

#### Recommandation Actionnable
1. [√Ä compl√©ter]

---
EOF
      ;;
    "minimal")
      cat >> "$file" << EOF
## ID: $kb_id
**Sujet:** $subject
**Date d'ajout:** $date

[√Ä compl√©ter]

---
EOF
      ;;
     esac
}

# Commande: fast - Fast Track
command_fast() {
  local task="$1"
  
  # Parser les arguments de validation et backup (sans le premier argument qui est la t√¢che)
  shift
  parse_validation_args "optional" "$@"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$task" in
    "--help"|"help"|"")
      echo "Usage: aklo fast \"<t√¢che>\" [--skip-validation]"
      echo ""
      echo "Proc√©dure acc√©l√©r√©e selon le protocole FAST-TRACK."
      echo ""
      echo "Arguments:"
      echo "  task         Description de la t√¢che mineure (requis)"
      echo ""
      echo "Options:"
      echo "  --skip-validation  Validation minimale (√† utiliser avec pr√©caution)"
      echo "  --no-agent         Assistance minimale (skeleton)"
      echo "  --no-journal       D√©sactiver la mise √† jour du journal"
      echo "  --no-validation    D√©sactiver validation TDD (linter/tests optionnels)"
      echo "  --force-validation Forcer validation TDD compl√®te"
      echo "  --auto-commit      Commit automatique sans validation humaine"
      echo "  --manual-commit    Demander validation humaine avant commit"
      echo ""
      echo "Exemples:"
      echo "  aklo fast \"Corriger faute de frappe dans le titre\""
      echo "  aklo fast \"Ajuster couleur du bouton principal\""
      echo "  aklo fast \"Mettre √† jour version dans package.json\""
      echo ""
      echo "Workflow Fast-Track:"
      echo "  1. Initialisation par Human_Developer"
      echo "  2. Impl√©mentation rapide par AI_Agent"
      echo "  3. Validation minimale"
      echo "  4. Commit s√©mantique et finalisation"
      echo ""
      echo "Statuts:"
      echo "  TODO - T√¢che d√©finie, pr√™te √† √™tre ex√©cut√©e"
      echo "  DONE - Diff valid√©, commit cr√©√©"
      echo ""
      echo "Crit√®res Fast-Track:"
      echo "  ‚Ä¢ Modification mineure √† faible risque"
      echo "  ‚Ä¢ Pas d'impact sur la logique m√©tier"
      echo "  ‚Ä¢ Ne justifie pas un cycle PBI -> TASK complet"
      echo ""
      echo "‚ö° PRINCIPE: Rapidit√© avec tra√ßabilit√© compl√®te"
      exit 0
      ;;
    *)
      # Les arguments sont d√©j√† pars√©s par parse_validation_args
      # On r√©cup√®re les arguments restants pour les options sp√©cifiques √† fast
      shift
      while [ $# -gt 0 ]; do
        case "$1" in
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          --no-validation|--force-validation|--auto-commit|--manual-commit)
            # D√©j√† trait√©s par parse_validation_args, ignorer
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$task" ]; then
    echo "Erreur : Description de la t√¢che fast-track requise." >&2
    echo "Utilisez 'aklo fast --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID fast-track
  FAST_DIR="./$(get_config "FAST_DIR" || echo "docs/backlog/17-fast-track")"
  mkdir -p "$FAST_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  fast_id=$(detect_id_pattern "20-FAST-TRACK" "$task")
  FAST_FILE="${FAST_DIR}/FAST-${fast_id}-TODO.md"
  TODAY=$(date +%Y-%m-%d)

  echo "‚ö° Cr√©ation de la t√¢che fast-track FAST-${fast_id}"
  echo "üéØ T√¢che: $task"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole FAST-TRACK..."
      generate_fast_from_protocol "$FAST_FILE" "$fast_id" "$task" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_fast_from_protocol "$FAST_FILE" "$fast_id" "$task" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_fast_from_protocol "$FAST_FILE" "$fast_id" "$task" "$TODAY" "minimal"
      ;;
  esac

  # Validation TDD si activ√©e et non skip_validation
  if [ "$PARSED_SKIP_VALIDATION" != "true" ] && [ "$PARSED_VALIDATION_LEVEL" != "none" ]; then
    echo ""
    echo "üîç Validation TDD pour FAST-TRACK..."
    if ! validate_tdd "$PARSED_VALIDATION_LEVEL" "FAST-TRACK"; then
      echo "‚ùå Validation TDD √©chou√©e. Arr√™t du processus."
      return 1
    fi
  fi

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "FAST" "Fast-track: $task" "FAST-${fast_id}-TODO.md"
  fi

  echo ""
  echo "‚úÖ FAST-${fast_id}-TODO.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $FAST_FILE"
  echo ""
  
  # Commit atomique selon configuration AUTO_BACKUP
  local commit_msg="feat(fast): ${task}

Fast-track FAST-${fast_id} - Modification mineure

- Artefact: FAST-${fast_id}-TODO.md
- Protocole: FAST-TRACK
- Validation: ${PARSED_VALIDATION_LEVEL}"

  if ! handle_auto_backup "$commit_msg" "FAST-TRACK"; then
    echo "‚ùå √âchec du commit atomique"
    return 1
  fi
  
  echo ""
  echo "üöÄ FAST-TRACK termin√© avec succ√®s !"
}

# Commande: meta - Meta Improvement
command_meta() {
  local improvement="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$improvement" in
    "--help"|"help"|"")
      echo "Usage: aklo meta \"<am√©lioration>\" [--analyze]"
      echo ""
      echo "Am√©lioration de la charte selon le protocole META-IMPROVEMENT."
      echo ""
      echo "Arguments:"
      echo "  improvement  Description de l'am√©lioration propos√©e (requis)"
      echo ""
      echo "Options:"
      echo "  --analyze      Mode analyse d'impact d√©taill√©e"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   D√©sactiver la mise √† jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo meta \"Simplifier le protocole DEBUG pour les bugs √©vidents\""
      echo "  aklo meta \"Ajouter support pour les tests automatis√©s\" --analyze"
      echo "  aklo meta \"Am√©liorer la tra√ßabilit√© des PBI\""
      echo ""
      echo "Workflow Meta-Improvement:"
      echo "  1. Identification d'une friction"
      echo "  2. Validation de la proposition"
      echo "  3. Impl√©mentation des modifications"
      echo "  4. Finalisation et commit de la charte"
      echo ""
      echo "Statuts:"
      echo "  PROPOSED    - Proposition r√©dig√©e, en attente de discussion"
      echo "  ACCEPTED    - Proposition valid√©e, pr√™te pour impl√©mentation"
      echo "  IMPLEMENTED - Charte mise √† jour"
      echo ""
      echo "Livrables:"
      echo "  ‚Ä¢ Proposition d'am√©lioration d√©taill√©e"
      echo "  ‚Ä¢ Mise √† jour de la charte (commit)"
      echo "  ‚Ä¢ Analyse d'impact sur les autres protocoles"
      echo ""
      echo "üîÑ PRINCIPE: √âvolution continue de la charte"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local analyze_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --analyze)
            analyze_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$improvement" ]; then
    echo "Erreur : Description de l'am√©lioration requise." >&2
    echo "Utilisez 'aklo meta --help' pour plus d'informations."
    exit 1
  fi

  # G√©n√©ration de l'ID meta-improvement
  META_DIR="./$(get_config "META_DIR" || echo "docs/backlog/18-improvements")"
  mkdir -p "$META_DIR"

  # G√©n√©rer l'ID selon le protocole (description-slugifi√©e-YYYYMMDD)
  meta_id=$(detect_id_pattern "21-META-IMPROVEMENT" "$improvement")
  META_FILE="${META_DIR}/IMPROVE-${meta_id}-PROPOSED.md"
  TODAY=$(date +%Y-%m-%d)

  echo "üîÑ Cr√©ation de la proposition d'am√©lioration IMPROVE-${meta_id}"
  echo "üéØ Am√©lioration: $improvement"

  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te selon protocole META-IMPROVEMENT..."
      generate_meta_from_protocol "$META_FILE" "$meta_id" "$improvement" "$TODAY" "full"
      ;;
    "skeleton")
      echo "üìù Structure protocole √† compl√©ter..."
      generate_meta_from_protocol "$META_FILE" "$meta_id" "$improvement" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "üîß Structure minimale selon protocole..."
      generate_meta_from_protocol "$META_FILE" "$meta_id" "$improvement" "$TODAY" "minimal"
      ;;
  esac

  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "META" "Meta-improvement: $improvement" "IMPROVE-${meta_id}-PROPOSED.md"
  fi

  echo ""
  echo "‚úÖ IMPROVE-${meta_id}-PROPOSED.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $META_FILE"
  echo ""
  echo "üîÑ Prochaines √©tapes (meta-improvement):"
  echo "  1. Analyser la friction observ√©e en d√©tail"
  echo "  2. √âvaluer l'impact sur les autres protocoles"
  echo "  3. Proposer une solution claire et mesurable"
  echo "  4. Soumettre pour validation Human_Developer"
  echo "  5. Impl√©menter les modifications de la charte"
  echo ""
  echo "üìà RAPPEL: √âvolution continue de la charte !"
}

# Fonction de g√©n√©ration OPTIM - Parser dynamique du protocole OPTIMISATION
generate_debug_from_protocol() {
  local file="$1"
  local debug_id="$2"
  local title="$3"
  local date="$4"
  local assistance_level="$5"
  
  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="id=${debug_id},title=${title},date=${date},status=INVESTIGATING"
  
  # G√©n√©ration dynamique depuis le protocole
  parse_and_generate_artefact "04-DEBOGAGE" "DEBUG" "$assistance_level" "$file" "$context_vars"
  
  # Si le parser g√©n√©rique √©choue, afficher une erreur explicite
  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration DEBUG depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole DEBOGAGE" >&2
    return 1
  fi
}

# ===== FONCTION DEBUG STATIC_FALLBACK SUPPRIM√âE =====
# La fonction generate_debug_static_fallback a √©t√© supprim√©e car remplac√©e
# par le parser g√©n√©rique dynamique.

generate_review_from_protocol() {
  local file="$1"
  local review_id="$2"
  local target="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="review_id:${review_id},target:${target},date:${date},status:PENDING"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "07-REVUE-DE-CODE" "REVIEW" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration REVIEW depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole REVUE-DE-CODE" >&2
    return 1
  fi
}

generate_refactor_from_protocol() {
  local file="$1"
  local refactor_id="$2"
  local description="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="refactor_id:${refactor_id},description:${description},date:${date},status:ANALYSIS"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "05-REFACTORING" "REFACTOR" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration REFACTOR depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole REFACTORING" >&2
    return 1
  fi
}

generate_hotfix_from_protocol() {
  local file="$1"
  local hotfix_id="$2"
  local issue="$3"
  local date="$4"
  local time="$5"
  local assistance_level="$6"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="hotfix_id:${hotfix_id},issue:${issue},date:${date},time:${time},status:INVESTIGATING"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "10-HOTFIX" "HOTFIX" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration HOTFIX depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole HOTFIX" >&2
    return 1
  fi
}

generate_optim_from_protocol() {
  local file="$1"
  local optim_id="$2"
  local objective="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="optim_id:${optim_id},objective:${objective},date:${date},status:BENCHMARKING"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "06-OPTIMISATION" "OPTIM" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration OPTIM depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole OPTIMISATION" >&2
    return 1
  fi
}

generate_security_from_protocol() {
  local file="$1"
  local audit_id="$2"
  local scope="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="audit_id:${audit_id},scope:${scope},date:${date},status:SCANNING"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "13-SECURITE-AUDIT" "AUDIT" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration AUDIT depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole SECURITE-AUDIT" >&2
    return 1
  fi
}

generate_experiment_from_protocol() {
  local file="$1"
  local experiment_id="$2"
  local hypothesis="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="experiment_id:${experiment_id},hypothesis:${hypothesis},date:${date},status:PLANNING"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "11-EXPERIMENTATION" "EXPERIMENT" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration EXPERIMENT depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole EXPERIMENTATION" >&2
    return 1
  fi
}

generate_docs_from_protocol() {
  local file="$1"
  local docs_id="$2"
  local topic="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="docs_id:${docs_id},topic:${topic},date:${date},status:DRAFT"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "17-USER-DOCS" "USER-DOCS" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration USER-DOCS depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole USER-DOCS" >&2
    return 1
  fi
}

generate_analysis_from_protocol() {
  local file="$1"
  local analysis_id="$2"
  local subject="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="analysis_id:${analysis_id},subject:${subject},date:${date},status:ANALYSIS"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "12-ANALYSE-CONCURRENCE" "COMPETITION" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration COMPETITION depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole ANALYSE-CONCURRENCE" >&2
    return 1
  fi
}

generate_tracking_from_protocol() {
  local file="$1"
  local tracking_id="$2"
  local feature_id="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="tracking_id:${tracking_id},feature_id:${feature_id},date:${date},status:DRAFT"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "16-TRACKING-PLAN" "TRACKING-PLAN" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration TRACKING-PLAN depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole TRACKING-PLAN" >&2
    return 1
  fi
}

generate_onboarding_from_protocol() {
  local file="$1"
  local onboarding_id="$2"
  local user_role="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="onboarding_id:${onboarding_id},user_role:${user_role},date:${date}"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "14-ONBOARDING" "ONBOARDING" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration ONBOARDING depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole ONBOARDING" >&2
    return 1
  fi
}

generate_deprecation_from_protocol() {
  local file="$1"
  local deprecation_id="$2"
  local feature="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="deprecation_id:${deprecation_id},feature:${feature},date:${date},status:ANALYSIS"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "15-DEPRECATION" "DEPRECATION" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration DEPRECATION depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole DEPRECATION" >&2
    return 1
  fi
}

generate_fast_from_protocol() {
  local file="$1"
  local fast_id="$2"
  local task="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="fast_id:${fast_id},task:${task},date:${date},status:TODO"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "20-FAST-TRACK" "FAST-TRACK" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration FAST-TRACK depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole FAST-TRACK" >&2
    return 1
  fi
}

generate_meta_from_protocol() {
  local file="$1"
  local meta_id="$2"
  local improvement="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser g√©n√©rique
  local context_vars="meta_id:${meta_id},improvement:${improvement},date:${date},status:PROPOSED"

  # Appel du parser g√©n√©rique
  parse_and_generate_artefact "21-META-IMPROVEMENT" "META-IMPROVEMENT" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "‚ùå Erreur : √âchec de g√©n√©ration META-IMPROVEMENT depuis le protocole" >&2
    echo "   V√©rifiez l'int√©grit√© du protocole META-IMPROVEMENT" >&2
    return 1
  fi
}

# Commande: get_config - Affichage de configuration
command_get_config() {
  local key="$1"
  
  case "$key" in
    "--help"|"help"|"")
      echo "Usage: aklo get_config [<cl√©>] [--all]"
      echo ""
      echo "Affiche la configuration aklo effective."
      echo ""
      echo "Arguments:"
      echo "  cl√©          Cl√© de configuration sp√©cifique (optionnel)"
      echo ""
      echo "Options:"
      echo "  --all        Affiche toute la configuration"
      echo "  --local      Affiche uniquement la config locale (.aklo.conf projet)"
      echo "  --global     Affiche uniquement la config globale"
      echo "  --paths      Affiche les chemins des fichiers de configuration"
      echo ""
      echo "Exemples:"
      echo "  aklo get_config PROJECT_WORKDIR     # Affiche une cl√© sp√©cifique"
      echo "  aklo config AGENT_ASSISTANCE        # Alias court"
      echo "  aklo get_config --all               # Affiche toute la config"
      echo "  aklo get_config --paths             # Affiche les chemins des fichiers"
      echo ""
      echo "Cl√©s principales:"
      echo "  PROJECT_WORKDIR, AGENT_ASSISTANCE, AUTO_JOURNAL"
      echo "  MAIN_BRANCH, PBI_DIR, TASKS_DIR, ARCH_DIR"
      echo "  VALIDATE_LINTER, TEST_COMMAND, BUILD_COMMAND"
      echo ""
      echo "üîß UTILE POUR: Debugging, scripts, validation de setup"
      exit 0
      ;;
    "--all")
      echo "üìã Configuration Aklo Effective"
      echo "================================"
      echo ""
      
      # D√©terminer quel fichier de config est utilis√©
      find_local_config() {
        local current_dir="$(pwd)"
        while [ "$current_dir" != "/" ]; do
          if [ -f "$current_dir/.aklo.conf" ]; then
            echo "$current_dir/.aklo.conf"
            return 0
          fi
          current_dir="$(dirname "$current_dir")"
        done
        return 1
      }
      
      local config_file=$(find_local_config)
      if [ -z "$config_file" ]; then
        config_file="$(dirname "$(realpath "$0")")/../config/.aklo.conf"
      fi
      echo "üìÅ Fichier de configuration utilis√©: $config_file"
      echo ""
      
      if [ -f "$config_file" ]; then
        echo "üìù Contenu de la configuration:"
        echo "------------------------------"
        # TASK-7-1: Utilisation du cache regex pour les lignes de configuration
        local config_pattern="^[A-Z_]+=.*"
        if command -v use_regex_pattern >/dev/null 2>&1; then
          config_pattern=$(use_regex_pattern "CONFIG_KEY_VALUE" "^[A-Z_]+=.*")
        fi
        cat "$config_file" | grep -E "$config_pattern" | sort
      else
        echo "‚ùå Fichier de configuration introuvable"
      fi
      ;;
    "--local")
      find_local_config() {
        local current_dir="$(pwd)"
        while [ "$current_dir" != "/" ]; do
          if [ -f "$current_dir/.aklo.conf" ]; then
            echo "$current_dir/.aklo.conf"
            return 0
          fi
          current_dir="$(dirname "$current_dir")"
        done
        return 1
      }
      
      local local_config=$(find_local_config)
      if [ -n "$local_config" ]; then
        echo "üìÅ Configuration locale: $local_config"
        # TASK-7-1: Utilisation du cache regex pour les lignes de configuration
        local config_pattern="^[A-Z_]+=.*"
        if command -v use_regex_pattern >/dev/null 2>&1; then
          config_pattern=$(use_regex_pattern "CONFIG_KEY_VALUE" "^[A-Z_]+=.*")
        fi
        cat "$local_config" | grep -E "$config_pattern" | sort
      else
        echo "‚ùå Aucune configuration locale trouv√©e"
      fi
      ;;
    "--global")
      local global_config="$(dirname "$(realpath "$0")")/../config/.aklo.conf"
      echo "üìÅ Configuration globale: $global_config"
      if [ -f "$global_config" ]; then
        # TASK-7-1: Utilisation du cache regex pour les lignes de configuration  
        local config_pattern="^[A-Z_]+=.*"
        if command -v use_regex_pattern >/dev/null 2>&1; then
          config_pattern=$(use_regex_pattern "CONFIG_KEY_VALUE" "^[A-Z_]+=.*")
        fi
        cat "$global_config" | grep -E "$config_pattern" | sort
      else
        echo "‚ùå Configuration globale introuvable"
      fi
      ;;
    "--paths")
      echo "üìÅ Chemins des fichiers de configuration:"
      echo "========================================="
      
      find_local_config() {
        local current_dir="$(pwd)"
        while [ "$current_dir" != "/" ]; do
          if [ -f "$current_dir/.aklo.conf" ]; then
            echo "$current_dir/.aklo.conf"
            return 0
          fi
          current_dir="$(dirname "$current_dir")"
        done
        return 1
      }
      
      local local_config=$(find_local_config)
      local global_config="$(dirname "$(realpath "$0")")/../config/.aklo.conf"
      
      echo "üè† Configuration locale:"
      if [ -n "$local_config" ]; then
        echo "   ‚úÖ $local_config"
      else
        echo "   ‚ùå Aucune (recherch√© dans $(pwd) et parents)"
      fi
      
      echo "üåç Configuration globale:"
      if [ -f "$global_config" ]; then
        echo "   ‚úÖ $global_config"
      else
        echo "   ‚ùå $global_config (introuvable)"
      fi
      
      echo ""
      echo "üîç Fichier utilis√© actuellement:"
      if [ -n "$local_config" ]; then
        echo "   üìã $local_config (locale prioritaire)"
      elif [ -f "$global_config" ]; then
        echo "   üìã $global_config (globale par d√©faut)"
      else
        echo "   ‚ùå Aucun fichier de configuration valide"
      fi
      ;;
    *)
      # Affichage d'une cl√© sp√©cifique
      if [ -n "$key" ]; then
        local value=$(get_config "$key" 2>/dev/null)
        if [ -n "$value" ]; then
          echo "$key=$value"
        else
          echo "‚ùå Cl√© '$key' non trouv√©e ou vide"
          echo "üí° Utilisez 'aklo get_config --all' pour voir toutes les cl√©s disponibles"
          exit 1
        fi
      else
        echo "‚ùå Cl√© requise. Utilisez 'aklo get_config --help' pour l'aide."
        exit 1
      fi
      ;;
  esac
}

#==============================================================================
# SECTION 5 : DISPATCH DES COMMANDES
#==============================================================================

# Fonction d'aide
show_help() {
  echo "ü§ñ Aklo Protocol - Interface Unifi√©e"
  echo ""
  echo "USAGE:"
  echo "  aklo <command> [options]"
  echo ""
  echo "üîß COMMANDES SYST√àME:"
  echo "  status [--brief|--detailed|--json]  Tableau de bord du projet"
  echo "  get_config [<cl√©>] [--all]          Affichage de configuration"
  echo "  config <cl√©>                        Alias pour get_config"
  echo "  validate [path]                     Validation projet/artefacts"
  echo "  mcp setup|restart|watch             Gestion serveurs MCP"
  echo "  cache status|clear|benchmark        Gestion cache intelligent"
  echo "  config tune|profile|diagnose        Configuration performance"
  echo "  monitor dashboard|memory|perf       Monitoring et m√©triques"
  echo "  template list|create|apply          Gestion des templates"
  echo "  install-ux                          Installation am√©liorations UX"
  echo ""
  echo "üöÄ COMMANDES D√âVELOPPEMENT:"
  echo "  propose-pbi \"<titre>\" [--template]  Cr√©ation d'un Product Backlog Item"
  echo "  pbi \"<titre>\"                       Alias pour propose-pbi"
  echo "  plan <PBI_ID> [--no-agent]          Planification avec commit atomique"
  echo "  arch <PBI_ID> [--review]            Conception d'architecture logicielle"
  echo "  dev <TASK_ID> [--no-journal]        D√©veloppement TDD d'une Task"
  echo "  debug \"<titre>\" [--no-agent]        Diagnostic et correction de bugs"
  echo "  review <TASK_ID|COMMIT> [--checklist] Revue de code assist√©e"
  echo "  refactor \"<description>\" [--safe]   Refactoring s√©curis√© de code"
  echo "  hotfix \"<bug critique>\" [--emergency] Correction d'urgence production"
  echo "  optimize \"<objectif>\" [--profile]    Optimisation de performance"
  echo "  security [<p√©rim√®tre>] [--scan-only] Audit de s√©curit√©"
  echo "  release <type> [--dry-run]          Release (major|minor|patch)"
  echo ""
  echo "üîß COMMANDES QUALIT√â:"
  echo "  diagnose [\"<erreur>\"] [--interactive] Diagnostic d'environnement"
  echo "  experiment \"<hypoth√®se>\" [--ab-test] Exp√©rimentation A/B"
  echo "  docs \"<sujet>\" [--guide]            Documentation utilisateur"
  echo ""
  echo "üîç COMMANDES ANALYSE:"
  echo "  analyze \"<sujet>\" [--features]       Analyse de la concurrence"
  echo "  track <PBI_ID> [--plan]               Plan de tracking"
  echo "  onboard [<role>] [--role]             Onboarding de projet"
  echo "  deprecate \"<feature>\" [--timeline]   D√©pr√©ciation de fonctionnalit√©"
  echo "  kb <action> [args]                    Knowledge base (search/add)"
  echo "  fast \"<t√¢che>\" [--skip-validation]   Proc√©dure acc√©l√©r√©e"
  echo "  meta \"<am√©lioration>\" [--analyze]    Am√©lioration de la charte"
  echo "  scratch \"<sujet>\" [--template]       Brainstorming et scratchpad"
  echo ""
  echo "üìö AIDE ET INFORMATION:"
  echo "  help                                Affiche cette aide"
  echo "  <command> --help                    Aide sp√©cifique √† une commande"
  echo ""
  echo "üéØ NIVEAUX D'ASSISTANCE:"
  echo "  full      - G√©n√©ration compl√®te par l'IA (d√©faut)"
  echo "  skeleton  - Structure vide √† compl√©ter (--no-agent)"
  echo "  minimal   - IDs uniquement (via .aklo.conf uniquement)"
  echo ""
  echo "‚öôÔ∏è CONFIGURATION:"
  echo "  .aklo.conf              Configuration locale du projet"
  echo "    agent_assistance=full|skeleton|minimal"
  echo "    auto_journal=true|false"
  echo ""
  echo "üìñ EXEMPLES:"
  echo "  aklo status             # Tableau de bord complet"
  echo "  aklo mcp restart        # Red√©marrer les serveurs MCP"
  echo "  aklo cache_stats        # Statistiques du cache regex (TASK-7-1)"
  echo "  aklo plan 42            # Planifier le PBI 42"
  echo "  aklo dev 1-2            # D√©velopper la Task 1-2 en TDD"
  echo "  aklo validate           # Valider le projet"
  echo ""
  echo "üí° Astuce: Utilisez 'aklo <command> --help' pour l'aide d√©taill√©e."
}

# SECTION 4 : ROUTEUR DE COMMANDES PRINCIPAL
#==============================================================================

# Parsing des arguments de validation/backup en premier
parse_validation_args "$@"

case "${1:-help}" in

  init)
    command_init "$@"
    ;;

  propose-pbi)
    shift
    command_propose_pbi "$@"
    ;;

  plan)
    shift
    command_plan "$@"
    ;;

  release)
    shift
    command_release "$@"
    ;;

  status)
    shift
    command_status "$@"
    ;;

  mcp)
    shift
    command_mcp "$@"
    ;;

  validate)
    shift
    command_validate "$@"
    ;;

  cache)
    shift
    command_cache "$@"
    ;;

  config)
    shift
    command_config "$@"
    ;;

  monitor)
    shift
    command_monitor "$@"
    ;;

  template)
    shift
    command_template "$@"
    ;;

  install-ux)
    shift
    command_install_ux "$@"
    ;;

  arch)
    shift
    command_arch "$@"
    ;;

  dev)
    shift
    command_dev "$@"
    ;;

  debug)
    shift
    command_debug "$@"
    ;;

  review)
    shift
    command_review "$@"
    ;;

  refactor)
    shift
    command_refactor "$@"
    ;;

  hotfix)
    shift
    command_hotfix "$@"
    ;;

  optimize)
    shift
    command_optimize "$@"
    ;;

  security)
    shift
    command_security "$@"
    ;;

  diagnose)
    shift
    command_diagnose "$@"
    ;;

  experiment)
    shift
    command_experiment "$@"
    ;;

  docs)
    shift
    command_docs "$@"
    ;;

  analyze)
    shift
    command_analyze "$@"
    ;;

  track)
    shift
    command_track "$@"
    ;;

  onboard)
    shift
    command_onboard "$@"
    ;;

  deprecate)
    shift
    command_deprecate "$@"
    ;;

  kb)
    shift
    command_kb "$@"
    ;;

  fast)
    shift
    command_fast "$@"
    ;;

  meta)
    shift
    command_meta "$@"
    ;;

  scratch)
    shift
    command_scratch "$@"
    ;;

  get_config|config)
    shift
    command_get_config "$@"
    ;;

  cache_stats|regex_stats)
    # TASK-7-1: Affichage des statistiques du cache regex
    echo "üöÄ Aklo - Statistiques du Cache Regex"
    echo "======================================="
    echo ""
    show_regex_cache_stats
    ;;

  help|"--help"|"-h")
    show_help
    ;;

  *)
    echo "Commande inconnue: $1"
    echo "Utilisez 'aklo help' pour voir les commandes disponibles."
    exit 1
    ;;
esac