#!/usr/bin/env bash
#==============================================================================
# The Aklo Protocol - Charte Automation Tool v3.4 (Architecture Portable)
#==============================================================================

# --- 1. Configuration des chemins et de l'environnement (ROBUSTE) ---
# RÃ©sout le chemin rÃ©el du script pour garantir la robustesse, mÃªme via des liens symboliques.
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # RÃ©soudre les liens symboliques de maniÃ¨re rÃ©cursive
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
done
AKLO_BIN_DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"

export AKLO_PROJECT_ROOT
AKLO_PROJECT_ROOT=$(cd "$AKLO_BIN_DIR/../.." && pwd)
export AKLO_MODULES_DIR="${AKLO_PROJECT_ROOT}/aklo/modules"

# --- 2. Gestion de l'option universelle --dry-run ---
export AKLO_DRY_RUN=false
PROCESSED_ARGS=()
for arg in "$@"; do
  if [ "$arg" = "--dry-run" ]; then
    AKLO_DRY_RUN=true
  else
    PROCESSED_ARGS+=("$arg")
  fi
done
set -- "${PROCESSED_ARGS[@]}"

# --- 3. Chargement intelligent et fail-safe ---
source "${AKLO_MODULES_DIR}/core/command_classifier.sh"
command_name="$1"
if [ -z "$command_name" ]; then
    source "${AKLO_MODULES_DIR}/ux/help-system.sh"
    show_help
    exit 0
fi
profile=$(classify_command "$command_name")
required_modules_str=$(get_required_modules "$profile")
if [ -n "$required_modules_str" ]; then
    for module_rel_path in $required_modules_str; do
        module_full_path="${AKLO_MODULES_DIR}/${module_rel_path}"
        if [ ! -f "$module_full_path" ]; then
            echo "Erreur critique : DÃ©pendance interne introuvable : ${module_rel_path}" >&2
            echo "(Chemin de base des modules : ${AKLO_MODULES_DIR})" >&2
            exit 1
        fi
        source "$module_full_path"
    done
else
    echo "Erreur: Commande '$command_name' inconnue." >&2
    exit 1
fi

# --- 4. ExÃ©cution de la commande ---
main() {
    if [ "$AKLO_DRY_RUN" = true ]; then
      echo "ðŸ’§ Mode DRY-RUN activÃ©. Aucune modification ne sera effectuÃ©e."
      echo "------------------------------------------------------------------"
    fi
    local cmd_func="cmd_$1"
    shift
    if declare -f "$cmd_func" >/dev/null; then
        "$cmd_func" "$@"
    else
        echo "Erreur interne : la fonction '$cmd_func' n'a pas Ã©tÃ© chargÃ©e. VÃ©rifiez le classifieur." >&2
        exit 1
    fi
}

main "$@"