#!/bin/sh
#==============================================================================
# The Aklo Protocol - Interface Unifi√©e
#
# Auteur: Human_Developer & AI_Agent
# Version: Interface compl√®te avec commits atomiques par protocole
#
# Impl√©mente l'interface unifi√©e aklo couvrant tous les protocoles
# d√©finie dans le META-IMPROVEMENT command-coverage-20250102.
#==============================================================================

# Configuration de base du Shell
set -e

#==============================================================================
# SECTION 1 : FONCTIONS UTILITAIRES H√âRIT√âES
#==============================================================================

# R√©utilisation des fonctions existantes
get_next_id() {
  SEARCH_PATH="$1"
  PREFIX="$2"
  LAST_ID=$(ls "${SEARCH_PATH}/${PREFIX}"*-*.md 2>/dev/null | sed -n "s/.*${PREFIX}\([0-9]*\)-.*/\1/p" | sort -n | tail -1 || echo 0)
  NEXT_ID=$((LAST_ID + 1))
  echo "$NEXT_ID"
}

get_config() {
  KEY="$1"
  GLOBAL_CONFIG_FILE="$(dirname "$0")/../config/.aklo.conf"
  
  find_local_config() {
    local current_dir="$(pwd)"
    while [ "$current_dir" != "/" ]; do
      if [ -f "$current_dir/.aklo.conf" ]; then
        echo "$current_dir/.aklo.conf"
        return 0
      fi
      current_dir="$(dirname "$current_dir")"
    done
    return 1
  }
  
  CONFIG_FILE=$(find_local_config) || CONFIG_FILE="$GLOBAL_CONFIG_FILE"
  if [ ! -f "$CONFIG_FILE" ]; then
    echo "Erreur : Fichier de configuration introuvable." >&2
    exit 1
  fi
  
  sed -n "/^${KEY}=/s/^[^=]*=//p" "$CONFIG_FILE" | tr -d '"'
}

#==============================================================================
# SECTION 2 : FONCTIONS JOURNAL ATOMIQUE
#==============================================================================

# Fonction: update_journal
# R√¥le: Met √† jour le journal quotidien avec une entr√©e de protocole
# Usage: update_journal "PROTOCOLE" "Action" "Description" "Artefacts"
update_journal() {
  PROTOCOL="$1"
  ACTION="$2"
  DESCRIPTION="$3"
  ARTEFACTS="$4"
  
  JOURNAL_DIR="./docs/backlog/15-journal"
  TODAY=$(date +%Y-%m-%d)
  JOURNAL_FILE="${JOURNAL_DIR}/JOURNAL-${TODAY}.md"
  TIMESTAMP=$(date +%H:%M)
  
  # Cr√©er le r√©pertoire journal si n√©cessaire
  mkdir -p "$JOURNAL_DIR"
  
  # Cr√©er le fichier journal du jour si n√©cessaire
  if [ ! -f "$JOURNAL_FILE" ]; then
    cat > "$JOURNAL_FILE" << EOF
# JOURNAL DE TRAVAIL : ${TODAY}
---
**Responsable:** Human_Developer
**Objectif(s) de la journ√©e:** [√Ä d√©finir]
---

## Entr√©es Chronologiques

### ${TIMESTAMP} - D√©but de session

- **Action :** Ouverture du journal quotidien
- **Contexte :** Premi√®re utilisation du syst√®me de journal int√©gr√©

EOF
  fi
  
  # Ajouter l'entr√©e de protocole
  cat >> "$JOURNAL_FILE" << EOF
### ${TIMESTAMP} - [${PROTOCOL}] ${ACTION}

- **Action :** ${DESCRIPTION}
- **Artefacts :** ${ARTEFACTS}
- **Timestamp :** ${TODAY} ${TIMESTAMP}

EOF
}

#==============================================================================
# SECTION 3 : COMMANDES AVEC COMMITS ATOMIQUES
#==============================================================================

# Commande: plan (Version 2.0 - Commit Atomique)
# Impl√©mente le protocole PLANIFICATION avec commit atomique unique
command_plan() {
  if [ -z "$1" ]; then
    echo "Erreur : L'ID du PBI est requis (ex: 42)." >&2
    exit 1
  fi
  PBI_ID="$1"
  
  # D√©tection du niveau d'assistance
  AGENT_ASSISTANCE="full"
  AUTO_JOURNAL="true"
  
  # Parsing des arguments
  shift
  while [ $# -gt 0 ]; do
    case "$1" in
      --no-agent)
        AGENT_ASSISTANCE="skeleton"
        ;;
      --no-journal)
        AUTO_JOURNAL="false"
        ;;
      *)
        echo "Argument inconnu: $1" >&2
        exit 1
        ;;
    esac
    shift
  done
  
  # Override depuis la configuration si pr√©sente
  CONFIG_ASSISTANCE=$(get_config "agent_assistance" 2>/dev/null || echo "")
  CONFIG_JOURNAL=$(get_config "auto_journal" 2>/dev/null || echo "")
  
  if [ -n "$CONFIG_ASSISTANCE" ]; then
    AGENT_ASSISTANCE="$CONFIG_ASSISTANCE"
  fi
  if [ -n "$CONFIG_JOURNAL" ]; then
    AUTO_JOURNAL="$CONFIG_JOURNAL"
  fi
  
  echo "--- PLANIFICATION v2.0 (Commit Atomique) ---"
  echo "‚Ä∫ PBI: ${PBI_ID}"
  echo "‚Ä∫ Assistance: ${AGENT_ASSISTANCE}"
  echo "‚Ä∫ Journal automatique: ${AUTO_JOURNAL}"
  echo ""
  
  # Validation du PBI
  PBI_FILE=$(ls ./docs/backlog/00-pbi/PBI-${PBI_ID}-*.md 2>/dev/null | head -1)
  if [ ! -f "$PBI_FILE" ]; then
    echo "Erreur : PBI ${PBI_ID} introuvable." >&2
    exit 1
  fi
  
  # Pr√©paration des variables pour le commit atomique
  CREATED_TASKS=""
  MODIFIED_FILES=""
  TASK_COUNT=0
  
  echo "--- Phase 1: Cr√©ation des Tasks ---"
  
  case "$AGENT_ASSISTANCE" in
    "full")
      echo "Mode FULL: L'IA va g√©n√©rer le contenu complet des tasks."
      echo "TODO: Int√©gration avec le serveur MCP pour g√©n√©ration automatique"
      ;;
    "skeleton")
      echo "Mode SKELETON: Cr√©ation de la structure des tasks √† compl√©ter."
      ;;
    "minimal")
      echo "Mode MINIMAL: Cr√©ation des fichiers avec IDs uniquement."
      ;;
  esac
  
  # Boucle de cr√©ation interactive (simplifi√©e pour la d√©mo)
  while true; do
    printf "  ‚Ä∫ Titre de la nouvelle t√¢che (vide pour terminer): "
    read -r TASK_TITLE
    
    if [ -z "$TASK_TITLE" ]; then
      break
    fi
    
    TASK_COUNT=$((TASK_COUNT + 1))
    TASK_ID=$(printf "%02d" $TASK_COUNT)
    TASK_FILENAME="TASK-${PBI_ID}-${TASK_ID}-TODO.md"
    TASK_PATH="./docs/backlog/01-tasks/${TASK_FILENAME}"
    
    # Cr√©ation du fichier Task selon le niveau d'assistance
    mkdir -p "./docs/backlog/01-tasks"
    
    case "$AGENT_ASSISTANCE" in
      "full")
        # Contenu complet g√©n√©r√© (ici simplifi√©)
        cat > "$TASK_PATH" << EOF
# TASK-${PBI_ID}-${TASK_ID}: ${TASK_TITLE}
---
**PBI Parent:** PBI-${PBI_ID}
**Responsable:** [√Ä assigner]
**Statut:** TODO
**Revue Architecturale Requise:** Non
---

## Description

${TASK_TITLE}

## Crit√®res d'Acceptation

- [ ] Crit√®re 1: [√Ä d√©finir]
- [ ] Crit√®re 2: [√Ä d√©finir]

## Definition of Done

- [ ] Code impl√©ment√© et test√©
- [ ] Tests unitaires passants
- [ ] Documentation mise √† jour
- [ ] Revue de code effectu√©e
EOF
        ;;
      "skeleton")
        # Structure vide √† compl√©ter
        cat > "$TASK_PATH" << EOF
# TASK-${PBI_ID}-${TASK_ID}: ${TASK_TITLE}
---
**PBI Parent:** PBI-${PBI_ID}
**Responsable:** [√Ä assigner]
**Statut:** TODO
**Revue Architecturale Requise:** [Oui/Non]
---

## Description

[√Ä compl√©ter]

## Crit√®res d'Acceptation

- [ ] [√Ä d√©finir]

## Definition of Done

- [ ] [√Ä compl√©ter]
EOF
        ;;
      "minimal")
        # Fichier minimal avec ID uniquement
        cat > "$TASK_PATH" << EOF
# TASK-${PBI_ID}-${TASK_ID}: ${TASK_TITLE}
---
**PBI Parent:** PBI-${PBI_ID}
**Statut:** TODO
---
EOF
        ;;
    esac
    
    CREATED_TASKS="${CREATED_TASKS}${TASK_FILENAME} "
    MODIFIED_FILES="${MODIFIED_FILES}${TASK_PATH} "
    echo "  ‚úì Task cr√©√©e: ${TASK_FILENAME}"
  done
  
  if [ $TASK_COUNT -eq 0 ]; then
    echo "Aucune task cr√©√©e. Abandon."
    exit 0
  fi
  
  echo ""
  echo "--- Phase 2: Mise √† jour du PBI ---"
  
  # Mise √† jour du PBI avec la liste des tasks
  cp "$PBI_FILE" "${PBI_FILE}.backup"
  
  # Ajout de la section Tasks si elle n'existe pas
  if ! grep -q "## Tasks Associ√©es" "$PBI_FILE"; then
    cat >> "$PBI_FILE" << EOF

## Tasks Associ√©es

EOF
  fi
  
  # Ajout des tasks cr√©√©es
  for task_file in $CREATED_TASKS; do
    task_id=$(echo "$task_file" | sed 's/TASK-\([^-]*-[^-]*\)-.*/\1/')
    echo "- TASK-${task_id}: [Cr√©√©e]" >> "$PBI_FILE"
  done
  
  MODIFIED_FILES="${MODIFIED_FILES}${PBI_FILE} "
  echo "  ‚úì PBI mis √† jour avec ${TASK_COUNT} tasks"
  
  # Phase 3: Mise √† jour du journal
  if [ "$AUTO_JOURNAL" = "true" ]; then
    echo ""
    echo "--- Phase 3: Mise √† jour du journal ---"
    
    JOURNAL_DESCRIPTION="D√©composition PBI-${PBI_ID} en ${TASK_COUNT} tasks techniques (mode: ${AGENT_ASSISTANCE})"
    JOURNAL_ARTEFACTS="PBI-${PBI_ID} mis √† jour, ${TASK_COUNT} tasks cr√©√©es: ${CREATED_TASKS}"
    
    update_journal "PLANIFICATION" "D√©composition PBI" "$JOURNAL_DESCRIPTION" "$JOURNAL_ARTEFACTS"
    
    JOURNAL_FILE="./docs/backlog/15-journal/JOURNAL-$(date +%Y-%m-%d).md"
    MODIFIED_FILES="${MODIFIED_FILES}${JOURNAL_FILE} "
    echo "  ‚úì Journal mis √† jour"
  fi
  
  # Phase 4: Validation et commit atomique
  echo ""
  echo "--- Phase 4: Pr√©paration du commit atomique ---"
  echo "Fichiers √† committer:"
  for file in $MODIFIED_FILES; do
    echo "  - $file"
  done
  echo ""
  
  printf "Voulez-vous cr√©er le commit atomique de planification ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Commit annul√©. Fichiers conserv√©s pour r√©vision manuelle."
    exit 0
  fi
  
  # Cr√©ation du commit atomique
  git add $MODIFIED_FILES
  
  COMMIT_MSG="feat(planning): D√©composition PBI-${PBI_ID} en ${TASK_COUNT} tasks

- Cr√©ation de ${TASK_COUNT} tasks techniques (mode: ${AGENT_ASSISTANCE})
- PBI-${PBI_ID} mis √† jour avec la liste des tasks associ√©es"

  if [ "$AUTO_JOURNAL" = "true" ]; then
    COMMIT_MSG="${COMMIT_MSG}
- Journal mis √† jour avec le processus de planification"
  fi

  COMMIT_MSG="${COMMIT_MSG}

Tasks cr√©√©es:"
  for task_file in $CREATED_TASKS; do
    task_title=$(head -1 "./docs/backlog/01-tasks/$task_file" | sed 's/# //')
    COMMIT_MSG="${COMMIT_MSG}
- $task_title"
  done

  COMMIT_MSG="${COMMIT_MSG}

Prochaine √©tape: DEVELOPPEMENT"
  
  git commit -m "$COMMIT_MSG"
  
  echo ""
  echo "üéâ Planification termin√©e avec commit atomique !"
  echo "   ${TASK_COUNT} tasks cr√©√©es pour PBI-${PBI_ID}"
  echo "   Commit: $(git rev-parse --short HEAD)"
}

#==============================================================================
# SECTION 4 : COMMANDE RELEASE V2.0
#==============================================================================

# Commande: release (Version 2.0 - Workflow S√©quentiel + Commit Atomique)
command_release() {
  if [ -z "$1" ]; then
    echo "Erreur : Le type de release est requis (major, minor, patch)." >&2
    exit 1
  fi
  BUMP_TYPE="$1"
  
  echo "--- RELEASE v2.0 (Workflow S√©quentiel + Commit Atomique) ---"
  
  # Phase 1: Pr√©paration locale (sans commit)
  echo "--- Phase 1: Pr√©paration locale ---"
  
  CURRENT_VERSION=$(grep '"version"' package.json | sed 's/.*"version": "\([^"]*\)".*/\1/' || echo "0.0.0")
  
  case "$BUMP_TYPE" in
    "major")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print ($1+1)".0.0"}')
      ;;
    "minor")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print $1"."($2+1)".0"}')
      ;;
    "patch")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print $1"."$2"."($3+1)}')
      ;;
    *)
      echo "Erreur : Type de release invalide. Utilisez major, minor ou patch." >&2
      exit 1
      ;;
  esac
  
  echo "  ‚Ä∫ Version actuelle: ${CURRENT_VERSION}"
  echo "  ‚Ä∫ Nouvelle version: ${NEW_VERSION}"
  
  # Pr√©paration des fichiers (sans commit)
  RELEASE_DIR="./docs/backlog/07-releases"
  mkdir -p "$RELEASE_DIR"
  RELEASE_FILE="${RELEASE_DIR}/RELEASE-${NEW_VERSION}-AWAITING_DEPLOYMENT.md"
  
  # Cr√©ation du rapport de release
  cat > "$RELEASE_FILE" << EOF
# RAPPORT DE RELEASE : v${NEW_VERSION}
---
**Version:** ${NEW_VERSION}
**Type:** ${BUMP_TYPE}
**Date:** $(date +%Y-%m-%d)
**Statut:** AWAITING_DEPLOYMENT
---

## R√©sum√©

Release ${BUMP_TYPE} v${NEW_VERSION} pr√©par√©e et valid√©e.

## Fonctionnalit√©s Incluses

[√Ä compl√©ter depuis les commits depuis la derni√®re release]

## Tests de Validation

- [ ] Suite de tests unitaires
- [ ] Tests d'int√©gration  
- [ ] Build de production
- [ ] Tests de r√©gression

## D√©ploiement

Pr√™t pour d√©ploiement en production.
EOF
  
  # Mise √† jour du CHANGELOG (simplifi√©)
  if [ ! -f "CHANGELOG.md" ]; then
    echo "# CHANGELOG" > CHANGELOG.md
    echo "" >> CHANGELOG.md
  fi
  
  # Ajout de la nouvelle version au CHANGELOG
  sed -i.bak "2i\\
\\
## [${NEW_VERSION}] - $(date +%Y-%m-%d)\\
\\
### Added\\
- [√Ä compl√©ter]\\
\\
### Changed\\
- [√Ä compl√©ter]\\
\\
### Fixed\\
- [√Ä compl√©ter]\\
" CHANGELOG.md
  
  # Mise √† jour de la version dans package.json
  if [ -f "package.json" ]; then
    sed -i.bak "s/\"version\": \"${CURRENT_VERSION}\"/\"version\": \"${NEW_VERSION}\"/" package.json
  fi
  
  echo "  ‚úì Rapport de release cr√©√©"
  echo "  ‚úì CHANGELOG.md mis √† jour"
  echo "  ‚úì Version mise √† jour dans package.json"
  
  # Phase 2: Validation technique (sans commit)
  echo ""
  echo "--- Phase 2: Validation technique ---"
  echo "  ‚Ä∫ Lancement des tests..."
  
  # Simulation des tests (√† adapter selon le projet)
  if command -v npm >/dev/null 2>&1 && [ -f "package.json" ]; then
    echo "  ‚Ä∫ Tests npm..."
    # npm test || { echo "Erreur: Les tests ont √©chou√©"; exit 1; }
    echo "  ‚úì Tests npm pass√©s (simul√©)"
  fi
  
  echo "  ‚úì Validation technique r√©ussie"
  
  # Phase 3: Mise √† jour du journal
  echo ""
  echo "--- Phase 3: Mise √† jour du journal ---"
  
  JOURNAL_DESCRIPTION="Pr√©paration release v${NEW_VERSION} (type: ${BUMP_TYPE})"
  JOURNAL_ARTEFACTS="RELEASE-${NEW_VERSION}, CHANGELOG.md, package.json"
  
  update_journal "RELEASE" "Pr√©paration release" "$JOURNAL_DESCRIPTION" "$JOURNAL_ARTEFACTS"
  echo "  ‚úì Journal mis √† jour"
  
  # Phase 4: Validation humaine du diff complet
  echo ""
  echo "--- Phase 4: Validation du commit atomique ---"
  echo "Fichiers modifi√©s pour la release:"
  echo "  - ${RELEASE_FILE}"
  echo "  - CHANGELOG.md"
  echo "  - package.json"
  echo "  - ./docs/backlog/15-journal/JOURNAL-$(date +%Y-%m-%d).md"
  echo ""
  
  printf "Voulez-vous cr√©er le commit atomique de release ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Release annul√©e. Fichiers conserv√©s pour r√©vision manuelle."
    exit 0
  fi
  
  # Phase 5: Commit atomique final
  echo ""
  echo "--- Phase 5: Commit atomique et tagging ---"
  
  git add "$RELEASE_FILE" CHANGELOG.md package.json "./docs/backlog/15-journal/JOURNAL-$(date +%Y-%m-%d).md"
  
  COMMIT_MSG="release: Version ${NEW_VERSION}

Release ${BUMP_TYPE} v${NEW_VERSION} pr√©par√©e et valid√©e.

- Rapport RELEASE-${NEW_VERSION} finalis√©
- CHANGELOG.md mis √† jour avec nouvelles fonctionnalit√©s
- Version mise √† jour : ${CURRENT_VERSION} ‚Üí ${NEW_VERSION}
- Journal mis √† jour avec le processus de release
- Tous les tests passent, build de production valid√©

Type de release: ${BUMP_TYPE}"
  
  git commit -m "$COMMIT_MSG"
  
  # Cr√©ation du tag
  git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
  
  echo ""
  echo "üéâ Release v${NEW_VERSION} cr√©√©e avec succ√®s !"
  echo "   Commit: $(git rev-parse --short HEAD)"
  echo "   Tag: v${NEW_VERSION}"
  echo ""
  echo "Prochaines √©tapes:"
  echo "  1. git push origin main"
  echo "  2. git push origin v${NEW_VERSION}"
  echo "  3. D√©ploiement en production"
}

#==============================================================================
# SECTION 4 : COMMANDES SYST√àME (P1 - Priorit√© maximale)
#==============================================================================

# Commande: status - Tableau de bord complet du projet
command_status() {
  local mode="${1:-standard}"
  local script_dir="$(dirname "$0")"
  
  case "$mode" in
    "--help")
      echo "Usage: aklo status [--brief|--detailed|--json]"
      echo ""
      echo "Affiche le tableau de bord complet du projet aklo."
      echo ""
      echo "Options:"
      echo "  --brief, -b     Affichage condens√©"
      echo "  --detailed, -d  Affichage d√©taill√© avec m√©triques"
      echo "  --json          Sortie au format JSON"
      exit 0
      ;;
    *)
      # D√©l√©guer au script sp√©cialis√© pour tous les modes
      if [ -f "$script_dir/../ux-improvements/status-command.sh" ]; then
        . "$script_dir/../ux-improvements/status-command.sh"
        # Passer le mode ou "standard" si vide
        aklo_status "${mode:-standard}"
      else
        echo "Erreur : Script status-command.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: mcp - Gestion des serveurs MCP
command_mcp() {
  local action="$1"
  local script_dir="$(dirname "$0")"
  
  case "$action" in
    "setup")
      echo "üîß Configuration des serveurs MCP..."
      if [ -f "$script_dir/../mcp-servers/setup-mcp.sh" ]; then
        "$script_dir/../mcp-servers/setup-mcp.sh"
      else
        echo "Erreur : Script setup-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "restart")
      echo "üîÑ Red√©marrage des serveurs MCP..."
      if [ -f "$script_dir/../mcp-servers/restart-mcp.sh" ]; then
        "$script_dir/../mcp-servers/restart-mcp.sh"
      else
        echo "Erreur : Script restart-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "watch")
      echo "üëÅÔ∏è Surveillance des serveurs MCP..."
      if [ -f "$script_dir/../mcp-servers/watch-mcp.sh" ]; then
        "$script_dir/../mcp-servers/watch-mcp.sh"
      else
        echo "Erreur : Script watch-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo mcp <action>"
      echo ""
      echo "Gestion des serveurs MCP (Model Context Protocol)."
      echo ""
      echo "Actions:"
      echo "  setup     Configuration initiale des serveurs MCP"
      echo "  restart   Red√©marrage des serveurs apr√®s modification"
      echo "  watch     Surveillance en temps r√©el des serveurs"
      echo ""
      echo "Exemples:"
      echo "  aklo mcp setup      # Configuration initiale"
      echo "  aklo mcp restart    # Apr√®s modification du code MCP"
      echo "  aklo mcp watch      # Surveillance continue"
      exit 0
      ;;
    *)
      echo "Erreur : Action MCP inconnue '$action'." >&2
      echo "Utilisez 'aklo mcp help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: validate - Validation de projets et artefacts
command_validate() {
  local target="${1:-.}"
  local script_dir="$(dirname "$0")"
  
  case "$target" in
    "--help")
      echo "Usage: aklo validate [path]"
      echo ""
      echo "Valide la structure et la coh√©rence du projet aklo."
      echo ""
      echo "Arguments:"
      echo "  path    Chemin √† valider (d√©faut: r√©pertoire courant)"
      echo ""
      echo "Validations effectu√©es:"
      echo "  ‚Ä¢ Structure des r√©pertoires aklo"
      echo "  ‚Ä¢ Coh√©rence des artefacts (PBI, TASK, etc.)"
      echo "  ‚Ä¢ Respect des protocoles de la charte"
      echo "  ‚Ä¢ Configuration .aklo.conf"
      exit 0
      ;;
    *)
      echo "üîç Validation du projet aklo..."
      if [ -f "$script_dir/../ux-improvements/validation.sh" ]; then
        "$script_dir/../ux-improvements/validation.sh" "$target"
      else
        echo "Erreur : Script validation.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: template - Gestion des templates
command_template() {
  local action="$1"
  local script_dir="$(dirname "$0")"
  
  case "$action" in
    "list")
      echo "üìã Templates disponibles..."
      if [ -f "$script_dir/../ux-improvements/templates.sh" ]; then
        . "$script_dir/../ux-improvements/templates.sh"
        list_templates
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "create")
      shift
      echo "üÜï Cr√©ation d'un nouveau template..."
      if [ -f "$script_dir/../ux-improvements/templates.sh" ]; then
        . "$script_dir/../ux-improvements/templates.sh"
        create_template "$@"
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "apply")
      shift
      echo "üìù Application d'un template..."
      if [ -f "$script_dir/../ux-improvements/templates.sh" ]; then
        . "$script_dir/../ux-improvements/templates.sh"
        apply_template "$@"
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo template <action> [args...]"
      echo ""
      echo "Gestion des templates de projet aklo."
      echo ""
      echo "Actions:"
      echo "  list              Liste les templates disponibles"
      echo "  create <name>     Cr√©e un nouveau template"
      echo "  apply <name>      Applique un template au projet"
      echo ""
      echo "Exemples:"
      echo "  aklo template list"
      echo "  aklo template create mon-template"
      echo "  aklo template apply web-app"
      exit 0
      ;;
    *)
      echo "Erreur : Action template inconnue '$action'." >&2
      echo "Utilisez 'aklo template help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: install-ux - Installation des am√©liorations UX
command_install_ux() {
  local script_dir="$(dirname "$0")"
  
  case "${1:-}" in
    "--help")
      echo "Usage: aklo install-ux"
      echo ""
      echo "Installe les am√©liorations d'exp√©rience utilisateur aklo :"
      echo "  ‚Ä¢ Autocompl√©tion shell (bash/zsh)"
      echo "  ‚Ä¢ Aliases et raccourcis"
      echo "  ‚Ä¢ Configuration optimis√©e"
      echo "  ‚Ä¢ Int√©gration avec les √©diteurs"
      exit 0
      ;;
    *)
      echo "üé® Installation des am√©liorations UX..."
      if [ -f "$script_dir/../ux-improvements/install-ux.sh" ]; then
        "$script_dir/../ux-improvements/install-ux.sh"
      else
        echo "Erreur : Script install-ux.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: propose-pbi - Cr√©ation d'un Product Backlog Item
command_propose_pbi() {
  local title="$1"
  local template="${2:-default}"
  local agent_assistance=$(get_config "agent_assistance" || echo "full")
  local auto_journal=$(get_config "auto_journal" || echo "true")
  
  case "$title" in
    "--help"|"help"|"")
      echo "Usage: aklo propose-pbi \"<titre>\" [--template=<type>]"
      echo ""
      echo "Cr√©e un nouveau Product Backlog Item selon le protocole PRODUCT-OWNER."
      echo ""
      echo "Arguments:"
      echo "  titre       Titre descriptif du PBI (requis, entre guillemets)"
      echo ""
      echo "Options:"
      echo "  --template=<type>  Type de template (default|feature|bug|improvement)"
      echo "  --no-agent         Mode skeleton (structure vide √† compl√©ter)"
      echo "  --no-journal       Pas de mise √† jour automatique du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo propose-pbi \"Ajouter authentification OAuth\""
      echo "  aklo propose-pbi \"Corriger bug de validation\" --template=bug"
      echo "  aklo pbi \"Optimiser temps de chargement\" --no-agent"
      exit 0
      ;;
    --no-agent)
      agent_assistance="skeleton"
      title="$2"
      template="${3:-default}"
      ;;
    --no-journal)
      auto_journal="false"
      title="$2"
      template="${3:-default}"
      ;;
  esac
  
  if [ -z "$title" ]; then
    echo "Erreur : Le titre du PBI est requis." >&2
    echo "Usage: aklo propose-pbi \"<titre>\""
    echo "Utilisez 'aklo propose-pbi --help' pour plus d'informations."
    exit 1
  fi
  
  # G√©n√©ration de l'ID unique
  PBI_DIR="./docs/backlog/00-pbi"
  mkdir -p "$PBI_DIR"
  
  PBI_ID=$(get_next_id "$PBI_DIR" "PBI")
  PBI_FILE="${PBI_DIR}/PBI-${PBI_ID}-PROPOSED.md"
  TODAY=$(date +%Y-%m-%d)
  
  echo "üéØ Cr√©ation du PBI-${PBI_ID}: \"$title\""
  
  # G√©n√©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ü§ñ G√©n√©ration compl√®te par l'IA..."
      generate_pbi_full "$PBI_FILE" "$PBI_ID" "$title" "$TODAY"
      ;;
    "skeleton")
      echo "üìù G√©n√©ration de la structure √† compl√©ter..."
      generate_pbi_skeleton "$PBI_FILE" "$PBI_ID" "$title" "$TODAY"
      ;;
    "minimal")
      echo "üîß Cr√©ation minimale (ID et structure de base)..."
      generate_pbi_minimal "$PBI_FILE" "$PBI_ID" "$title" "$TODAY"
      ;;
  esac
  
  # Mise √† jour du journal si activ√©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "PRODUCT-OWNER" "Cr√©ation PBI" "Nouveau PBI-${PBI_ID}: $title" "PBI-${PBI_ID}-PROPOSED.md"
  fi
  
  echo ""
  echo "‚úÖ PBI-${PBI_ID}-PROPOSED.md cr√©√© avec succ√®s !"
  echo "üìç Fichier: $PBI_FILE"
  echo ""
  echo "Prochaines √©tapes:"
  echo "  1. R√©viser et compl√©ter le PBI"
  echo "  2. Valider avec l'√©quipe"
  echo "  3. aklo plan ${PBI_ID} (pour d√©composer en t√¢ches)"
}

# Fonctions de g√©n√©ration PBI
generate_pbi_full() {
  local file="$1"
  local id="$2"
  local title="$3"
  local date="$4"
  
  cat > "$file" << EOF
# PBI-${id} : ${title}

---
**Statut:** PROPOSED
**Date de cr√©ation:** ${date}
---

## 1. Description de la User Story

_En tant que [utilisateur], je veux [action], afin de [b√©n√©fice]._

## 2. Crit√®res d'Acceptation

- [ ] Crit√®re 1 : Condition binaire et testable.
- [ ] Crit√®re 2 : Autre condition binaire et testable.

## 3. Sp√©cifications Techniques Pr√©liminaires & Contraintes (Optionnel)

_Section pour l'architecte/lead dev._

## 4. Documents d'Architecture Associ√©s (Optionnel)

_Liens vers les documents d'architecture si n√©cessaire._

## 5. Tasks Associ√©es

_Cette section sera remplie par le protocole [PLANIFICATION]._

EOF
}

generate_pbi_skeleton() {
  local file="$1"
  local id="$2"
  local title="$3"
  local date="$4"
  
  cat > "$file" << EOF
# PBI-${id} : ${title}

---
**Statut:** PROPOSED
**Date de cr√©ation:** ${date}
---

## 1. Description de la User Story

_√Ä compl√©ter: En tant que [utilisateur], je veux [action], afin de [b√©n√©fice]._

## 2. Crit√®res d'Acceptation

- [ ] _√Ä d√©finir_

## 3. Sp√©cifications Techniques Pr√©liminaires & Contraintes (Optionnel)

_√Ä compl√©ter si n√©cessaire_

## 4. Documents d'Architecture Associ√©s (Optionnel)

_√Ä compl√©ter si n√©cessaire_

## 5. Tasks Associ√©es

_Cette section sera remplie par le protocole [PLANIFICATION]._

EOF
}

generate_pbi_minimal() {
  local file="$1"
  local id="$2"
  local title="$3"
  local date="$4"
  
  cat > "$file" << EOF
# PBI-${id} : ${title}

---
**Statut:** PROPOSED
**Date de cr√©ation:** ${date}
---

## 1. Description de la User Story



## 2. Crit√®res d'Acceptation



## 3. Sp√©cifications Techniques Pr√©liminaires & Contraintes (Optionnel)



## 4. Documents d'Architecture Associ√©s (Optionnel)



## 5. Tasks Associ√©es



EOF
}

#==============================================================================
# SECTION 5 : DISPATCH DES COMMANDES
#==============================================================================

# Fonction d'aide
show_help() {
  echo "ü§ñ Aklo Protocol - Interface Unifi√©e"
  echo ""
  echo "USAGE:"
  echo "  aklo <command> [options]"
  echo ""
  echo "üîß COMMANDES SYST√àME:"
  echo "  status [--brief|--detailed|--json]  Tableau de bord du projet"
  echo "  validate [path]                     Validation projet/artefacts"
  echo "  mcp setup|restart|watch             Gestion serveurs MCP"
  echo "  template list|create|apply          Gestion des templates"
  echo "  install-ux                          Installation am√©liorations UX"
  echo ""
  echo "üöÄ COMMANDES D√âVELOPPEMENT:"
  echo "  propose-pbi \"<titre>\" [--template]  Cr√©ation d'un Product Backlog Item"
  echo "  pbi \"<titre>\"                       Alias pour propose-pbi"
  echo "  plan <PBI_ID> [--no-agent]          Planification avec commit atomique"
  echo "  release <type> [--dry-run]          Release (major|minor|patch)"
  echo ""
  echo "üìö AIDE ET INFORMATION:"
  echo "  help                                Affiche cette aide"
  echo "  <command> --help                    Aide sp√©cifique √† une commande"
  echo ""
  echo "üéØ NIVEAUX D'ASSISTANCE:"
  echo "  full      - G√©n√©ration compl√®te par l'IA (d√©faut)"
  echo "  skeleton  - Structure vide √† compl√©ter (--no-agent)"
  echo "  minimal   - IDs uniquement (via .aklo.conf uniquement)"
  echo ""
  echo "‚öôÔ∏è CONFIGURATION:"
  echo "  .aklo.conf              Configuration locale du projet"
  echo "    agent_assistance=full|skeleton|minimal"
  echo "    auto_journal=true|false"
  echo ""
  echo "üìñ EXEMPLES:"
  echo "  aklo status             # Tableau de bord complet"
  echo "  aklo mcp restart        # Red√©marrer les serveurs MCP"
  echo "  aklo plan 42            # Planifier le PBI 42"
  echo "  aklo validate           # Valider le projet"
  echo ""
  echo "üí° Astuce: Utilisez 'aklo <command> --help' pour l'aide d√©taill√©e."
}

# Dispatch principal
case "${1:-help}" in
  "plan")
    shift
    command_plan "$@"
    ;;
  "release")
    shift
    command_release "$@"
    ;;
  "status")
    shift
    command_status "$@"
    ;;
  "mcp")
    shift
    command_mcp "$@"
    ;;
  "validate")
    shift
    command_validate "$@"
    ;;
  "template")
    shift
    command_template "$@"
    ;;
  "install-ux")
    shift
    command_install_ux "$@"
    ;;
  "propose-pbi"|"pbi")
    shift
    command_propose_pbi "$@"
    ;;
  "help"|"--help"|"-h")
    show_help
    ;;
  *)
    echo "Commande inconnue: $1"
    echo "Utilisez 'aklo help' pour voir les commandes disponibles."
    exit 1
    ;;
esac