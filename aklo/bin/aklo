#!/bin/sh
#==============================================================================
# The Aklo Protocol - Interface UnifiÃ©e
#
# Auteur: Human_Developer & AI_Agent
# Version: Interface complÃ¨te avec commits atomiques par protocole
#
# ImplÃ©mente l'interface unifiÃ©e aklo couvrant tous les protocoles
# dÃ©finie dans le META-IMPROVEMENT command-coverage-20250102.
#==============================================================================

# Configuration de base du Shell
set -e

#==============================================================================
# PARSER GÃ‰NÃ‰RIQUE DE PROTOCOLES - SOURCE UNIQUE DE VÃ‰RITÃ‰
#==============================================================================

# Fonction principale : Parser et gÃ©nÃ©rer un artefact depuis un protocole
parse_and_generate_artefact() {
  local protocol_name="$1"        # Ex: "00-PRODUCT-OWNER", "04-DEBOGAGE", "05-REFACTORING"
  local artefact_type="$2"        # Ex: "PBI", "DEBUG", "REFACTOR"
  local assistance_level="$3"     # "full", "skeleton", "minimal"
  local output_file="$4"          # Chemin du fichier de sortie
  local context_vars="$5"         # Variables contextuelles (JSON-like string)
  
  # Construire le chemin du protocole (relatif au rÃ©pertoire racine)
  local protocol_file="./aklo/charte/PROTOCOLES/${protocol_name}.md"
  
  # Si pas trouvÃ© en relatif, essayer le chemin absolu depuis le script
  if [ ! -f "$protocol_file" ]; then
    local script_dir="$(dirname "$0")"
    protocol_file="${script_dir}/../charte/PROTOCOLES/${protocol_name}.md"
  fi
  
  if [ ! -f "$protocol_file" ]; then
    echo "âŒ Erreur : Protocole $protocol_name non trouvÃ© dans la charte." >&2
    echo "   CherchÃ© dans: ./aklo/charte/PROTOCOLES/${protocol_name}.md" >&2
    echo "   Et dans: ${script_dir}/../charte/PROTOCOLES/${protocol_name}.md" >&2
    return 1
  fi
  
  # Parser le protocole pour extraire la structure d'artefact
  local artefact_structure=$(extract_artefact_structure "$protocol_file" "$artefact_type")
  
  if [ -z "$artefact_structure" ]; then
    echo "âŒ Erreur : Structure d'artefact $artefact_type non trouvÃ©e dans $protocol_name." >&2
    return 1
  fi
  
  # Appliquer le filtrage intelligent selon le niveau d'assistance
  local filtered_content=$(apply_intelligent_filtering "$artefact_structure" "$assistance_level" "$context_vars")
  
  # Ã‰crire le rÃ©sultat dans le fichier de sortie
  echo "$filtered_content" > "$output_file"
  
  return 0
}

# Extraire la structure d'artefact depuis un protocole
extract_artefact_structure() {
  local protocol_file="$1"
  local artefact_type="$2"
  
  # Patterns de recherche selon le type d'artefact
  local start_pattern=""
  local end_pattern=""
  
  case "$artefact_type" in
    "PBI")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier PBI"
      end_pattern="^## SECTION 3"
      ;;
    "DEBUG")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Debug"
      end_pattern="^## SECTION 3"
      ;;
    "REFACTOR")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Refactor"
      end_pattern="^## SECTION 3"
      ;;
    "ARCH")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier ARCH"
      end_pattern="^## SECTION 3"
      ;;
    "TASK")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Task"
      end_pattern="^## SECTION 3"
      ;;
    "RELEASE")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Release"
      end_pattern="^## SECTION 3"
      ;;
    "JOURNAL")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Journal"
      end_pattern="^## SECTION 3"
      ;;
    "REVIEW")
      start_pattern="### 2\.2\. Structure Obligatoire Du Fichier Review"
      end_pattern="^## SECTION 3"
      ;;
    "HOTFIX")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier Hotfix"
      end_pattern="^## SECTION 3"
      ;;
    "OPTIM")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Optim"
      end_pattern="^## SECTION 3"
      ;;
    "AUDIT")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier d'Audit"
      end_pattern="^## SECTION 3"
      ;;
    "EXPERIMENT")
      start_pattern="### 2\.3\. Structure Obligatoire Du Fichier Experiment"
      end_pattern="^## SECTION 3"
      ;;
    "USER-DOCS")
      start_pattern="### 2\.3\. Structure Obligatoire du Fichier de Documentation"
      end_pattern="^## SECTION 3"
      ;;
    *)
      echo "âŒ Type d'artefact $artefact_type non supportÃ©." >&2
      return 1
      ;;
  esac
  
  # Extraire la section entre les patterns
  local structure=$(sed -n "/$start_pattern/,/$end_pattern/p" "$protocol_file")
  
  # Si aucune section trouvÃ©e, retourner vide
  if [ -z "$structure" ]; then
    return 1
  fi
  
  # Supprimer la premiÃ¨re ligne (pattern de dÃ©but)
  structure=$(echo "$structure" | tail -n +2)
  
  # Supprimer la derniÃ¨re ligne si elle contient le pattern de fin
  if echo "$structure" | tail -n 1 | grep -q "^## SECTION 3"; then
    # Compter les lignes et supprimer la derniÃ¨re
    local line_count=$(echo "$structure" | wc -l)
    local target_lines=$((line_count - 1))
    structure=$(echo "$structure" | head -n $target_lines)
  fi
  
  # Extraire uniquement le contenu markdown entre ```markdown et ```
  echo "$structure" | sed -n '/```markdown/,/```/p' | sed '1d;$d'
}

# Appliquer le filtrage intelligent selon le niveau d'assistance
apply_intelligent_filtering() {
  local content="$1"
  local assistance_level="$2"
  local context_vars="$3"
  
  # Parser les variables contextuelles (format simple key=value) - approche robuste
  # Remplacer les virgules par des newlines et parser ligne par ligne
  local vars_lines=$(echo "$context_vars" | sed 's/,/\n/g')
  local id_value=$(echo "$vars_lines" | grep '^id=' | cut -d'=' -f2 | tr -d '\n\r')
  local full_id_value=$(echo "$vars_lines" | grep '^full_id=' | cut -d'=' -f2 | tr -d '\n\r')
  local pbi_id_value=$(echo "$vars_lines" | grep '^pbi_id=' | cut -d'=' -f2 | tr -d '\n\r')
  local task_id_value=$(echo "$vars_lines" | grep '^task_id=' | cut -d'=' -f2 | tr -d '\n\r')
  local title_value=$(echo "$vars_lines" | grep '^title=' | cut -d'=' -f2 | tr -d '\n\r')
  local date_value=$(echo "$vars_lines" | grep '^date=' | cut -d'=' -f2 | tr -d '\n\r')
  local status_value=$(echo "$vars_lines" | grep '^status=' | cut -d'=' -f2 | tr -d '\n\r')
  local version_value=$(echo "$vars_lines" | grep '^version=' | cut -d'=' -f2 | tr -d '\n\r')
  local timestamp_value=$(echo "$vars_lines" | grep '^timestamp=' | cut -d'=' -f2 | tr -d '\n\r')
  
  # Appliquer les remplacements intelligents
  local filtered_content="$content"
  
  # Extraire PBI_ID et ARCH_ID depuis id_value (format: "1-4")
  local pbi_id_only="${id_value%%-*}"    # "1" depuis "1-4"
  local arch_id_only="${id_value##*-}"   # "4" depuis "1-4"
  

  
  # Remplacements de patterns selon le type d'artefact (ordre important!)
  # 1. Remplacements pour TASK (01-PLANIFICATION)
  if [ -n "$full_id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/TASK-\\[PBI_ID\\]-\\[Task_ID\\]/TASK-${full_id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/feature\\/task-\\[PBI_ID\\]-\\[Task_ID\\]/feature\\/task-${full_id_value}/g")
  fi
  if [ -n "$pbi_id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[PBI_ID\\]/${pbi_id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/PBI-\\[PBI_ID\\]/PBI-${pbi_id_value}/g")
  fi
  if [ -n "$task_id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[Task_ID\\]/${task_id_value}/g")
  fi
  
  # 2. Remplacements pour ARCH (02-ARCHITECTURE) 
  if [ -n "$id_value" ]; then
    # Extraire PBI_ID et ARCH_ID depuis id_value (format: "1-4")
    local pbi_id_only="${id_value%%-*}"    # "1" depuis "1-4"
    local arch_id_only="${id_value##*-}"   # "4" depuis "1-4"
    
    filtered_content=$(echo "$filtered_content" | sed "s/ARCH-\\[PBI_ID\\]-\\[ID\\]/ARCH-${id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/ARCH-42-1/ARCH-${id_value}/g")  # Remplacer l'exemple ARCH-42-1
    filtered_content=$(echo "$filtered_content" | sed "s/PBI-42/PBI-${pbi_id_only}/g")   # Remplacer l'exemple PBI-42
    filtered_content=$(echo "$filtered_content" | sed "s/\\[ID\\]/${arch_id_only}/g")
  fi
  
  # 3. Remplacements de patterns gÃ©nÃ©riques et titres
  if [ -n "$title_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[Titre dÃ©crivant le problÃ¨me architectural\\]/${title_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/\\[Titre technique de la tÃ¢che\\]/${title_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/%%TITLE%%/${title_value}/g")
  fi
  
  # 4. Remplacements d'ID gÃ©nÃ©riques
  if [ -n "$id_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/%%ID%%/${id_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/PBI-%%ID%%/PBI-${id_value}/g")
  fi
  
  # 5. Remplacements de version (RELEASE)
  if [ -n "$version_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/\\[version\\]/${version_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/v\\[version\\]/v${version_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/vX\\.X\\.X/v${version_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/X\\.X\\.X/${version_value}/g")
  fi
  
  # 6. Remplacements de timestamp (JOURNAL)
  if [ -n "$timestamp_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/HH:MM/${timestamp_value}/g")
  fi
  
  # 7. Remplacements de dates (patterns YYYY-MM-DD et commandes date)
  if [ -n "$date_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/YYYY-MM-DD/${date_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/[0-9]\{4\}-[0-9]\{2\}-[0-9]\{2\}/${date_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/\$(date +[^)]*))/${date_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/\$(date +'[^']*')/${date_value}/g")
  fi
  
  # Remplacements de statuts
  if [ -n "$status_value" ]; then
    filtered_content=$(echo "$filtered_content" | sed "s/PROPOSED/${status_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/INVESTIGATING/${status_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/ANALYSIS/${status_value}/g")
    filtered_content=$(echo "$filtered_content" | sed "s/DRAFT/${status_value}/g")
  fi
  
  # Adaptation selon le niveau d'assistance
  case "$assistance_level" in
    "full")
      # Garder tout le contenu avec exemples et instructions
      ;;
    "skeleton")
      # Supprimer les exemples et instructions dÃ©taillÃ©es, garder la structure
      filtered_content=$(echo "$filtered_content" | sed 's/(Ex: [^)]*)//g')
      filtered_content=$(echo "$filtered_content" | sed 's/_Ã€ complÃ©ter[^_]*_/_Ã€ complÃ©ter_/g')
      ;;
    "minimal")
      # Garder seulement la structure de base, supprimer les dÃ©tails
      filtered_content=$(echo "$filtered_content" | sed 's/(.*)//')
      filtered_content=$(echo "$filtered_content" | sed 's/_[^_]*_//g')
      filtered_content=$(echo "$filtered_content" | sed '/^$/N;/^\n$/d')
      ;;
  esac
  
  echo "$filtered_content"
}

# Fonction utilitaire : DÃ©tecter le type d'ID selon le protocole
detect_id_pattern() {
  local protocol_name="$1"
  local base_value="$2"  # Valeur de base (ex: titre pour DEBUG, PBI_ID pour ARCH)
  
  case "$protocol_name" in
    "00-PRODUCT-OWNER")
      # PBI: ID numÃ©rique simple
      echo "$base_value"
      ;;
    "04-DEBOGAGE")
      # DEBUG: titre-slugifiÃ©-YYYYMMDD
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "05-REFACTORING")
      # REFACTOR: titre-slugifiÃ©-YYYYMMDD (mÃªme pattern que DEBUG)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "02-ARCHITECTURE")
      # ARCH: PBI_ID-SEQ-STATUS (ex: 1-1-DRAFT)
      echo "$base_value"  # DÃ©jÃ  formatÃ© par la commande appelante
      ;;
    "01-PLANIFICATION")
      # TASK: PBI_ID-TASK_SEQ (ex: 1-1)
      echo "$base_value"  # DÃ©jÃ  formatÃ© par la commande appelante
      ;;
    "09-RELEASE")
      # RELEASE: Version sÃ©mantique (ex: 1.2.0)
      echo "$base_value"  # Version dÃ©jÃ  formatÃ©e
      ;;
    "18-JOURNAL")
      # JOURNAL: Date YYYY-MM-DD (ex: 2025-01-02)
      echo "$base_value"  # Date dÃ©jÃ  formatÃ©e
      ;;
    "07-REVUE-DE-CODE")
      # REVIEW: ID de task ou PR (ex: task-42-1, pr-123)
      echo "$base_value"  # ID dÃ©jÃ  formatÃ© par la commande appelante
      ;;
    "10-HOTFIX")
      # HOTFIX: description-slugifiÃ©e-YYYYMMDD (ex: bug-login-prod-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "06-OPTIMISATION")
      # OPTIM: description-slugifiÃ©e-YYYYMMDD (ex: api-users-performance-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "13-SECURITE-AUDIT")
      # AUDIT-SECURITY: YYYY-MM-DD (ex: 2025-06-28)
      echo "$(date +%Y-%m-%d)"
      ;;
    "11-EXPERIMENTATION")
      # EXPERIMENT: description-slugifiÃ©e-YYYYMMDD (ex: button-cta-color-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    "17-USER-DOCS")
      # USER-DOCS: description-slugifiÃ©e-YYYYMMDD (ex: new-payment-feature-20250628)
      local date_id=$(date +%Y%m%d)
      local title_slug=$(echo "$base_value" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
      echo "${title_slug}-${date_id}"
      ;;
    *)
      echo "$base_value"
      ;;
  esac
}

#==============================================================================
# SECTION 1 : FONCTIONS UTILITAIRES HÃ‰RITÃ‰ES
#==============================================================================

# RÃ©utilisation des fonctions existantes
get_next_id() {
  SEARCH_PATH="$1"
  PREFIX="$2"
  LAST_ID=$(ls "${SEARCH_PATH}/${PREFIX}"*-*.md 2>/dev/null | sed -n "s/.*${PREFIX}\([0-9]*\)-.*/\1/p" | sort -n | tail -1 || echo 0)
  NEXT_ID=$((LAST_ID + 1))
  echo "$NEXT_ID"
}

get_config() {
  KEY="$1"
  GLOBAL_CONFIG_FILE="$(dirname "$0")/../config/.aklo.conf"
  
  find_local_config() {
    local current_dir="$(pwd)"
    while [ "$current_dir" != "/" ]; do
      if [ -f "$current_dir/.aklo.conf" ]; then
        echo "$current_dir/.aklo.conf"
        return 0
      fi
      current_dir="$(dirname "$current_dir")"
    done
    return 1
  }
  
  CONFIG_FILE=$(find_local_config) || CONFIG_FILE="$GLOBAL_CONFIG_FILE"
  if [ ! -f "$CONFIG_FILE" ]; then
    echo "Erreur : Fichier de configuration introuvable." >&2
    exit 1
  fi
  
  sed -n "/^${KEY}=/s/^[^=]*=//p" "$CONFIG_FILE" | tr -d '"'
}

#==============================================================================
# SECTION 2 : FONCTIONS JOURNAL ATOMIQUE
#==============================================================================

# Fonction: update_journal
# RÃ´le: Met Ã  jour le journal quotidien avec une entrÃ©e de protocole
# Usage: update_journal "PROTOCOLE" "Action" "Description" "Artefacts"
update_journal() {
  PROTOCOL="$1"
  ACTION="$2"
  DESCRIPTION="$3"
  ARTEFACTS="$4"
  
  JOURNAL_DIR="./$(get_config "JOURNAL_DIR")"
  TODAY=$(date +%Y-%m-%d)
  JOURNAL_FILE="${JOURNAL_DIR}/JOURNAL-${TODAY}.md"
  TIMESTAMP=$(date +%H:%M)
  
  # CrÃ©er le rÃ©pertoire journal si nÃ©cessaire
  mkdir -p "$JOURNAL_DIR"
  
  # CrÃ©er le fichier journal du jour si nÃ©cessaire avec le parser gÃ©nÃ©rique
  if [ ! -f "$JOURNAL_FILE" ]; then
    local context_vars="date=${TODAY},timestamp=${TIMESTAMP}"
    parse_and_generate_artefact "18-JOURNAL" "JOURNAL" "full" "$JOURNAL_FILE" "$context_vars"
    
    if [ $? -ne 0 ]; then
      echo "âš ï¸ Fallback vers gÃ©nÃ©ration statique JOURNAL" >&2
      # Fallback statique si le parser Ã©choue
      cat > "$JOURNAL_FILE" << EOF
# JOURNAL DE TRAVAIL : ${TODAY}
---
**Responsable:** Human_Developer
**Objectif(s) de la journÃ©e:** [Ã€ dÃ©finir]
---

## EntrÃ©es Chronologiques

### ${TIMESTAMP} - DÃ©but de session

- **Action :** Ouverture du journal quotidien
- **Contexte :** PremiÃ¨re utilisation du systÃ¨me de journal intÃ©grÃ©

EOF
    fi
  fi
  
  # Ajouter l'entrÃ©e de protocole (structure extraite du protocole)
  cat >> "$JOURNAL_FILE" << EOF
### ${TIMESTAMP} - [${PROTOCOL}] ${ACTION}

- **Action :** ${DESCRIPTION}
- **Artefacts :** ${ARTEFACTS}
- **Timestamp :** ${TODAY} ${TIMESTAMP}

EOF
}

#==============================================================================
# SECTION 3 : COMMANDES AVEC COMMITS ATOMIQUES
#==============================================================================

# Commande: plan (Version 2.0 - Commit Atomique)
# ImplÃ©mente le protocole PLANIFICATION avec commit atomique unique
command_plan() {
  if [ -z "$1" ]; then
    echo "Erreur : L'ID du PBI est requis (ex: 42)." >&2
    exit 1
  fi
  PBI_ID="$1"
  
  # DÃ©tection du niveau d'assistance
  AGENT_ASSISTANCE=$(get_config "AGENT_ASSISTANCE")
  AUTO_JOURNAL=$(get_config "AUTO_JOURNAL")
  
  # Parsing des arguments
  shift
  while [ $# -gt 0 ]; do
    case "$1" in
      --no-agent)
        AGENT_ASSISTANCE="skeleton"
        ;;
      --no-journal)
        AUTO_JOURNAL="false"
        ;;
      *)
        echo "Argument inconnu: $1" >&2
        exit 1
        ;;
    esac
    shift
  done
  
  # Override depuis la configuration si prÃ©sente
  CONFIG_ASSISTANCE=$(get_config "AGENT_ASSISTANCE" 2>/dev/null || echo "")
  CONFIG_JOURNAL=$(get_config "AUTO_JOURNAL" 2>/dev/null || echo "")
  
  if [ -n "$CONFIG_ASSISTANCE" ]; then
    AGENT_ASSISTANCE="$CONFIG_ASSISTANCE"
  fi
  if [ -n "$CONFIG_JOURNAL" ]; then
    AUTO_JOURNAL="$CONFIG_JOURNAL"
  fi
  
  echo "--- PLANIFICATION v2.0 (Commit Atomique) ---"
  echo "â€º PBI: ${PBI_ID}"
  echo "â€º Assistance: ${AGENT_ASSISTANCE}"
  echo "â€º Journal automatique: ${AUTO_JOURNAL}"
  echo ""
  
  # Validation du PBI
  PBI_FILE=$(ls ./docs/backlog/00-pbi/PBI-${PBI_ID}-*.md 2>/dev/null | head -1)
  if [ ! -f "$PBI_FILE" ]; then
    echo "Erreur : PBI ${PBI_ID} introuvable." >&2
    exit 1
  fi
  
  # PrÃ©paration des variables pour le commit atomique
  CREATED_TASKS=""
  MODIFIED_FILES=""
  TASK_COUNT=0
  
  echo "--- Phase 1: CrÃ©ation des Tasks ---"
  
  case "$AGENT_ASSISTANCE" in
    "full")
      echo "Mode FULL: L'IA va gÃ©nÃ©rer le contenu complet des tasks."
      echo "TODO: IntÃ©gration avec le serveur MCP pour gÃ©nÃ©ration automatique"
      ;;
    "skeleton")
      echo "Mode SKELETON: CrÃ©ation de la structure des tasks Ã  complÃ©ter."
      ;;
    "minimal")
      echo "Mode MINIMAL: CrÃ©ation des fichiers avec IDs uniquement."
      ;;
  esac
  
  # Boucle de crÃ©ation interactive (simplifiÃ©e pour la dÃ©mo)
  while true; do
    printf "  â€º Titre de la nouvelle tÃ¢che (vide pour terminer): "
    read -r TASK_TITLE
    
    if [ -z "$TASK_TITLE" ]; then
      break
    fi
    
    TASK_COUNT=$((TASK_COUNT + 1))
    TASK_ID=$(printf "%02d" $TASK_COUNT)
    TASK_FILENAME="TASK-${PBI_ID}-${TASK_ID}-TODO.md"
    TASK_PATH="./docs/backlog/01-tasks/${TASK_FILENAME}"
    
    # CrÃ©ation du fichier Task selon le niveau d'assistance
    mkdir -p "./docs/backlog/01-tasks"
    
    # GÃ©nÃ©ration dynamique depuis le protocole PLANIFICATION
    local task_full_id="${PBI_ID}-${TASK_ID}"
    local context_vars="pbi_id=${PBI_ID},task_id=${TASK_ID},full_id=${task_full_id},title=${TASK_TITLE},status=TODO"
    
    parse_and_generate_artefact "01-PLANIFICATION" "TASK" "$AGENT_ASSISTANCE" "$TASK_PATH" "$context_vars"
    
    # VÃ©rification du succÃ¨s de gÃ©nÃ©ration
    if [ $? -ne 0 ]; then
      echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration TASK depuis le protocole PLANIFICATION" >&2
      echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole et rÃ©essayez" >&2
      return 1
    fi
    
    CREATED_TASKS="${CREATED_TASKS}${TASK_FILENAME} "
    MODIFIED_FILES="${MODIFIED_FILES}${TASK_PATH} "
    echo "  âœ“ Task crÃ©Ã©e: ${TASK_FILENAME}"
  done
  
  if [ $TASK_COUNT -eq 0 ]; then
    echo "Aucune task crÃ©Ã©e. Abandon."
    exit 0
  fi
  
  echo ""
  echo "--- Phase 2: Mise Ã  jour du PBI ---"
  
  # Mise Ã  jour du PBI avec la liste des tasks
  cp "$PBI_FILE" "${PBI_FILE}.backup"
  
  # Ajout de la section Tasks si elle n'existe pas
  if ! grep -q "## Tasks AssociÃ©es" "$PBI_FILE"; then
    cat >> "$PBI_FILE" << EOF

## Tasks AssociÃ©es

EOF
  fi
  
  # Ajout des tasks crÃ©Ã©es
  for task_file in $CREATED_TASKS; do
    task_id=$(echo "$task_file" | sed 's/TASK-\([^-]*-[^-]*\)-.*/\1/')
    echo "- TASK-${task_id}: [CrÃ©Ã©e]" >> "$PBI_FILE"
  done
  
  MODIFIED_FILES="${MODIFIED_FILES}${PBI_FILE} "
  echo "  âœ“ PBI mis Ã  jour avec ${TASK_COUNT} tasks"
  
  # Phase 3: Mise Ã  jour du journal
  if [ "$AUTO_JOURNAL" = "true" ]; then
    echo ""
    echo "--- Phase 3: Mise Ã  jour du journal ---"
    
    JOURNAL_DESCRIPTION="DÃ©composition PBI-${PBI_ID} en ${TASK_COUNT} tasks techniques (mode: ${AGENT_ASSISTANCE})"
    JOURNAL_ARTEFACTS="PBI-${PBI_ID} mis Ã  jour, ${TASK_COUNT} tasks crÃ©Ã©es: ${CREATED_TASKS}"
    
    update_journal "PLANIFICATION" "DÃ©composition PBI" "$JOURNAL_DESCRIPTION" "$JOURNAL_ARTEFACTS"
    
    JOURNAL_FILE="./docs/backlog/15-journal/JOURNAL-$(date +%Y-%m-%d).md"
    MODIFIED_FILES="${MODIFIED_FILES}${JOURNAL_FILE} "
    echo "  âœ“ Journal mis Ã  jour"
  fi
  
  # Phase 4: Validation et commit atomique
  echo ""
  echo "--- Phase 4: PrÃ©paration du commit atomique ---"
  echo "Fichiers Ã  committer:"
  for file in $MODIFIED_FILES; do
    echo "  - $file"
  done
  echo ""
  
  printf "Voulez-vous crÃ©er le commit atomique de planification ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Commit annulÃ©. Fichiers conservÃ©s pour rÃ©vision manuelle."
    exit 0
  fi
  
  # CrÃ©ation du commit atomique
  git add $MODIFIED_FILES
  
  COMMIT_MSG="feat(planning): DÃ©composition PBI-${PBI_ID} en ${TASK_COUNT} tasks

- CrÃ©ation de ${TASK_COUNT} tasks techniques (mode: ${AGENT_ASSISTANCE})
- PBI-${PBI_ID} mis Ã  jour avec la liste des tasks associÃ©es"

  if [ "$AUTO_JOURNAL" = "true" ]; then
    COMMIT_MSG="${COMMIT_MSG}
- Journal mis Ã  jour avec le processus de planification"
  fi

  COMMIT_MSG="${COMMIT_MSG}

Tasks crÃ©Ã©es:"
  for task_file in $CREATED_TASKS; do
    task_title=$(head -1 "./docs/backlog/01-tasks/$task_file" | sed 's/# //')
    COMMIT_MSG="${COMMIT_MSG}
- $task_title"
  done

  COMMIT_MSG="${COMMIT_MSG}

Prochaine Ã©tape: DEVELOPPEMENT"
  
  git commit -m "$COMMIT_MSG"
  
  echo ""
  echo "ğŸ‰ Planification terminÃ©e avec commit atomique !"
  echo "   ${TASK_COUNT} tasks crÃ©Ã©es pour PBI-${PBI_ID}"
  echo "   Commit: $(git rev-parse --short HEAD)"
}

#==============================================================================
# SECTION 4 : COMMANDE RELEASE V2.0
#==============================================================================

# Commande: release (Version 2.0 - Workflow SÃ©quentiel + Commit Atomique)
command_release() {
  if [ -z "$1" ]; then
    echo "Erreur : Le type de release est requis (major, minor, patch)." >&2
    exit 1
  fi
  BUMP_TYPE="$1"
  
  echo "--- RELEASE v2.0 (Workflow SÃ©quentiel + Commit Atomique) ---"
  
  # Phase 1: PrÃ©paration locale (sans commit)
  echo "--- Phase 1: PrÃ©paration locale ---"
  
  CURRENT_VERSION=$(grep '"version"' package.json | sed 's/.*"version": "\([^"]*\)".*/\1/' || echo "0.0.0")
  
  case "$BUMP_TYPE" in
    "major")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print ($1+1)".0.0"}')
      ;;
    "minor")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print $1"."($2+1)".0"}')
      ;;
    "patch")
      NEW_VERSION=$(echo "$CURRENT_VERSION" | awk -F. '{print $1"."$2"."($3+1)}')
      ;;
    *)
      echo "Erreur : Type de release invalide. Utilisez major, minor ou patch." >&2
      exit 1
      ;;
  esac
  
  echo "  â€º Version actuelle: ${CURRENT_VERSION}"
  echo "  â€º Nouvelle version: ${NEW_VERSION}"
  
  # PrÃ©paration des fichiers (sans commit)
  RELEASE_DIR="./$(get_config "RELEASES_DIR")"
  mkdir -p "$RELEASE_DIR"
  RELEASE_FILE="${RELEASE_DIR}/RELEASE-${NEW_VERSION}-AWAITING_DEPLOYMENT.md"
  
  # GÃ©nÃ©ration dynamique depuis le protocole RELEASE
  local context_vars="version=${NEW_VERSION},type=${BUMP_TYPE},date=$(date +%Y-%m-%d),status=AWAITING_DEPLOYMENT"
  
  parse_and_generate_artefact "09-RELEASE" "RELEASE" "full" "$RELEASE_FILE" "$context_vars"
  
  # VÃ©rification du succÃ¨s de gÃ©nÃ©ration
  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration RELEASE depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole 09-RELEASE" >&2
    return 1
  fi
  
  # Mise Ã  jour du CHANGELOG (simplifiÃ©)
  if [ ! -f "CHANGELOG.md" ]; then
    echo "# CHANGELOG" > CHANGELOG.md
    echo "" >> CHANGELOG.md
  fi
  
  # Ajout de la nouvelle version au CHANGELOG
  sed -i.bak "2i\\
\\
## [${NEW_VERSION}] - $(date +%Y-%m-%d)\\
\\
### Added\\
- [Ã€ complÃ©ter]\\
\\
### Changed\\
- [Ã€ complÃ©ter]\\
\\
### Fixed\\
- [Ã€ complÃ©ter]\\
" CHANGELOG.md
  
  # Mise Ã  jour de la version dans package.json
  if [ -f "package.json" ]; then
    sed -i.bak "s/\"version\": \"${CURRENT_VERSION}\"/\"version\": \"${NEW_VERSION}\"/" package.json
  fi
  
  echo "  âœ“ Rapport de release crÃ©Ã©"
  echo "  âœ“ CHANGELOG.md mis Ã  jour"
  echo "  âœ“ Version mise Ã  jour dans package.json"
  
  # Phase 2: Validation technique (sans commit)
  echo ""
  echo "--- Phase 2: Validation technique ---"
  echo "  â€º Lancement des tests..."
  
  # Simulation des tests (Ã  adapter selon le projet)
  if command -v npm >/dev/null 2>&1 && [ -f "package.json" ]; then
    echo "  â€º Tests npm..."
    # npm test || { echo "Erreur: Les tests ont Ã©chouÃ©"; exit 1; }
    echo "  âœ“ Tests npm passÃ©s (simulÃ©)"
  fi
  
  echo "  âœ“ Validation technique rÃ©ussie"
  
  # Phase 3: Mise Ã  jour du journal
  echo ""
  echo "--- Phase 3: Mise Ã  jour du journal ---"
  
  JOURNAL_DESCRIPTION="PrÃ©paration release v${NEW_VERSION} (type: ${BUMP_TYPE})"
  JOURNAL_ARTEFACTS="RELEASE-${NEW_VERSION}, CHANGELOG.md, package.json"
  
  update_journal "RELEASE" "PrÃ©paration release" "$JOURNAL_DESCRIPTION" "$JOURNAL_ARTEFACTS"
  echo "  âœ“ Journal mis Ã  jour"
  
  # Phase 4: Validation humaine du diff complet
  echo ""
  echo "--- Phase 4: Validation du commit atomique ---"
  echo "Fichiers modifiÃ©s pour la release:"
  echo "  - ${RELEASE_FILE}"
  echo "  - CHANGELOG.md"
  echo "  - package.json"
  echo "  - ./docs/backlog/15-journal/JOURNAL-$(date +%Y-%m-%d).md"
  echo ""
  
  printf "Voulez-vous crÃ©er le commit atomique de release ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Release annulÃ©e. Fichiers conservÃ©s pour rÃ©vision manuelle."
    exit 0
  fi
  
  # Phase 5: Commit atomique final
  echo ""
  echo "--- Phase 5: Commit atomique et tagging ---"
  
  git add "$RELEASE_FILE" CHANGELOG.md package.json "./docs/backlog/15-journal/JOURNAL-$(date +%Y-%m-%d).md"
  
  COMMIT_MSG="release: Version ${NEW_VERSION}

Release ${BUMP_TYPE} v${NEW_VERSION} prÃ©parÃ©e et validÃ©e.

- Rapport RELEASE-${NEW_VERSION} finalisÃ©
- CHANGELOG.md mis Ã  jour avec nouvelles fonctionnalitÃ©s
- Version mise Ã  jour : ${CURRENT_VERSION} â†’ ${NEW_VERSION}
- Journal mis Ã  jour avec le processus de release
- Tous les tests passent, build de production validÃ©

Type de release: ${BUMP_TYPE}"
  
  git commit -m "$COMMIT_MSG"
  
  # CrÃ©ation du tag
  git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
  
  echo ""
  echo "ğŸ‰ Release v${NEW_VERSION} crÃ©Ã©e avec succÃ¨s !"
  echo "   Commit: $(git rev-parse --short HEAD)"
  echo "   Tag: v${NEW_VERSION}"
  echo ""
  echo "Prochaines Ã©tapes:"
  echo "  1. git push origin main"
  echo "  2. git push origin v${NEW_VERSION}"
  echo "  3. DÃ©ploiement en production"
}

#==============================================================================
# SECTION 4 : COMMANDES SYSTÃˆME (P1 - PrioritÃ© maximale)
#==============================================================================

# Commande: status - Tableau de bord complet du projet
command_status() {
  local mode="${1:-standard}"
  local script_dir="$(dirname "$0")"
  
  case "$mode" in
    "--help")
      echo "Usage: aklo status [--brief|--detailed|--json]"
      echo ""
      echo "Affiche le tableau de bord complet du projet aklo."
      echo ""
      echo "Options:"
      echo "  --brief, -b     Affichage condensÃ©"
      echo "  --detailed, -d  Affichage dÃ©taillÃ© avec mÃ©triques"
      echo "  --json          Sortie au format JSON"
      exit 0
      ;;
    *)
      # DÃ©lÃ©guer au script spÃ©cialisÃ© pour tous les modes
      if [ -f "$script_dir/../ux-improvements/status-command.sh" ]; then
        . "$script_dir/../ux-improvements/status-command.sh"
        # Passer le mode ou "standard" si vide
        aklo_status "${mode:-standard}"
      else
        echo "Erreur : Script status-command.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: mcp - Gestion des serveurs MCP
command_mcp() {
  local action="$1"
  local script_dir="$(dirname "$0")"
  
  case "$action" in
    "setup")
      echo "ğŸ”§ Configuration des serveurs MCP..."
      if [ -f "$script_dir/../mcp-servers/setup-mcp.sh" ]; then
        "$script_dir/../mcp-servers/setup-mcp.sh"
      else
        echo "Erreur : Script setup-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "restart")
      echo "ğŸ”„ RedÃ©marrage des serveurs MCP..."
      if [ -f "$script_dir/../mcp-servers/restart-mcp.sh" ]; then
        "$script_dir/../mcp-servers/restart-mcp.sh"
      else
        echo "Erreur : Script restart-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "watch")
      echo "ğŸ‘ï¸ Surveillance des serveurs MCP..."
      if [ -f "$script_dir/../mcp-servers/watch-mcp.sh" ]; then
        "$script_dir/../mcp-servers/watch-mcp.sh"
      else
        echo "Erreur : Script watch-mcp.sh introuvable." >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo mcp <action>"
      echo ""
      echo "Gestion des serveurs MCP (Model Context Protocol)."
      echo ""
      echo "Actions:"
      echo "  setup     Configuration initiale des serveurs MCP"
      echo "  restart   RedÃ©marrage des serveurs aprÃ¨s modification"
      echo "  watch     Surveillance en temps rÃ©el des serveurs"
      echo ""
      echo "Exemples:"
      echo "  aklo mcp setup      # Configuration initiale"
      echo "  aklo mcp restart    # AprÃ¨s modification du code MCP"
      echo "  aklo mcp watch      # Surveillance continue"
      exit 0
      ;;
    *)
      echo "Erreur : Action MCP inconnue '$action'." >&2
      echo "Utilisez 'aklo mcp help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: validate - Validation de projets et artefacts
command_validate() {
  local target="${1:-.}"
  local script_dir="$(dirname "$0")"
  
  case "$target" in
    "--help")
      echo "Usage: aklo validate [path]"
      echo ""
      echo "Valide la structure et la cohÃ©rence du projet aklo."
      echo ""
      echo "Arguments:"
      echo "  path    Chemin Ã  valider (dÃ©faut: rÃ©pertoire courant)"
      echo ""
      echo "Validations effectuÃ©es:"
      echo "  â€¢ Structure des rÃ©pertoires aklo"
      echo "  â€¢ CohÃ©rence des artefacts (PBI, TASK, etc.)"
      echo "  â€¢ Respect des protocoles de la charte"
      echo "  â€¢ Configuration .aklo.conf"
      exit 0
      ;;
    *)
      echo "ğŸ” Validation du projet aklo..."
      if [ -f "$script_dir/../ux-improvements/validation.sh" ]; then
        "$script_dir/../ux-improvements/validation.sh" "$target"
      else
        echo "Erreur : Script validation.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: template - Gestion des templates
command_template() {
  local action="$1"
  local script_dir="$(dirname "$0")"
  
  case "$action" in
    "list")
      echo "ğŸ“‹ Templates disponibles..."
      if [ -f "$script_dir/../ux-improvements/templates.sh" ]; then
        . "$script_dir/../ux-improvements/templates.sh"
        list_templates
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "create")
      shift
      echo "ğŸ†• CrÃ©ation d'un nouveau template..."
      if [ -f "$script_dir/../ux-improvements/templates.sh" ]; then
        . "$script_dir/../ux-improvements/templates.sh"
        create_template "$@"
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "apply")
      shift
      echo "ğŸ“ Application d'un template..."
      if [ -f "$script_dir/../ux-improvements/templates.sh" ]; then
        . "$script_dir/../ux-improvements/templates.sh"
        apply_template "$@"
      else
        echo "Erreur : Script templates.sh introuvable." >&2
        exit 1
      fi
      ;;
    "--help"|"help"|"")
      echo "Usage: aklo template <action> [args...]"
      echo ""
      echo "Gestion des templates de projet aklo."
      echo ""
      echo "Actions:"
      echo "  list              Liste les templates disponibles"
      echo "  create <name>     CrÃ©e un nouveau template"
      echo "  apply <name>      Applique un template au projet"
      echo ""
      echo "Exemples:"
      echo "  aklo template list"
      echo "  aklo template create mon-template"
      echo "  aklo template apply web-app"
      exit 0
      ;;
    *)
      echo "Erreur : Action template inconnue '$action'." >&2
      echo "Utilisez 'aklo template help' pour voir les actions disponibles."
      exit 1
      ;;
  esac
}

# Commande: install-ux - Installation des amÃ©liorations UX
command_install_ux() {
  local script_dir="$(dirname "$0")"
  
  case "${1:-}" in
    "--help")
      echo "Usage: aklo install-ux"
      echo ""
      echo "Installe les amÃ©liorations d'expÃ©rience utilisateur aklo :"
      echo "  â€¢ AutocomplÃ©tion shell (bash/zsh)"
      echo "  â€¢ Aliases et raccourcis"
      echo "  â€¢ Configuration optimisÃ©e"
      echo "  â€¢ IntÃ©gration avec les Ã©diteurs"
      exit 0
      ;;
    *)
      echo "ğŸ¨ Installation des amÃ©liorations UX..."
      if [ -f "$script_dir/../ux-improvements/install-ux.sh" ]; then
        "$script_dir/../ux-improvements/install-ux.sh"
      else
        echo "Erreur : Script install-ux.sh introuvable." >&2
        exit 1
      fi
      ;;
  esac
}

# Commande: propose-pbi - CrÃ©ation d'un Product Backlog Item
command_propose_pbi() {
  local title="$1"
  local template="${2:-default}"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$title" in
    "--help"|"help"|"")
      echo "Usage: aklo propose-pbi \"<titre>\" [--template=<type>]"
      echo ""
      echo "CrÃ©e un nouveau Product Backlog Item selon le protocole PRODUCT-OWNER."
      echo ""
      echo "Arguments:"
      echo "  titre       Titre descriptif du PBI (requis, entre guillemets)"
      echo ""
      echo "Options:"
      echo "  --template=<type>  Type de template (default|feature|bug|improvement)"
      echo "  --no-agent         Mode skeleton (structure vide Ã  complÃ©ter)"
      echo "  --no-journal       Pas de mise Ã  jour automatique du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo propose-pbi \"Ajouter authentification OAuth\""
      echo "  aklo propose-pbi \"Corriger bug de validation\" --template=bug"
      echo "  aklo pbi \"Optimiser temps de chargement\" --no-agent"
      exit 0
      ;;
    --no-agent)
      agent_assistance="skeleton"
      title="$2"
      template="${3:-default}"
      ;;
    --no-journal)
      auto_journal="false"
      title="$2"
      template="${3:-default}"
      ;;
  esac
  
  if [ -z "$title" ]; then
    echo "Erreur : Le titre du PBI est requis." >&2
    echo "Usage: aklo propose-pbi \"<titre>\""
    echo "Utilisez 'aklo propose-pbi --help' pour plus d'informations."
    exit 1
  fi
  
  # GÃ©nÃ©ration de l'ID unique
  PBI_DIR="./$(get_config "PBI_DIR")"
  mkdir -p "$PBI_DIR"
  
  PBI_ID=$(get_next_id "$PBI_DIR" "PBI")
  PBI_FILE="${PBI_DIR}/PBI-${PBI_ID}-PROPOSED.md"
  TODAY=$(date +%Y-%m-%d)
  
  echo "ğŸ¯ CrÃ©ation du PBI-${PBI_ID}: \"$title\""
  
  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole PRODUCT-OWNER..."
      generate_pbi_from_protocol "$PBI_FILE" "$PBI_ID" "$title" "$TODAY" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_pbi_from_protocol "$PBI_FILE" "$PBI_ID" "$title" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_pbi_from_protocol "$PBI_FILE" "$PBI_ID" "$title" "$TODAY" "minimal"
      ;;
  esac
  
  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "PRODUCT-OWNER" "CrÃ©ation PBI" "Nouveau PBI-${PBI_ID}: $title" "PBI-${PBI_ID}-PROPOSED.md"
  fi
  
  echo ""
  echo "âœ… PBI-${PBI_ID}-PROPOSED.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $PBI_FILE"
  echo ""
  echo "Prochaines Ã©tapes:"
  echo "  1. RÃ©viser et complÃ©ter le PBI"
  echo "  2. Valider avec l'Ã©quipe"
  echo "  3. aklo plan ${PBI_ID} (pour dÃ©composer en tÃ¢ches)"
}

# Fonction de gÃ©nÃ©ration PBI - Parser dynamique du protocole PRODUCT-OWNER
generate_pbi_from_protocol() {
  local file="$1"
  local id="$2"
  local title="$3"
  local date="$4"
  local assistance_level="$5"
  
  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="id=${id},title=${title},date=${date},status=PROPOSED"
  
  # GÃ©nÃ©ration dynamique depuis le protocole
  parse_and_generate_artefact "00-PRODUCT-OWNER" "PBI" "$assistance_level" "$file" "$context_vars"
  
  # Si le parser gÃ©nÃ©rique Ã©choue, afficher une erreur explicite
  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration PBI depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole PRODUCT-OWNER" >&2
    return 1
  fi
}

# ===== FONCTION PBI STATIC_FALLBACK SUPPRIMÃ‰E =====
# La fonction generate_pbi_static_fallback a Ã©tÃ© supprimÃ©e car remplacÃ©e 
# par le parser gÃ©nÃ©rique dynamique.

# Commande: arch - Conception d'architecture logicielle
command_arch() {
  local pbi_id="$1"
  local review_flag="$2"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$pbi_id" in
    "--help"|"help"|"")
      echo "Usage: aklo arch <PBI_ID> [--review]"
      echo ""
      echo "Conception d'architecture logicielle selon le protocole ARCHITECTURE."
      echo ""
      echo "Arguments:"
      echo "  PBI_ID      ID du PBI nÃ©cessitant une architecture (requis)"
      echo ""
      echo "Options:"
      echo "  --review    RÃ©vision d'une architecture existante"
      echo "  --no-agent  Mode skeleton (structure vide Ã  complÃ©ter)"
      echo "  --no-journal Pas de mise Ã  jour automatique du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo arch 42            # Nouvelle architecture pour PBI-42"
      echo "  aklo arch 42 --review   # RÃ©vision de l'architecture PBI-42"
      echo "  aklo arch 42 --no-agent # Mode skeleton"
      exit 0
      ;;
    --no-agent)
      agent_assistance="skeleton"
      pbi_id="$2"
      review_flag="$3"
      ;;
    --no-journal)
      auto_journal="false"
      pbi_id="$2"
      review_flag="$3"
      ;;
  esac
  
  if [ -z "$pbi_id" ]; then
    echo "Erreur : L'ID du PBI est requis." >&2
    echo "Usage: aklo arch <PBI_ID>"
    echo "Utilisez 'aklo arch --help' pour plus d'informations."
    exit 1
  fi
  
  # Validation de l'existence du PBI
  PBI_DIR="./$(get_config "PBI_DIR")"
  PBI_FILE=$(find "$PBI_DIR" -name "PBI-${pbi_id}-*.md" 2>/dev/null | head -1)
  
  if [ -z "$PBI_FILE" ]; then
    echo "Erreur : PBI-${pbi_id} introuvable dans $PBI_DIR" >&2
    echo "VÃ©rifiez que le PBI existe avant de crÃ©er son architecture."
    echo "Fichiers PBI disponibles:"
    ls -la "$PBI_DIR"/ 2>/dev/null | grep "PBI-" || echo "  Aucun fichier PBI trouvÃ©"
    exit 1
  fi
  
  # GÃ©nÃ©ration de l'ID d'architecture
  ARCH_DIR="./$(get_config "ARCH_DIR")"
  mkdir -p "$ARCH_DIR"
  
  # Trouver le prochain ID d'architecture pour ce PBI
  ARCH_ID=1
  while [ -f "${ARCH_DIR}/ARCH-${pbi_id}-${ARCH_ID}-"*".md" ]; do
    ARCH_ID=$((ARCH_ID + 1))
  done
  
  if [ "$review_flag" = "--review" ]; then
    # Mode rÃ©vision : chercher l'architecture existante
    EXISTING_ARCH=$(find "$ARCH_DIR" -name "ARCH-${pbi_id}-*-VALIDATED.md" 2>/dev/null | head -1)
    if [ -z "$EXISTING_ARCH" ]; then
      echo "Erreur : Aucune architecture validÃ©e trouvÃ©e pour PBI-${pbi_id}" >&2
      echo "Utilisez 'aklo arch ${pbi_id}' pour crÃ©er une nouvelle architecture."
      exit 1
    fi
    echo "ğŸ”„ RÃ©vision de l'architecture existante : $(basename "$EXISTING_ARCH")"
  fi
  
  ARCH_FILE="${ARCH_DIR}/ARCH-${pbi_id}-${ARCH_ID}-DRAFT.md"
  TODAY=$(date +%Y-%m-%d)
  
  echo "ğŸ—ï¸  CrÃ©ation de l'architecture ARCH-${pbi_id}-${ARCH_ID} pour PBI-${pbi_id}"
  
  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole ARCHITECTURE..."
      generate_arch_from_protocol "$ARCH_FILE" "$pbi_id" "$ARCH_ID" "$TODAY" "$PBI_FILE" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_arch_from_protocol "$ARCH_FILE" "$pbi_id" "$ARCH_ID" "$TODAY" "$PBI_FILE" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_arch_from_protocol "$ARCH_FILE" "$pbi_id" "$ARCH_ID" "$TODAY" "$PBI_FILE" "minimal"
      ;;
  esac
  
  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "ARCHITECTURE" "CrÃ©ation document" "Architecture ARCH-${pbi_id}-${ARCH_ID} pour PBI-${pbi_id}" "ARCH-${pbi_id}-${ARCH_ID}-DRAFT.md"
  fi
  
  echo ""
  echo "âœ… ARCH-${pbi_id}-${ARCH_ID}-DRAFT.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $ARCH_FILE"
  echo ""
  echo "Prochaines Ã©tapes:"
  echo "  1. Analyser le problÃ¨me architectural"
  echo "  2. Ã‰valuer 2-3 options d'architecture"
  echo "  3. Documenter les compromis (trade-offs)"
  echo "  4. Soumettre pour validation"
  echo "  5. Mettre Ã  jour les Tasks aprÃ¨s validation"
}

# ===== FONCTIONS ARCH OBSOLÃˆTES SUPPRIMÃ‰ES =====
# Les fonctions generate_arch_full, generate_arch_skeleton, generate_arch_minimal
# ont Ã©tÃ© supprimÃ©es car remplacÃ©es par le parser gÃ©nÃ©rique dynamique.

# Fonction de gÃ©nÃ©ration ARCH - Parser dynamique du protocole ARCHITECTURE
generate_arch_from_protocol() {
  local file="$1"
  local pbi_id="$2"
  local arch_id="$3"
  local date="$4"
  local pbi_file="$5"
  local assistance_level="$6"
  
  # Extraire le titre du PBI (nettoyer les caractÃ¨res spÃ©ciaux)
  local pbi_title=$(grep "^# PBI-${pbi_id}" "$pbi_file" 2>/dev/null | sed 's/^# PBI-[0-9]* : //' | tr -d '\n\r' || echo "Architecture pour PBI-${pbi_id}")
  
  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local arch_full_id="${pbi_id}-${arch_id}"
  local context_vars="id=${arch_full_id},title=${pbi_title},date=${date},status=DRAFT,pbi_id=${pbi_id},arch_id=${arch_id}"
  

  
  # GÃ©nÃ©ration dynamique depuis le protocole
  parse_and_generate_artefact "02-ARCHITECTURE" "ARCH" "$assistance_level" "$file" "$context_vars"
  
  # Si le parser gÃ©nÃ©rique Ã©choue, afficher une erreur explicite
  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration ARCH depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole ARCHITECTURE" >&2
    return 1
  fi
}

# ===== FONCTION ARCH STATIC_FALLBACK SUPPRIMÃ‰E =====
# La fonction generate_arch_static_fallback a Ã©tÃ© supprimÃ©e car remplacÃ©e 
# par le parser gÃ©nÃ©rique dynamique.

# Commande: dev - DÃ©veloppement TDD d'une Task
command_dev() {
  local task_id="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$task_id" in
    "--help"|"help"|"")
      echo "Usage: aklo dev <TASK_ID>"
      echo ""
      echo "DÃ©marre le dÃ©veloppement TDD d'une Task selon le protocole DÃ‰VELOPPEMENT."
      echo ""
      echo "Arguments:"
      echo "  TASK_ID    ID de la task (format: PBI_ID-TASK_ID, ex: 1-2)"
      echo ""
      echo "Options:"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo dev 1-1              # DÃ©velopper TASK-1-1"
      echo "  aklo dev 2-3 --no-agent   # DÃ©velopper TASK-2-3 en mode minimal"
      echo ""
      echo "PrÃ©requis:"
      echo "  - La Task doit exister avec le statut TODO"
      echo "  - Le rÃ©pertoire doit Ãªtre un projet Git"
      echo ""
      echo "Workflow:"
      echo "  1. Validation de la Task (statut TODO)"
      echo "  2. CrÃ©ation de la branche feature/task-[PBI_ID]-[TASK_ID]"
      echo "  3. Changement de statut TODO â†’ IN_PROGRESS"
      echo "  4. PrÃ©sentation du plan de vol dÃ©veloppement TDD"
      echo "  5. Guidage dans le cycle TDD (RED-GREEN-BLUE)"
      return 0
      ;;
  esac

  # Validation du format TASK_ID
  if [[ ! "$task_id" =~ ^[0-9]+-[0-9]+$ ]]; then
    echo "âŒ Erreur : Format TASK_ID invalide."
    echo "   Format attendu: PBI_ID-TASK_ID (ex: 1-2)"
    echo "   ReÃ§u: '$task_id'"
    return 1
  fi

  # Extraction PBI_ID et TASK_SEQ
  local pbi_id=$(echo "$task_id" | cut -d'-' -f1)
  local task_seq=$(echo "$task_id" | cut -d'-' -f2)
  
  # Recherche de la Task
  local tasks_dir="./$(get_config "TASKS_DIR")"
  local task_file=$(find "$tasks_dir" -name "TASK-${pbi_id}-${task_seq}-TODO.md" 2>/dev/null | head -1)
  
  if [ -z "$task_file" ]; then
    echo "âŒ Erreur : Task TASK-${pbi_id}-${task_seq} introuvable avec statut TODO."
    echo "   RÃ©pertoire recherchÃ©: $tasks_dir"
    echo "   Fichier attendu: TASK-${pbi_id}-${task_seq}-TODO.md"
    echo ""
    echo "VÃ©rifiez que:"
    echo "  1. La Task existe"
    echo "  2. Elle a le statut TODO (pas IN_PROGRESS ou DONE)"
    echo "  3. Le rÃ©pertoire TASKS_DIR est correct dans .aklo.conf"
    return 1
  fi

  echo "ğŸš€ DÃ©marrage du dÃ©veloppement TDD pour TASK-${pbi_id}-${task_seq}"
  echo "ğŸ“ Task trouvÃ©e: $task_file"
  
  # VÃ©rification que nous sommes dans un repo Git
  if ! git rev-parse --git-dir > /dev/null 2>&1; then
    echo "âŒ Erreur : Ce rÃ©pertoire n'est pas un dÃ©pÃ´t Git."
    echo "   Le dÃ©veloppement TDD nÃ©cessite Git pour la gestion des branches."
    return 1
  fi

  # CrÃ©ation de la branche feature
  local branch_name="feature/task-${pbi_id}-${task_seq}"
  echo "ğŸŒ¿ CrÃ©ation de la branche: $branch_name"
  
  if git show-ref --verify --quiet refs/heads/$branch_name; then
    echo "âš ï¸  La branche $branch_name existe dÃ©jÃ ."
    echo "   Basculement vers la branche existante..."
    git checkout $branch_name
  else
    git checkout -b $branch_name
    if [ $? -ne 0 ]; then
      echo "âŒ Erreur : Impossible de crÃ©er la branche $branch_name"
      return 1
    fi
  fi

  # Changement de statut TODO â†’ IN_PROGRESS
  local new_task_file="${tasks_dir}/TASK-${pbi_id}-${task_seq}-IN_PROGRESS.md"
  echo "ğŸ“ Mise Ã  jour du statut: TODO â†’ IN_PROGRESS"
  
  mv "$task_file" "$new_task_file"
  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Impossible de changer le statut de la Task"
    git checkout -
    return 1
  fi

  # Mise Ã  jour du journal si activÃ©
  if [ "$auto_journal" = "true" ]; then
    update_journal "DÃ‰VELOPPEMENT" "DÃ©marrage dÃ©veloppement TDD TASK-${pbi_id}-${task_seq}" "Branche: $branch_name, Statut: TODO â†’ IN_PROGRESS" "TASK-${pbi_id}-${task_seq}-IN_PROGRESS.md"
  fi

  echo ""
  echo "âœ… Environnement de dÃ©veloppement TDD prÃ©parÃ© !"
  echo ""
  echo "ğŸ“‹ PLAN DE VOL DÃ‰VELOPPEMENT TDD"
  echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
  echo "ğŸ¯ Objectif: ImplÃ©menter TASK-${pbi_id}-${task_seq} selon mÃ©thodologie TDD"
  echo ""
  echo "ğŸ“ Fichiers:"
  echo "   â€¢ Task: $new_task_file"
  echo "   â€¢ Branche: $branch_name"
  echo "   â€¢ Statut: IN_PROGRESS"
  echo ""
  echo "ğŸ”„ Cycle TDD Ã  suivre:"
  echo "   1. ğŸ”´ RED:   Ã‰crire un test qui Ã©choue"
  echo "   2. ğŸŸ¢ GREEN: Ã‰crire le code minimum pour rÃ©ussir"
  echo "   3. ğŸ”µ BLUE:  Refactoriser et valider la qualitÃ©"
  echo "   4. â™»ï¸  ITÃ‰RER: RÃ©pÃ©ter jusqu'Ã  completion"
  echo ""
  echo "ğŸ“‹ Validation finale requise:"
  echo "   â€¢ Definition of Done complÃ¨tement cochÃ©e"
  echo "   â€¢ Tous les tests passent"
  echo "   â€¢ Linter et typage sans erreur"
  echo "   â€¢ Code review et approbation"
  echo ""
  echo "ğŸ¯ Prochaines Ã©tapes:"
  echo "   1. Lire la Task: cat '$new_task_file'"
  echo "   2. Identifier la premiÃ¨re fonctionnalitÃ© Ã  implÃ©menter"
  echo "   3. Commencer le cycle TDD"
  echo "   4. Utiliser 'aklo submit-task' quand terminÃ©"
  echo ""
  echo "ğŸ’¡ Conseils:"
  echo "   â€¢ Restez sur la branche $branch_name"
  echo "   â€¢ Commitez rÃ©guliÃ¨rement vos avancÃ©es"
  echo "   â€¢ Respectez les principes SOLID"
  echo "   â€¢ Documentez votre code (JSDoc/TSDoc)"
}

# Commande: debug - Diagnostic et correction de bugs
command_debug() {
  local title="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")
  
  case "$title" in
    "--help"|"help"|"")
      echo "Usage: aklo debug \"<titre du problÃ¨me>\""
      echo ""
      echo "Diagnostic et correction de bugs selon le protocole DEBOGAGE."
      echo ""
      echo "Arguments:"
      echo "  titre      Description du problÃ¨me Ã  diagnostiquer (requis)"
      echo ""
      echo "Options:"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo debug \"Login impossible avec utilisateur admin\""
      echo "  aklo debug \"Timeout API payment\" --no-agent"
      echo ""
      echo "Workflow:"
      echo "  1. CrÃ©ation du rapport DEBUG-[ID]-INVESTIGATING.md"
      echo "  2. Documentation du problÃ¨me et Ã©tapes de reproduction"
      echo "  3. Formulation d'hypothÃ¨ses initiales"
      echo "  4. Investigation itÃ©rative avec instrumentation"
      echo "  5. Analyse de la cause racine (root cause)"
      echo "  6. Plan de correction et validation"
      echo "  7. ImplÃ©mentation via protocole DÃ‰VELOPPEMENT"
      return 0
      ;;
    --no-agent)
      agent_assistance="skeleton"
      title="$2"
      ;;
    --no-journal)
      auto_journal="false"
      title="$2"
      ;;
  esac

  if [ -z "$title" ]; then
    echo "âŒ Erreur : Le titre du problÃ¨me est requis." >&2
    echo "Usage: aklo debug \"<titre du problÃ¨me>\""
    echo "Utilisez 'aklo debug --help' pour plus d'informations."
    return 1
  fi

  # GÃ©nÃ©ration de l'ID unique basÃ© sur le titre et la date
  local date_id=$(date +%Y%m%d)
  local title_slug=$(echo "$title" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g')
  local debug_id="${title_slug}-${date_id}"
  
  # PrÃ©paration des rÃ©pertoires
  local debug_dir="$(get_config "DEBUG_DIR" || echo "docs/backlog/03-debug")"
  
  # Assurer que le rÃ©pertoire existe (chemin absolu si besoin)
  if [ ! -d "$debug_dir" ]; then
    mkdir -p "$debug_dir" 2>/dev/null || true
  fi
  
  local debug_file="${debug_dir}/DEBUG-${debug_id}-INVESTIGATING.md"
  local today=$(date +%Y-%m-%d)
  
  # VÃ©rification si le rapport existe dÃ©jÃ 
  if [ -f "$debug_file" ]; then
    echo "âš ï¸  Un rapport de dÃ©bogage existe dÃ©jÃ  pour ce problÃ¨me :"
    echo "   ğŸ“ $debug_file"
    echo ""
    echo "Options :"
    echo "  1. Modifier le titre pour crÃ©er un nouveau rapport"
    echo "  2. Continuer avec le rapport existant"
    return 1
  fi

  echo "ğŸ› CrÃ©ation du rapport de dÃ©bogage DEBUG-${debug_id}"
  echo "ğŸ“ ProblÃ¨me: $title"
  
  # GÃ©nÃ©ration du rapport selon le niveau d'assistance
  generate_debug_from_protocol "$debug_file" "$debug_id" "$title" "$today" "$agent_assistance"
  
  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "DEBOGAGE" "Initialisation investigation DEBUG-${debug_id}" "ProblÃ¨me: $title" "DEBUG-${debug_id}-INVESTIGATING.md"
  fi

  echo ""
  echo "âœ… DEBUG-${debug_id}-INVESTIGATING.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $debug_file"
  echo ""
  echo "ğŸ” Prochaines Ã©tapes:"
  echo "  1. Documenter les Ã©tapes de reproduction"
  echo "  2. Formuler les hypothÃ¨ses initiales"
  echo "  3. Commencer l'investigation itÃ©rative"
  echo "  4. Identifier la cause racine"
  echo "  5. Proposer un plan de correction"
  echo "  6. ImplÃ©menter via 'aklo dev' aprÃ¨s validation"
}

# Commande: review - Revue de code assistÃ©e
command_review() {
  local target="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$target" in
    "--help"|"help"|"")
      echo "Usage: aklo review <TASK_ID|COMMIT|PR> [--checklist]"
      echo ""
      echo "Revue de code assistÃ©e selon le protocole REVUE-DE-CODE."
      echo ""
      echo "Arguments:"
      echo "  TASK_ID    ID de la task Ã  rÃ©viser (format: PBI_ID-TASK_ID, ex: 1-2)"
      echo "  COMMIT     Hash du commit Ã  rÃ©viser (ex: abc123f)"
      echo "  PR         NumÃ©ro de PR Ã  rÃ©viser (ex: pr-42)"
      echo ""
      echo "Options:"
      echo "  --checklist    Mode checklist dÃ©taillÃ©e pour validation"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo review 1-2              # RÃ©viser la Task 1-2"
      echo "  aklo review abc123f          # RÃ©viser un commit spÃ©cifique"
      echo "  aklo review pr-42            # RÃ©viser une Pull Request"
      echo "  aklo review 1-2 --checklist  # Mode checklist dÃ©taillÃ©e"
      echo ""
      echo "Workflow:"
      echo "  1. Analyse du diff de code"
      echo "  2. VÃ©rification conformitÃ© protocole DÃ‰VELOPPEMENT"
      echo "  3. Ã‰valuation principes SOLID et qualitÃ©"
      echo "  4. GÃ©nÃ©ration rapport REVIEW-[ID].md"
      echo "  5. Classification des observations (CRITICAL/MAJOR/MINOR)"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local checklist_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --checklist)
            checklist_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$target" ]; then
    echo "Erreur : Cible de revue requise (TASK_ID, COMMIT ou PR)." >&2
    echo "Utilisez 'aklo review --help' pour plus d'informations."
    exit 1
  fi

  # GÃ©nÃ©ration de l'ID de review
  REVIEW_DIR="./$(get_config "REVIEWS_DIR" || echo "docs/backlog/03-reviews")"
  mkdir -p "$REVIEW_DIR"

  # DÃ©terminer le type de cible et formater l'ID
  local review_id=""
  if [[ "$target" =~ ^[0-9]+-[0-9]+$ ]]; then
    # Format TASK_ID (ex: 1-2)
    review_id="task-${target}"
  elif [[ "$target" =~ ^pr-[0-9]+$ ]]; then
    # Format PR (ex: pr-42)
    review_id="$target"
  elif [[ "$target" =~ ^[a-f0-9]{6,40}$ ]]; then
    # Format commit hash
    review_id="commit-${target:0:7}"
  else
    # Format libre
    review_id="$target"
  fi

  REVIEW_FILE="${REVIEW_DIR}/REVIEW-${review_id}.md"
  TODAY=$(date +%Y-%m-%d)

  echo "ğŸ” CrÃ©ation de la revue REVIEW-${review_id} pour: $target"

  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole REVUE-DE-CODE..."
      generate_review_from_protocol "$REVIEW_FILE" "$review_id" "$target" "$TODAY" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_review_from_protocol "$REVIEW_FILE" "$review_id" "$target" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_review_from_protocol "$REVIEW_FILE" "$review_id" "$target" "$TODAY" "minimal"
      ;;
  esac

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "REVIEW" "Revue de code: $target" "REVIEW-${review_id}.md"
  fi

  echo ""
  echo "âœ… REVIEW-${review_id}.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $REVIEW_FILE"
  echo ""
  echo "ğŸ” Prochaines Ã©tapes:"
  echo "  1. Analyser le diff de code concernÃ©"
  echo "  2. Remplir la checklist de conformitÃ©"
  echo "  3. Documenter les observations par criticitÃ©"
  echo "  4. PrÃ©senter le rapport au dÃ©veloppeur"
  echo "  5. Fusionner aprÃ¨s corrections (aklo merge-task)"
}

# Commande: refactor - Refactoring sÃ©curisÃ© de code
command_refactor() {
  local scope="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$scope" in
    "--help"|"help"|"")
      echo "Usage: aklo refactor \"<description>\" [--safe]"
      echo ""
      echo "Refactoring sÃ©curisÃ© de code selon le protocole REFACTORING."
      echo ""
      echo "Arguments:"
      echo "  description  Description du refactoring Ã  effectuer (requis)"
      echo ""
      echo "Options:"
      echo "  --safe         Mode sÃ©curisÃ© avec validation continue"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo refactor \"Extraire logique mÃ©tier en service\""
      echo "  aklo refactor \"Simplifier fonction de validation\" --safe"
      echo "  aklo refactor \"RÃ©organiser structure des classes\""
      echo ""
      echo "Workflow:"
      echo "  1. Diagnostic du code smell et problÃ¨me identifiÃ©"
      echo "  2. StratÃ©gie de refactoring avec plan d'action"
      echo "  3. VÃ©rification couverture de tests (prÃ©requis)"
      echo "  4. ExÃ©cution par micro-changements avec validation"
      echo "  5. Preuve de non-rÃ©gression et finalisation"
      echo ""
      echo "Statuts:"
      echo "  ANALYSIS     - Diagnostic en cours"
      echo "  REFACTORING  - ExÃ©cution du plan approuvÃ©"
      echo "  DONE         - Refactoring terminÃ© et validÃ©"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local safe_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --safe)
            safe_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$scope" ]; then
    echo "Erreur : Description du refactoring requise." >&2
    echo "Utilisez 'aklo refactor --help' pour plus d'informations."
    exit 1
  fi

  # GÃ©nÃ©ration de l'ID de refactoring
  REFACTOR_DIR="./$(get_config "REFACTOR_DIR" || echo "docs/backlog/05-refactor")"
  mkdir -p "$REFACTOR_DIR"

  # GÃ©nÃ©rer l'ID selon le protocole (titre-slugifiÃ©-YYYYMMDD)
  refactor_id=$(detect_id_pattern "05-REFACTORING" "$scope")
  REFACTOR_FILE="${REFACTOR_DIR}/REFACTOR-${refactor_id}-ANALYSIS.md"
  TODAY=$(date +%Y-%m-%d)

  echo "ğŸ”§ CrÃ©ation du refactoring REFACTOR-${refactor_id}"
  echo "ğŸ“‹ Description: $scope"

  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole REFACTORING..."
      generate_refactor_from_protocol "$REFACTOR_FILE" "$refactor_id" "$scope" "$TODAY" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_refactor_from_protocol "$REFACTOR_FILE" "$refactor_id" "$scope" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_refactor_from_protocol "$REFACTOR_FILE" "$refactor_id" "$scope" "$TODAY" "minimal"
      ;;
  esac

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "REFACTOR" "Refactoring: $scope" "REFACTOR-${refactor_id}-ANALYSIS.md"
  fi

  echo ""
  echo "âœ… REFACTOR-${refactor_id}-ANALYSIS.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $REFACTOR_FILE"
  echo ""
  echo "ğŸ”§ Prochaines Ã©tapes:"
  echo "  1. Diagnostiquer le code smell identifiÃ©"
  echo "  2. DÃ©finir la stratÃ©gie et plan d'action"
  echo "  3. VÃ©rifier la couverture de tests (OBLIGATOIRE)"
  echo "  4. Soumettre le plan pour validation"
  echo "  5. ExÃ©cuter le refactoring par micro-changements"
  echo ""
  echo "âš ï¸  RAPPEL: La couverture de tests est un prÃ©requis non nÃ©gociable"
}

# Commande: hotfix - Correction d'urgence en production
command_hotfix() {
  local issue="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$issue" in
    "--help"|"help"|"")
      echo "Usage: aklo hotfix \"<description du bug critique>\" [--emergency]"
      echo ""
      echo "Correction d'urgence en production selon le protocole HOTFIX."
      echo ""
      echo "Arguments:"
      echo "  description  Description du bug critique en production (requis)"
      echo ""
      echo "Options:"
      echo "  --emergency    Mode urgence avec validation accÃ©lÃ©rÃ©e"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo hotfix \"Login impossible pour nouveaux utilisateurs\""
      echo "  aklo hotfix \"Panier d'achat inaccessible\" --emergency"
      echo "  aklo hotfix \"API payment timeout en production\""
      echo ""
      echo "Workflow d'urgence:"
      echo "  1. Validation de l'urgence rÃ©elle (production bloquÃ©e)"
      echo "  2. CrÃ©ation branche hotfix depuis tag de production"
      echo "  3. Diagnostic rapide de la cause racine"
      echo "  4. Correction minimale et ciblÃ©e"
      echo "  5. DÃ©ploiement d'urgence avec nouveau tag de patch"
      echo "  6. Planification post-mortem et synchronisation"
      echo ""
      echo "Statuts:"
      echo "  INVESTIGATING - Analyse cause racine en cours"
      echo "  AWAITING_FIX  - Plan de correction en attente de validation"
      echo "  DEPLOYING     - Correctif validÃ©, dÃ©ploiement en cours"
      echo "  RESOLVED      - Hotfix en production, post-mortem planifiÃ©"
      echo ""
      echo "âš ï¸  ATTENTION: RÃ©servÃ© aux bugs critiques bloquant la production"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local emergency_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --emergency)
            emergency_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$issue" ]; then
    echo "Erreur : Description du bug critique requise." >&2
    echo "Utilisez 'aklo hotfix --help' pour plus d'informations."
    exit 1
  fi

  # Validation de l'urgence
  echo "ğŸš¨ HOTFIX D'URGENCE DÃ‰TECTÃ‰"
  echo "ğŸ“‹ Bug critique: $issue"
  echo ""
  echo "âš ï¸  VALIDATION REQUISE:"
  echo "   Ce bug bloque-t-il rÃ©ellement la production ?"
  echo "   Cause-t-il une perte de revenus immÃ©diate ?"
  echo "   Les utilisateurs sont-ils impactÃ©s de maniÃ¨re critique ?"
  echo ""
  read -p "Confirmer l'urgence rÃ©elle (y/N): " confirm
  if [[ ! "$confirm" =~ ^[Yy]$ ]]; then
    echo "âŒ Hotfix annulÃ©. Utilisez 'aklo debug' pour un diagnostic normal."
    exit 1
  fi

  # GÃ©nÃ©ration de l'ID de hotfix
  HOTFIX_DIR="./$(get_config "HOTFIX_DIR" || echo "docs/backlog/08-hotfixes")"
  mkdir -p "$HOTFIX_DIR"

  # GÃ©nÃ©rer l'ID selon le protocole (description-slugifiÃ©e-YYYYMMDD)
  hotfix_id=$(detect_id_pattern "10-HOTFIX" "$issue")
  HOTFIX_FILE="${HOTFIX_DIR}/HOTFIX-${hotfix_id}.md"
  TODAY=$(date +%Y-%m-%d)
  TIME=$(date +%H:%M)

  echo ""
  echo "ğŸš¨ CrÃ©ation du hotfix HOTFIX-${hotfix_id}"
  echo "â° Urgence confirmÃ©e - ProcÃ©dure accÃ©lÃ©rÃ©e activÃ©e"

  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole HOTFIX..."
      generate_hotfix_from_protocol "$HOTFIX_FILE" "$hotfix_id" "$issue" "$TODAY" "$TIME" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_hotfix_from_protocol "$HOTFIX_FILE" "$hotfix_id" "$issue" "$TODAY" "$TIME" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_hotfix_from_protocol "$HOTFIX_FILE" "$hotfix_id" "$issue" "$TODAY" "$TIME" "minimal"
      ;;
  esac

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "HOTFIX" "URGENCE: $issue" "HOTFIX-${hotfix_id}.md"
  fi

  echo ""
  echo "âœ… HOTFIX-${hotfix_id}.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $HOTFIX_FILE"
  echo ""
  echo "ğŸš¨ PROCÃ‰DURE D'URGENCE - Prochaines Ã©tapes:"
  echo "  1. Identifier le tag de production actuellement dÃ©ployÃ©"
  echo "  2. CrÃ©er branche hotfix depuis ce tag"
  echo "  3. Diagnostiquer rapidement la cause racine"
  echo "  4. ImplÃ©menter la correction MINIMALE"
  echo "  5. DÃ©ployer d'urgence avec nouveau tag de patch"
  echo "  6. Planifier le post-mortem (PBI/TASK de correction dÃ©finitive)"
  echo ""
  echo "âš¡ RAPPEL: Correction minimale uniquement - Pas de refactoring !"
  echo "âš¡ RAPPEL: Planifier le post-mortem aprÃ¨s stabilisation"
}

# Commande: optimize - Optimisation de performance
command_optimize() {
  local scope="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$scope" in
    "--help"|"help"|"")
      echo "Usage: aklo optimize \"<objectif de performance>\" [--profile]"
      echo ""
      echo "Optimisation de performance selon le protocole OPTIMISATION."
      echo ""
      echo "Arguments:"
      echo "  objectif     Objectif de performance Ã  atteindre (requis)"
      echo ""
      echo "Options:"
      echo "  --profile      Mode profiling avec outils d'analyse"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo optimize \"RÃ©duire temps de rÃ©ponse API users < 100ms\""
      echo "  aklo optimize \"Optimiser consommation mÃ©moire < 512MB\" --profile"
      echo "  aklo optimize \"AccÃ©lÃ©rer rendu page d'accueil < 2s\""
      echo ""
      echo "Workflow scientifique:"
      echo "  1. DÃ©finition objectif de performance chiffrÃ©"
      echo "  2. Mise en place protocole de benchmark reproductible"
      echo "  3. Mesure initiale des performances (baseline)"
      echo "  4. Analyse scientifique du goulet d'Ã©tranglement"
      echo "  5. StratÃ©gie d'optimisation ciblÃ©e"
      echo "  6. ImplÃ©mentation et mesure finale"
      echo ""
      echo "Statuts:"
      echo "  BENCHMARKING - Mesure et analyse en cours"
      echo "  AWAITING_FIX - Solution proposÃ©e en attente de validation"
      echo "  DONE         - Optimisation implÃ©mentÃ©e et validÃ©e"
      echo ""
      echo "ğŸ”¬ PRINCIPE: Mesurer d'abord, optimiser ensuite"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local profile_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --profile)
            profile_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$scope" ]; then
    echo "Erreur : Objectif de performance requis." >&2
    echo "Utilisez 'aklo optimize --help' pour plus d'informations."
    exit 1
  fi

  # GÃ©nÃ©ration de l'ID d'optimisation
  OPTIM_DIR="./$(get_config "OPTIM_DIR" || echo "docs/backlog/06-optim")"
  mkdir -p "$OPTIM_DIR"

  # GÃ©nÃ©rer l'ID selon le protocole (description-slugifiÃ©e-YYYYMMDD)
  optim_id=$(detect_id_pattern "06-OPTIMISATION" "$scope")
  OPTIM_FILE="${OPTIM_DIR}/OPTIM-${optim_id}-BENCHMARKING.md"
  TODAY=$(date +%Y-%m-%d)

  echo "ğŸ”¬ CrÃ©ation de l'optimisation OPTIM-${optim_id}"
  echo "ğŸ¯ Objectif: $scope"

  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole OPTIMISATION..."
      generate_optim_from_protocol "$OPTIM_FILE" "$optim_id" "$scope" "$TODAY" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_optim_from_protocol "$OPTIM_FILE" "$optim_id" "$scope" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_optim_from_protocol "$OPTIM_FILE" "$optim_id" "$scope" "$TODAY" "minimal"
      ;;
  esac

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "OPTIM" "Optimisation: $scope" "OPTIM-${optim_id}-BENCHMARKING.md"
  fi

  echo ""
  echo "âœ… OPTIM-${optim_id}-BENCHMARKING.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $OPTIM_FILE"
  echo ""
  echo "ğŸ”¬ Prochaines Ã©tapes (mÃ©thode scientifique):"
  echo "  1. DÃ©finir la mÃ©trique ciblÃ©e avec objectif chiffrÃ©"
  echo "  2. Mettre en place un protocole de benchmark reproductible"
  echo "  3. Effectuer la mesure initiale (baseline)"
  echo "  4. Analyser scientifiquement le goulet d'Ã©tranglement"
  echo "  5. Proposer une stratÃ©gie d'optimisation ciblÃ©e"
  echo "  6. ImplÃ©menter et mesurer l'amÃ©lioration"
  echo ""
  echo "ğŸ“Š RAPPEL: Mesurer d'abord, optimiser ensuite !"
}

# Commande: security - Audit de sÃ©curitÃ©
command_security() {
  local scope="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$scope" in
    "--help"|"help"|"")
      echo "Usage: aklo security [<pÃ©rimÃ¨tre>] [--scan-only]"
      echo ""
      echo "Audit de sÃ©curitÃ© selon le protocole SECURITE-AUDIT."
      echo ""
      echo "Arguments:"
      echo "  pÃ©rimÃ¨tre    PÃ©rimÃ¨tre d'audit (optionnel, par dÃ©faut: complet)"
      echo ""
      echo "Options:"
      echo "  --scan-only    Mode scan uniquement (sans triage)"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo security                                # Audit complet"
      echo "  aklo security \"DÃ©pendances NPM\"              # Audit ciblÃ©"
      echo "  aklo security \"API d'authentification\" --scan-only"
      echo ""
      echo "Workflow d'audit:"
      echo "  1. Scan automatisÃ© avec outils de sÃ©curitÃ©"
      echo "  2. Triage et analyse manuelle des vulnÃ©rabilitÃ©s"
      echo "  3. Ã‰valuation de criticitÃ© et impact rÃ©el"
      echo "  4. Plan d'action avec tasks/PBI de correction"
      echo "  5. Validation et clÃ´ture de l'audit"
      echo ""
      echo "Statuts:"
      echo "  SCANNING  - Analyse automatisÃ©e en cours"
      echo "  TRIAGE    - Priorisation des vulnÃ©rabilitÃ©s"
      echo "  CONCLUDED - Audit terminÃ© avec plan d'action"
      echo ""
      echo "ğŸ”’ PRINCIPE: SÃ©curitÃ© proactive et systÃ©matique"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local scan_only=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --scan-only)
            scan_only=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  # GÃ©nÃ©ration de l'ID d'audit de sÃ©curitÃ©
  SECURITY_DIR="./$(get_config "SECURITY_DIR" || echo "docs/backlog/11-security")"
  mkdir -p "$SECURITY_DIR"

  # GÃ©nÃ©rer l'ID selon le protocole (YYYY-MM-DD)
  audit_id=$(detect_id_pattern "13-SECURITE-AUDIT" "audit")
  AUDIT_FILE="${SECURITY_DIR}/AUDIT-SECURITY-${audit_id}-SCANNING.md"
  TODAY=$(date +%Y-%m-%d)
  
  # DÃ©finir le pÃ©rimÃ¨tre par dÃ©faut
  if [ -z "$scope" ]; then
    scope="Audit de sÃ©curitÃ© complet"
  fi

  echo "ğŸ”’ CrÃ©ation de l'audit de sÃ©curitÃ© AUDIT-SECURITY-${audit_id}"
  echo "ğŸ¯ PÃ©rimÃ¨tre: $scope"

  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole SECURITE-AUDIT..."
      generate_security_from_protocol "$AUDIT_FILE" "$audit_id" "$scope" "$TODAY" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_security_from_protocol "$AUDIT_FILE" "$audit_id" "$scope" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_security_from_protocol "$AUDIT_FILE" "$audit_id" "$scope" "$TODAY" "minimal"
      ;;
  esac

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "SECURITY" "Audit de sÃ©curitÃ©: $scope" "AUDIT-SECURITY-${audit_id}-SCANNING.md"
  fi

  echo ""
  echo "âœ… AUDIT-SECURITY-${audit_id}-SCANNING.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $AUDIT_FILE"
  echo ""
  echo "ğŸ”’ Prochaines Ã©tapes (mÃ©thode systÃ©matique):"
  echo "  1. ExÃ©cuter les outils d'analyse de sÃ©curitÃ© automatisÃ©s"
  echo "  2. Compiler les rÃ©sultats bruts dans le rapport"
  echo "  3. Effectuer le triage et l'analyse manuelle"
  echo "  4. Ã‰valuer l'impact rÃ©el et assigner les criticitÃ©s"
  echo "  5. CrÃ©er le plan d'action avec tasks/PBI de correction"
  echo "  6. Valider et clÃ´turer l'audit"
  echo ""
  echo "ğŸ›¡ï¸ RAPPEL: SÃ©curitÃ© proactive et systÃ©matique !"
}

# Commande: diagnose - Diagnostic de l'environnement
command_diagnose() {
  local error_msg="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$error_msg" in
    "--help"|"help"|"")
      echo "Usage: aklo diagnose [\"<message d'erreur>\"] [--interactive]"
      echo ""
      echo "Diagnostic d'environnement selon le protocole DIAGNOSTIC-ENV."
      echo ""
      echo "Arguments:"
      echo "  erreur       Message d'erreur Ã  diagnostiquer (optionnel)"
      echo ""
      echo "Options:"
      echo "  --interactive  Mode interactif avec checklist guidÃ©e"
      echo "  --no-agent     Assistance minimale (liste seule)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo diagnose                                    # Diagnostic gÃ©nÃ©ral"
      echo "  aklo diagnose \"npm error Tracker already exists\" # Erreur spÃ©cifique"
      echo "  aklo diagnose \"Cannot find module 'X'\" --interactive"
      echo ""
      echo "ProcÃ©dure de diagnostic:"
      echo "  1. Halte et identification de l'erreur"
      echo "  2. Consultation du catalogue des erreurs connues"
      echo "  3. Application de la solution spÃ©cifique ou checklist gÃ©nÃ©rale"
      echo "  4. Validation et correction de l'environnement"
      echo ""
      echo "Erreurs cataloguÃ©es:"
      echo "  â€¢ npm error Tracker \"idealTree\" already exists"
      echo "  â€¢ 'npm' is not recognized as internal command"
      echo "  â€¢ Error: EPERM/EACCES permission denied"
      echo "  â€¢ Error: Cannot find module 'X'"
      echo ""
      echo "ğŸ”§ PRINCIPE: Diagnostic systÃ©matique avant correction"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local interactive_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --interactive)
            interactive_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  echo "ğŸ”§ DÃ©marrage du diagnostic d'environnement"
  if [ -n "$error_msg" ]; then
    echo "ğŸ¯ Erreur rapportÃ©e: $error_msg"
  else
    echo "ğŸ¯ Mode: Diagnostic gÃ©nÃ©ral de l'environnement"
  fi
  echo ""

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    local journal_msg="Diagnostic d'environnement"
    if [ -n "$error_msg" ]; then
      journal_msg="Diagnostic: $error_msg"
    fi
    update_journal "DIAGNOSE" "$journal_msg" "Diagnostic en cours"
  fi

  # Analyse de l'erreur selon le catalogue
  echo "ğŸ“‹ Ã‰TAPE 1: Identification et classification de l'erreur"
  echo ""
  
  local error_type="unknown"
  local solution_found=false

  if [ -n "$error_msg" ]; then
    # Catalogue des erreurs connues
    case "$error_msg" in
      *"idealTree"*"already exists"*)
        error_type="npm_tracker"
        solution_found=true
        echo "âœ… ERREUR CATALOGUÃ‰E: CAS NÂ°1 - npm error Tracker 'idealTree' already exists"
        echo ""
        echo "ğŸ” DIAGNOSTIC:"
        echo "   Conflit de processus npm ou exÃ©cution depuis un mauvais rÃ©pertoire (WORKDIR)"
        echo ""
        echo "ğŸ› ï¸ PROCÃ‰DURE DE RÃ‰SOLUTION:"
        echo "   1. VÃ©rifier qu'aucun autre processus npm n'est en cours"
        echo "   2. Forcer la re-validation du WORKDIR Ã  la racine du projet"
        echo "   3. ExÃ©cuter 'npm cache clean --force' depuis la racine"
        echo "   4. Relancer la commande initiale"
        ;;
      *"npm"*"not recognized"*|*"npm"*"command not found"*)
        error_type="npm_missing"
        solution_found=true
        echo "âœ… ERREUR CATALOGUÃ‰E: CAS NÂ°2 - 'npm' is not recognized"
        echo ""
        echo "ğŸ” DIAGNOSTIC:"
        echo "   ProblÃ¨me de variable d'environnement PATH. Node.js/npm non accessible"
        echo ""
        echo "ğŸ› ï¸ PROCÃ‰DURE DE RÃ‰SOLUTION:"
        echo "   âŒ LIMITATION: Ce problÃ¨me ne peut pas Ãªtre rÃ©solu par l'agent"
        echo "   ğŸ“ ACTION REQUISE: Informer le Human_Developer que l'environnement"
        echo "      d'exÃ©cution est mal configurÃ© et que la variable PATH doit Ãªtre inspectÃ©e"
        ;;
      *"EPERM"*|*"EACCES"*|*"permission denied"*)
        error_type="permission"
        solution_found=true
        echo "âœ… ERREUR CATALOGUÃ‰E: CAS NÂ°3 - Error: EPERM/EACCES permission denied"
        echo ""
        echo "ğŸ” DIAGNOSTIC:"
        echo "   Tentative d'Ã©criture/modification sans droits nÃ©cessaires"
        echo ""
        echo "ğŸ› ï¸ PROCÃ‰DURE DE RÃ‰SOLUTION:"
        echo "   1. Identifier prÃ©cisÃ©ment le fichier/dossier concernÃ©"
        echo "   ğŸ“ ACTION REQUISE: Informer le Human_Developer du problÃ¨me"
        echo "      de permission. Les permissions doivent Ãªtre ajustÃ©es manuellement"
        ;;
      *"Cannot find module"*)
        error_type="module_missing"
        solution_found=true
        echo "âœ… ERREUR CATALOGUÃ‰E: CAS NÂ°4 - Error: Cannot find module"
        echo ""
        echo "ğŸ” DIAGNOSTIC:"
        echo "   Commande lancÃ©e depuis un sous-rÃ©pertoire au lieu de la racine,"
        echo "   ou installation de dÃ©pendances corrompue"
        echo ""
        echo "ğŸ› ï¸ PROCÃ‰DURE DE RÃ‰SOLUTION:"
        echo "   1. Forcer la re-validation du WORKDIR Ã  la racine du projet"
        echo "   2. Relancer la commande depuis cette racine"
        echo "   3. Si l'erreur persiste: supprimer node_modules et package-lock.json"
        echo "   4. Relancer 'npm install' depuis la racine"
        ;;
    esac
  fi

  if [ "$solution_found" = false ]; then
    echo "â“ ERREUR NON CATALOGUÃ‰E - Application de la checklist gÃ©nÃ©rale"
    echo ""
    echo "ğŸ“‹ Ã‰TAPE 3: Checklist de diagnostic de base"
    echo ""
    echo "ğŸ” 1. VALIDATION DU RÃ‰PERTOIRE DE TRAVAIL (WORKDIR):"
    echo "   âš ï¸  Cause la plus frÃ©quente de problÃ¨mes"
    echo "   ğŸ“ RÃ©pertoire actuel: $(pwd)"
    echo "   âœ… VÃ©rifier que toutes les commandes sont lancÃ©es depuis la racine absolue du projet"
    echo ""
    echo "ğŸ” 2. VÃ‰RIFICATION DES PERMISSIONS:"
    if [ -n "$error_msg" ]; then
      if echo "$error_msg" | grep -q -E "(EPERM|EACCES|permission)"; then
        echo "   âŒ L'erreur indique un problÃ¨me de permission"
      else
        echo "   âœ… Aucun indicateur de problÃ¨me de permission dÃ©tectÃ©"
      fi
    else
      echo "   â“ VÃ©rifier les permissions sur les fichiers/dossiers critiques"
    fi
    echo ""
    echo "ğŸ” 3. Ã‰TAT DES DÃ‰PENDANCES:"
    if [ -n "$error_msg" ]; then
      if echo "$error_msg" | grep -q -E "(module|dependency|package)"; then
        echo "   âŒ L'erreur semble liÃ©e aux dÃ©pendances/modules"
      else
        echo "   âœ… Aucun indicateur de problÃ¨me de dÃ©pendances dÃ©tectÃ©"
      fi
    else
      echo "   â“ VÃ©rifier l'Ã©tat des node_modules et package-lock.json"
    fi
  fi

  echo ""
  echo "ğŸ“‹ Ã‰TAPE 4: Actions recommandÃ©es"
  echo ""

  case "$error_type" in
    "npm_tracker")
      echo "ğŸš€ ACTIONS IMMÃ‰DIATES:"
      echo "   1. VÃ©rifier les processus npm: ps aux | grep npm"
      echo "   2. Valider le WORKDIR: cd \$(git rev-parse --show-toplevel)"
      echo "   3. Nettoyer le cache: npm cache clean --force"
      echo "   4. Relancer la commande originale"
      ;;
    "npm_missing")
      echo "ğŸš¨ ESCALADE REQUISE:"
      echo "   Configuration d'environnement requise par l'administrateur systÃ¨me"
      ;;
    "permission")
      echo "ğŸš¨ ESCALADE REQUISE:"
      echo "   Ajustement des permissions requis par l'administrateur systÃ¨me"
      ;;
    "module_missing")
      echo "ğŸš€ ACTIONS IMMÃ‰DIATES:"
      echo "   1. Valider le WORKDIR: cd \$(git rev-parse --show-toplevel)"
      echo "   2. Relancer depuis la racine"
      echo "   3. Si Ã©chec: rm -rf node_modules package-lock.json"
      echo "   4. RÃ©installer: npm install"
      ;;
    "unknown")
      echo "ğŸ¤” DIAGNOSTIC MANUEL REQUIS:"
      echo "   1. Corriger le WORKDIR si nÃ©cessaire"
      echo "   2. VÃ©rifier les permissions sur les ressources critiques"
      echo "   3. VÃ©rifier l'Ã©tat des dÃ©pendances"
      echo "   4. PrÃ©senter les rÃ©sultats au Human_Developer"
      ;;
  esac

  echo ""
  echo "âœ… Diagnostic d'environnement terminÃ©"
  echo "ğŸ”§ RAPPEL: Diagnostic systÃ©matique avant correction !"
}

# Commande: experiment - Gestion d'expÃ©rimentation A/B
command_experiment() {
  local hypothesis="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$hypothesis" in
    "--help"|"help"|"")
      echo "Usage: aklo experiment \"<hypothÃ¨se>\" [--ab-test]"
      echo ""
      echo "Gestion d'expÃ©rimentation A/B selon le protocole EXPERIMENTATION."
      echo ""
      echo "Arguments:"
      echo "  hypothÃ¨se    HypothÃ¨se Ã  valider par expÃ©rimentation (requis)"
      echo ""
      echo "Options:"
      echo "  --ab-test      Mode A/B test complet avec mÃ©triques"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo experiment \"Bouton CTA rouge augmente conversion\""
      echo "  aklo experiment \"Nouveau onboarding rÃ©duit churn\" --ab-test"
      echo "  aklo experiment \"Feature X amÃ©liore engagement utilisateur\""
      echo ""
      echo "Workflow d'expÃ©rimentation:"
      echo "  1. Planification et dÃ©finition de l'hypothÃ¨se"
      echo "  2. ImplÃ©mentation technique (feature flags, tracking)"
      echo "  3. ExÃ©cution et monitoring des mÃ©triques"
      echo "  4. Analyse des rÃ©sultats et significativitÃ© statistique"
      echo "  5. DÃ©cision et clÃ´ture (gÃ©nÃ©raliser ou abandonner)"
      echo ""
      echo "Statuts:"
      echo "  PLANNING              - DÃ©finition hypothÃ¨se et mÃ©triques"
      echo "  AWAITING_IMPLEMENTATION - Plan validÃ©, en attente dev"
      echo "  RUNNING               - ExpÃ©rience en ligne collectant donnÃ©es"
      echo "  COMPLETED             - ExpÃ©rience terminÃ©e, en attente analyse"
      echo "  CONCLUDED             - Analyse terminÃ©e avec dÃ©cision prise"
      echo ""
      echo "ğŸ§ª PRINCIPE: Validation scientifique basÃ©e sur les donnÃ©es"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local ab_test_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --ab-test)
            ab_test_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$hypothesis" ]; then
    echo "Erreur : HypothÃ¨se d'expÃ©rimentation requise." >&2
    echo "Utilisez 'aklo experiment --help' pour plus d'informations."
    exit 1
  fi

  # GÃ©nÃ©ration de l'ID d'expÃ©rimentation
  EXPERIMENTS_DIR="./$(get_config "EXPERIMENTS_DIR" || echo "docs/backlog/09-experiments")"
  mkdir -p "$EXPERIMENTS_DIR"

  # GÃ©nÃ©rer l'ID selon le protocole (description-slugifiÃ©e-YYYYMMDD)
  experiment_id=$(detect_id_pattern "11-EXPERIMENTATION" "$hypothesis")
  EXPERIMENT_FILE="${EXPERIMENTS_DIR}/EXPERIMENT-${experiment_id}-PLANNING.md"
  TODAY=$(date +%Y-%m-%d)

  echo "ğŸ§ª CrÃ©ation de l'expÃ©rimentation EXPERIMENT-${experiment_id}"
  echo "ğŸ¯ HypothÃ¨se: $hypothesis"

  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole EXPERIMENTATION..."
      generate_experiment_from_protocol "$EXPERIMENT_FILE" "$experiment_id" "$hypothesis" "$TODAY" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_experiment_from_protocol "$EXPERIMENT_FILE" "$experiment_id" "$hypothesis" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_experiment_from_protocol "$EXPERIMENT_FILE" "$experiment_id" "$hypothesis" "$TODAY" "minimal"
      ;;
  esac

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "EXPERIMENT" "ExpÃ©rimentation: $hypothesis" "EXPERIMENT-${experiment_id}-PLANNING.md"
  fi

  echo ""
  echo "âœ… EXPERIMENT-${experiment_id}-PLANNING.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $EXPERIMENT_FILE"
  echo ""
  echo "ğŸ§ª Prochaines Ã©tapes (mÃ©thode scientifique):"
  echo "  1. DÃ©finir l'hypothÃ¨se avec critÃ¨res de succÃ¨s mesurables"
  echo "  2. Concevoir les variantes A (contrÃ´le) et B (test)"
  echo "  3. Planifier l'implÃ©mentation technique (feature flags, tracking)"
  echo "  4. Valider le plan avant implÃ©mentation"
  echo "  5. ExÃ©cuter l'expÃ©rience et monitorer les mÃ©triques"
  echo "  6. Analyser les rÃ©sultats avec significativitÃ© statistique"
  echo "  7. Prendre une dÃ©cision basÃ©e sur les donnÃ©es"
  echo ""
  echo "ğŸ“Š RAPPEL: Validation scientifique basÃ©e sur les donnÃ©es !"
}

# Commande: docs - Documentation utilisateur
command_docs() {
  local topic="$1"
  local agent_assistance=$(get_config "AGENT_ASSISTANCE" || echo "full")
  local auto_journal=$(get_config "AUTO_JOURNAL" || echo "true")

  case "$topic" in
    "--help"|"help"|"")
      echo "Usage: aklo docs \"<sujet de documentation>\" [--guide]"
      echo ""
      echo "Documentation utilisateur selon le protocole USER-DOCS."
      echo ""
      echo "Arguments:"
      echo "  sujet        Sujet de la documentation Ã  crÃ©er (requis)"
      echo ""
      echo "Options:"
      echo "  --guide        Mode guide utilisateur dÃ©taillÃ©"
      echo "  --no-agent     Assistance minimale (skeleton)"
      echo "  --no-journal   DÃ©sactiver la mise Ã  jour du journal"
      echo ""
      echo "Exemples:"
      echo "  aklo docs \"Nouvelle fonctionnalitÃ© de paiement\""
      echo "  aklo docs \"Guide d'utilisation avancÃ©e\" --guide"
      echo "  aklo docs \"FAQ mise Ã  jour limites de compte\""
      echo ""
      echo "Workflow de documentation:"
      echo "  1. Identification du besoin de documentation"
      echo "  2. RÃ©daction du contenu (plan et contenu brut)"
      echo "  3. Relecture et validation par Human_Developer"
      echo "  4. Publication sur la plateforme de documentation"
      echo ""
      echo "Statuts:"
      echo "  DRAFT           - RÃ©daction en cours"
      echo "  AWAITING_REVIEW - PrÃªt pour relecture et validation"
      echo "  PUBLISHED       - Documentation mise en ligne"
      echo ""
      echo "Audiences cibles:"
      echo "  â€¢ Nouveaux utilisateurs"
      echo "  â€¢ Administrateurs de compte"
      echo "  â€¢ Tous les utilisateurs"
      echo ""
      echo "ğŸ“š PRINCIPE: Documentation claire et synchronisÃ©e"
      exit 0
      ;;
    *)
      # Parsing des arguments
      shift
      local guide_mode=false
      while [ $# -gt 0 ]; do
        case "$1" in
          --guide)
            guide_mode=true
            ;;
          --no-agent)
            agent_assistance="skeleton"
            ;;
          --no-journal)
            auto_journal="false"
            ;;
          *)
            echo "Argument inconnu: $1" >&2
            exit 1
            ;;
        esac
        shift
      done
      ;;
  esac

  if [ -z "$topic" ]; then
    echo "Erreur : Sujet de documentation requis." >&2
    echo "Utilisez 'aklo docs --help' pour plus d'informations."
    exit 1
  fi

  # GÃ©nÃ©ration de l'ID de documentation
  USER_DOCS_DIR="./$(get_config "USER_DOCS_DIR" || echo "docs/backlog/14-user-docs")"
  mkdir -p "$USER_DOCS_DIR"

  # GÃ©nÃ©rer l'ID selon le protocole (description-slugifiÃ©e-YYYYMMDD)
  docs_id=$(detect_id_pattern "17-USER-DOCS" "$topic")
  DOCS_FILE="${USER_DOCS_DIR}/USER-DOCS-${docs_id}-DRAFT.md"
  TODAY=$(date +%Y-%m-%d)

  echo "ğŸ“š CrÃ©ation de la documentation USER-DOCS-${docs_id}"
  echo "ğŸ¯ Sujet: $topic"

  # GÃ©nÃ©ration du contenu selon le niveau d'assistance
  case "$agent_assistance" in
    "full")
      echo "ğŸ¤– GÃ©nÃ©ration complÃ¨te selon protocole USER-DOCS..."
      generate_docs_from_protocol "$DOCS_FILE" "$docs_id" "$topic" "$TODAY" "full"
      ;;
    "skeleton")
      echo "ğŸ“ Structure protocole Ã  complÃ©ter..."
      generate_docs_from_protocol "$DOCS_FILE" "$docs_id" "$topic" "$TODAY" "skeleton"
      ;;
    "minimal")
      echo "ğŸ”§ Structure minimale selon protocole..."
      generate_docs_from_protocol "$DOCS_FILE" "$docs_id" "$topic" "$TODAY" "minimal"
      ;;
  esac

  # Mise Ã  jour du journal si activÃ©e
  if [ "$auto_journal" = "true" ]; then
    update_journal "DOCS" "Documentation: $topic" "USER-DOCS-${docs_id}-DRAFT.md"
  fi

  echo ""
  echo "âœ… USER-DOCS-${docs_id}-DRAFT.md crÃ©Ã© avec succÃ¨s !"
  echo "ğŸ“ Fichier: $DOCS_FILE"
  echo ""
  echo "ğŸ“š Prochaines Ã©tapes (processus de documentation):"
  echo "  1. DÃ©finir l'objectif et l'audience cible de la documentation"
  echo "  2. Ã‰laborer le plan de contenu avec structure claire"
  echo "  3. RÃ©diger le contenu en langage simple et accessible"
  echo "  4. Soumettre pour relecture et validation"
  echo "  5. Publier sur la plateforme de documentation"
  echo ""
  echo "âœï¸ RAPPEL: Documentation claire et synchronisÃ©e !"
}

# Fonction de gÃ©nÃ©ration OPTIM - Parser dynamique du protocole OPTIMISATION
generate_debug_from_protocol() {
  local file="$1"
  local debug_id="$2"
  local title="$3"
  local date="$4"
  local assistance_level="$5"
  
  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="id=${debug_id},title=${title},date=${date},status=INVESTIGATING"
  
  # GÃ©nÃ©ration dynamique depuis le protocole
  parse_and_generate_artefact "04-DEBOGAGE" "DEBUG" "$assistance_level" "$file" "$context_vars"
  
  # Si le parser gÃ©nÃ©rique Ã©choue, afficher une erreur explicite
  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration DEBUG depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole DEBOGAGE" >&2
    return 1
  fi
}

# ===== FONCTION DEBUG STATIC_FALLBACK SUPPRIMÃ‰E =====
# La fonction generate_debug_static_fallback a Ã©tÃ© supprimÃ©e car remplacÃ©e
# par le parser gÃ©nÃ©rique dynamique.

generate_review_from_protocol() {
  local file="$1"
  local review_id="$2"
  local target="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="review_id:${review_id},target:${target},date:${date},status:PENDING"

  # Appel du parser gÃ©nÃ©rique
  parse_and_generate_artefact "07-REVUE-DE-CODE" "REVIEW" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration REVIEW depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole REVUE-DE-CODE" >&2
    return 1
  fi
}

generate_refactor_from_protocol() {
  local file="$1"
  local refactor_id="$2"
  local description="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="refactor_id:${refactor_id},description:${description},date:${date},status:ANALYSIS"

  # Appel du parser gÃ©nÃ©rique
  parse_and_generate_artefact "05-REFACTORING" "REFACTOR" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration REFACTOR depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole REFACTORING" >&2
    return 1
  fi
}

generate_hotfix_from_protocol() {
  local file="$1"
  local hotfix_id="$2"
  local issue="$3"
  local date="$4"
  local time="$5"
  local assistance_level="$6"

  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="hotfix_id:${hotfix_id},issue:${issue},date:${date},time:${time},status:INVESTIGATING"

  # Appel du parser gÃ©nÃ©rique
  parse_and_generate_artefact "10-HOTFIX" "HOTFIX" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration HOTFIX depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole HOTFIX" >&2
    return 1
  fi
}

generate_optim_from_protocol() {
  local file="$1"
  local optim_id="$2"
  local objective="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="optim_id:${optim_id},objective:${objective},date:${date},status:BENCHMARKING"

  # Appel du parser gÃ©nÃ©rique
  parse_and_generate_artefact "06-OPTIMISATION" "OPTIM" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration OPTIM depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole OPTIMISATION" >&2
    return 1
  fi
}

generate_security_from_protocol() {
  local file="$1"
  local audit_id="$2"
  local scope="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="audit_id:${audit_id},scope:${scope},date:${date},status:SCANNING"

  # Appel du parser gÃ©nÃ©rique
  parse_and_generate_artefact "13-SECURITE-AUDIT" "AUDIT" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration AUDIT depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole SECURITE-AUDIT" >&2
    return 1
  fi
}

generate_experiment_from_protocol() {
  local file="$1"
  local experiment_id="$2"
  local hypothesis="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="experiment_id:${experiment_id},hypothesis:${hypothesis},date:${date},status:PLANNING"

  # Appel du parser gÃ©nÃ©rique
  parse_and_generate_artefact "11-EXPERIMENTATION" "EXPERIMENT" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration EXPERIMENT depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole EXPERIMENTATION" >&2
    return 1
  fi
}

generate_docs_from_protocol() {
  local file="$1"
  local docs_id="$2"
  local topic="$3"
  local date="$4"
  local assistance_level="$5"

  # Variables contextuelles pour le parser gÃ©nÃ©rique
  local context_vars="docs_id:${docs_id},topic:${topic},date:${date},status:DRAFT"

  # Appel du parser gÃ©nÃ©rique
  parse_and_generate_artefact "17-USER-DOCS" "USER-DOCS" "$assistance_level" "$file" "$context_vars"

  if [ $? -ne 0 ]; then
    echo "âŒ Erreur : Ã‰chec de gÃ©nÃ©ration USER-DOCS depuis le protocole" >&2
    echo "   VÃ©rifiez l'intÃ©gritÃ© du protocole USER-DOCS" >&2
    return 1
  fi
}

#==============================================================================
# SECTION 5 : DISPATCH DES COMMANDES
#==============================================================================

# Fonction d'aide
show_help() {
  echo "ğŸ¤– Aklo Protocol - Interface UnifiÃ©e"
  echo ""
  echo "USAGE:"
  echo "  aklo <command> [options]"
  echo ""
  echo "ğŸ”§ COMMANDES SYSTÃˆME:"
  echo "  status [--brief|--detailed|--json]  Tableau de bord du projet"
  echo "  validate [path]                     Validation projet/artefacts"
  echo "  mcp setup|restart|watch             Gestion serveurs MCP"
  echo "  template list|create|apply          Gestion des templates"
  echo "  install-ux                          Installation amÃ©liorations UX"
  echo ""
  echo "ğŸš€ COMMANDES DÃ‰VELOPPEMENT:"
  echo "  propose-pbi \"<titre>\" [--template]  CrÃ©ation d'un Product Backlog Item"
  echo "  pbi \"<titre>\"                       Alias pour propose-pbi"
  echo "  plan <PBI_ID> [--no-agent]          Planification avec commit atomique"
  echo "  arch <PBI_ID> [--review]            Conception d'architecture logicielle"
  echo "  dev <TASK_ID> [--no-journal]        DÃ©veloppement TDD d'une Task"
  echo "  debug \"<titre>\" [--no-agent]        Diagnostic et correction de bugs"
  echo "  review <TASK_ID|COMMIT> [--checklist] Revue de code assistÃ©e"
  echo "  refactor \"<description>\" [--safe]   Refactoring sÃ©curisÃ© de code"
  echo "  hotfix \"<bug critique>\" [--emergency] Correction d'urgence production"
  echo "  optimize \"<objectif>\" [--profile]    Optimisation de performance"
  echo "  security [<pÃ©rimÃ¨tre>] [--scan-only] Audit de sÃ©curitÃ©"
  echo "  release <type> [--dry-run]          Release (major|minor|patch)"
  echo ""
  echo "ğŸ”§ COMMANDES QUALITÃ‰:"
  echo "  diagnose [\"<erreur>\"] [--interactive] Diagnostic d'environnement"
  echo "  experiment \"<hypothÃ¨se>\" [--ab-test] ExpÃ©rimentation A/B"
  echo "  docs \"<sujet>\" [--guide]            Documentation utilisateur"
  echo ""
  echo "ğŸ“š AIDE ET INFORMATION:"
  echo "  help                                Affiche cette aide"
  echo "  <command> --help                    Aide spÃ©cifique Ã  une commande"
  echo ""
  echo "ğŸ¯ NIVEAUX D'ASSISTANCE:"
  echo "  full      - GÃ©nÃ©ration complÃ¨te par l'IA (dÃ©faut)"
  echo "  skeleton  - Structure vide Ã  complÃ©ter (--no-agent)"
  echo "  minimal   - IDs uniquement (via .aklo.conf uniquement)"
  echo ""
  echo "âš™ï¸ CONFIGURATION:"
  echo "  .aklo.conf              Configuration locale du projet"
  echo "    agent_assistance=full|skeleton|minimal"
  echo "    auto_journal=true|false"
  echo ""
  echo "ğŸ“– EXEMPLES:"
  echo "  aklo status             # Tableau de bord complet"
  echo "  aklo mcp restart        # RedÃ©marrer les serveurs MCP"
  echo "  aklo plan 42            # Planifier le PBI 42"
  echo "  aklo dev 1-2            # DÃ©velopper la Task 1-2 en TDD"
  echo "  aklo validate           # Valider le projet"
  echo ""
  echo "ğŸ’¡ Astuce: Utilisez 'aklo <command> --help' pour l'aide dÃ©taillÃ©e."
}

# Dispatch principal
case "${1:-help}" in
  "plan")
    shift
    command_plan "$@"
    ;;
  "release")
    shift
    command_release "$@"
    ;;
  "status")
    shift
    command_status "$@"
    ;;
  "mcp")
    shift
    command_mcp "$@"
    ;;
  "validate")
    shift
    command_validate "$@"
    ;;
  "template")
    shift
    command_template "$@"
    ;;
  "install-ux")
    shift
    command_install_ux "$@"
    ;;
  "propose-pbi"|"pbi")
    shift
    command_propose_pbi "$@"
    ;;
  "arch")
    shift
    command_arch "$@"
    ;;
  "dev")
    shift
    command_dev "$@"
    ;;
  "debug")
    shift
    command_debug "$@"
    ;;
  "review")
    shift
    command_review "$@"
    ;;
  "refactor")
    shift
    command_refactor "$@"
    ;;
  "hotfix")
    shift
    command_hotfix "$@"
    ;;
  "optimize")
    shift
    command_optimize "$@"
    ;;
  "security")
    shift
    command_security "$@"
    ;;
  "diagnose")
    shift
    command_diagnose "$@"
    ;;
  "experiment")
    shift
    command_experiment "$@"
    ;;
  "docs")
    shift
    command_docs "$@"
    ;;
  "help"|"--help"|"-h")
    show_help
    ;;
  *)
    echo "Commande inconnue: $1"
    echo "Utilisez 'aklo help' pour voir les commandes disponibles."
    exit 1
    ;;
esac