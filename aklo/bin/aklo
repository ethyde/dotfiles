#!/bin/sh
#==============================================================================
# The Aklo Protocol - Main Script
#
# Auteur: Human_Developer & AI_Agent
# Version: 1.5 (Version consolid√©e et finale)
#
# Cet outil est l'ex√©cuteur des rituels d√©finis dans la Charte IA.
# Il automatise la cr√©ation d'artefacts, la gestion de Git et le cycle de
# vie des t√¢ches pour garantir une application stricte des protocoles.
#==============================================================================

# Configuration de base du Shell
# 'set -e' : Stoppe le script imm√©diatement si une commande √©choue.
set -e


#==============================================================================
# SECTION 1 : FONCTIONS UTILITAIRES (Bo√Æte √† outils interne)
#==============================================================================

# Fonction: get_next_id
# R√¥le: Trouve le plus grand ID num√©rique dans un nom de fichier et retourne le suivant.
#       Cette fonction est essentielle pour la cr√©ation incr√©mentale d'artefacts.
#
# Usage: get_next_id [CHEMIN_REPERTOIRE] [PREFIXE_FICHIER]
# Ex: get_next_id "docs/backlog/00-pbi" "PBI-"
#
get_next_id() {
  # Arguments de la fonction pour plus de lisibilit√©.
  SEARCH_PATH="$1"
  PREFIX="$2"

  # La commande est d√©compos√©e pour la clart√© :
  # 1. 'ls "${SEARCH_PATH}/${PREFIX}"*-*.md 2>/dev/null' : Liste les fichiers correspondant au pattern.
  #    '2>/dev/null' redirige les erreurs (ex: "aucun fichier trouv√©") vers le n√©ant pour √©viter les messages parasites.
  # 2. 'sed -n "s/.*${PREFIX}\([0-9]*\)-.*/\1/p"' : Extrait uniquement les chiffres qui se trouvent apr√®s le pr√©fixe.
  # 3. 'sort -n' : Trie les num√©ros extraits num√©riquement (et non alphab√©tiquement).
  # 4. 'tail -1' : Ne garde que la derni√®re ligne, qui est le num√©ro le plus √©lev√©.
  # 5. '|| echo 0' : C'est un garde-fou crucial. Si la commande 'ls' ou 'sed' √©choue (ex: r√©pertoire vide),
  #    cette partie s'ex√©cute et retourne "0" comme valeur par d√©faut.
  LAST_ID=$(ls "${SEARCH_PATH}/${PREFIX}"*-*.md 2>/dev/null | sed -n "s/.*${PREFIX}\([0-9]*\)-.*/\1/p" | sort -n | tail -1 || echo 0)
  
  # On incr√©mente simplement le dernier ID trouv√© pour obtenir le nouvel ID.
  NEXT_ID=$((LAST_ID + 1))
  
  # On retourne le r√©sultat.
  echo "$NEXT_ID"
}

# Fonction: get_artefact_header
# R√¥le: Extrait une valeur depuis l'en-t√™te d'un fichier artefact en se basant sur une cl√©.
#       Tr√®s utile pour rendre les artefacts "auto-descriptifs".
#
# Usage: get_artefact_header [FICHIER] [CLE_EN-TETE]
# Ex: get_artefact_header "docs/tasks/TASK-42-1.md" "Branche Git"
#
get_artefact_header() {
  # Arguments de la fonction pour plus de lisibilit√©.
  ARTEFACT_FILE="$1"
  HEADER_KEY="$2"

  # 'sed' est utilis√© ici pour sa capacit√© √† filtrer et transformer du texte.
  # -n : Supprime l'affichage par d√©faut de chaque ligne.
  # /.../s/.../.../p : C'est la commande de substitution de sed.
  #   - /^${HEADER_KEY}:/ : Ne s'applique qu'aux lignes qui commencent (^) par la cl√© recherch√©e.
  #   - s/^[^:]*: \`*\([^`]*\)\`*$/\1/ : C'est l'expression de remplacement.
  #     - s/.../.../ : Commande de substitution.
  #     - ^[^:]*: : Capture tout depuis le d√©but de la ligne jusqu'aux deux-points et l'espace.
  #     - Group capture : Il prend tout ce qui n'est pas un backtick,
  #       et est lui-m√™me entour√© de potentiels backticks.
  #     - /\1/ : Remplace toute la ligne par le contenu du premier groupe de capture.
  #   - p : Imprime la ligne si une substitution a eu lieu.
  sed -n "/^${HEADER_KEY}:/s/^[^:]*: \`*\([^\`]*\)\`*$/\1/p" "$ARTEFACT_FILE"
}

# Fonction: get_config (Version 2 - avec surcharge locale)
# R√¥le: Lit une valeur dans la configuration. Elle cherche d'abord un fichier
#       .aklo.conf √† la racine du projet courant pour des configurations
#       sp√©cifiques, et se rabat sur le fichier global dans les dotfiles
#       si aucune configuration locale n'est trouv√©e.
#
# Usage: get_config [CLE]
#
get_config() {
  KEY="$1"
  LOCAL_CONFIG_FILE="./.aklo.conf"
  GLOBAL_CONFIG_FILE="$(dirname "$0")/../config/.aklo.conf"

  # On cherche d'abord dans le fichier de configuration local au projet.
  if [ -f "$LOCAL_CONFIG_FILE" ]; then
    # 'grep' retourne la ligne si elle est trouv√©e.
    VALUE=$(grep "^${KEY}=" "$LOCAL_CONFIG_FILE" | cut -d'=' -f2)
    # Si une valeur a √©t√© trouv√©e, on la retourne et on arr√™te la fonction.
    if [ -n "$VALUE" ]; then
      echo "$VALUE"
      return
    fi
  fi

  # Si aucune valeur n'a √©t√© trouv√©e localement, on cherche dans le fichier global.
  if [ -f "$GLOBAL_CONFIG_FILE" ]; then
    grep "^${KEY}=" "$GLOBAL_CONFIG_FILE" | cut -d'=' -f2
  else
    echo "Erreur critique : Fichier de configuration global introuvable." >&2
    exit 1
  fi
}

# Fonction: get_current_version
# R√¥le: Lit la version actuelle du projet directement depuis le fichier package.json.
#       Cette fonction est un pr√©requis pour toute automatisation de release.
#
# Note: L'utilisation de 'sed' pour extraire des donn√©es d'un fichier JSON est
#       une simplification pour respecter notre contrainte de "z√©ro d√©pendance externe".
#       Dans un environnement avec 'jq', on l'utiliserait pour plus de robustesse.
#
get_current_version() {
  # On v√©rifie d'abord que le fichier package.json existe pour √©viter les erreurs.
  if [ ! -f "package.json" ]; then
    echo "Erreur : fichier package.json non trouv√©. Impossible de d√©terminer la version." >&2
    exit 1
  fi

  # La commande sed est utilis√©e pour trouver et extraire la version :
  # 1. '/"version":/ s/.../.../ p' : Ne s'applique qu'aux lignes contenant "version":
  # 2. 's/.*: *"\([^"]*\)".*/\1/' : Capture tout ce qui se trouve entre les guillemets
  #    apr√®s la cl√© "version" et les deux-points.
  #    - '.*: *"' : Trouve la cl√©, les deux-points et le guillemet ouvrant.
  #    - '\([^"]*\)' : C'est le groupe de capture. Il prend tous les caract√®res qui ne sont PAS un guillemet.
  #    - '".*/' : Capture la fin de la ligne.
  #    - /\1/ : Remplace toute la ligne par le contenu captur√© (le num√©ro de version).
  sed -n '/"version":/s/.*: *"\([^"]*\)".*/\1/p' package.json
}

# Fonction: bump_version
# R√¥le: Incr√©mente une version SemVer (M.m.p) en fonction du type de bump.
#       Cette fonction est le moteur logique de la commande 'aklo release'.
#
# Usage: bump_version "1.2.3" "minor" -> retourne "1.3.0"
#
bump_version() {
  # Arguments de la fonction pour plus de lisibilit√©.
  VERSION="$1"
  BUMP_TYPE="$2"

  # On utilise 'cut' pour s√©parer la cha√Æne de version en trois parties
  # en utilisant le point comme d√©limiteur (-d'.').
  # -f1 : premier champ (Major)
  # -f2 : deuxi√®me champ (Minor)
  # -f3 : troisi√®me champ (Patch)
  MAJOR=$(echo "$VERSION" | cut -d. -f1)
  MINOR=$(echo "$VERSION" | cut -d. -f2)
  PATCH=$(echo "$VERSION" | cut -d. -f3)

  # Le 'case' est la structure de contr√¥le parfaite pour g√©rer les
  # diff√©rents types d'incr√©mentation.
  case "$BUMP_TYPE" in
    "major")
      # Pour une release majeure, on incr√©mente le num√©ro majeur
      # et on r√©initialise les num√©ros mineur et patch √† 0.
      MAJOR=$((MAJOR + 1))
      MINOR=0
      PATCH=0
      ;;
    "minor")
      # Pour une release mineure, on incr√©mente le num√©ro mineur
      # et on r√©initialise le num√©ro de patch √† 0.
      MINOR=$((MINOR + 1))
      PATCH=0
      ;;
    "patch")
      # Pour un patch, on incr√©mente simplement le num√©ro de patch.
      PATCH=$((PATCH + 1))
      ;;
    *)
      # Cas par d√©faut si un argument invalide est fourni.
      echo "Erreur: type de bump invalide. Utilisez 'major', 'minor' ou 'patch'." >&2
      exit 1
      ;;
  esac

  # On reconstruit et retourne la nouvelle cha√Æne de version.
  echo "${MAJOR}.${MINOR}.${PATCH}"
}

# Fonction: get_latest_production_tag
# R√¥le: Trouve le dernier tag Git sur la branche de production.
#       Cette fonction est la pierre angulaire du protocole de HOTFIX,
#       car elle garantit que les corrections d'urgence partent d'une
#       base de code stable et connue.
#
get_latest_production_tag() {
  # On r√©cup√®re d'abord le nom de la branche de production depuis la configuration.
  PRODUCTION_BRANCH=$(get_config "PRODUCTION_BRANCH")

  # On utilise la commande 'git describe', qui est l'outil parfait pour cela.
  # --tags : Indique √† 'describe' de ne consid√©rer que les tags.
  # --abbrev=0 : Supprime le suffixe de hash du commit pour n'avoir que le nom du tag propre.
  # "${PRODUCTION_BRANCH}" : Sp√©cifie le point de d√©part de la recherche (la t√™te de la branche de prod).
  git describe --tags --abbrev=0 "${PRODUCTION_BRANCH}"
}

# Fonction: get_template_from_protocol
# R√¥le: Extrait une structure d'artefact directement depuis un fichier de protocole.
#       Elle rend le r√©pertoire de templates obsol√®te et garantit que les
#       artefacts g√©n√©r√©s sont TOUJOURS 100% conformes √† la Charte.
#
# Usage: get_template_from_protocol [CHEMIN_PROTOCOLE] [TITRE_DE_SECTION]
#
get_template_from_protocol() {
  # Arguments de la fonction pour plus de lisibilit√©.
  PROTOCOL_FILE="$1"
  SECTION_TITLE="$2"

  # 'awk' est utilis√© ici pour sa capacit√© √† traiter un fichier ligne par ligne
  # avec une logique conditionnelle, ce qui est parfait pour extraire un bloc de texte.
  #
  # -v title="$SECTION_TITLE" : passe une variable shell (le titre de la section)
  #                            dans le script awk pour qu'il puisse l'utiliser.
  #
  # Le script awk se lit comme suit :
  # 1. '$0 ~ title { in_section=1 }' : Si la ligne courante ('$0') contient le titre
  #                                    de la section, on active un drapeau 'in_section'.
  # 2. 'in_section && /```markdown/ { in_code_block=1; next }' : Si on est dans la bonne
  #                                    section ET qu'on trouve le d√©but du bloc de code (backtick-markdown),
  #                                    on active un second drapeau 'in_code_block' et on
  #                                    passe imm√©diatement √† la ligne suivante ('next').
  # 3. 'in_section && /```/ { in_code_block=0; in_section=0 }' : Si on trouve la balise
  #                                    de fin de bloc de code (backticks), on d√©sactive les deux drapeaux.
  # 4. 'in_code_block { print }' : Si le drapeau 'in_code_block' est actif, alors on
  #                                imprime la ligne courante.
  #
  awk -v title="$SECTION_TITLE" '
    $0 ~ title { in_section=1 }
    in_section && /^```markdown/ { in_code_block=1; next }
    in_section && /^```$/ { in_code_block=0; in_section=0 }
    in_code_block { print }
  ' "$PROTOCOL_FILE"
}

#==============================================================================
# SECTION 2 : COMMANDES (Les "Rituels" d'Aklo)
#==============================================================================

# Commande: init (Version 3, intelligente et compl√®te)
# R√¥le: Pr√©pare enti√®rement un projet pour l'utilisation d'Aklo.
#       1. Lie la Charte IA.
#       2. Cr√©e un fichier de configuration local .aklo.conf.
#       3. Pr√©-remplit le PROJECT_WORKDIR avec le chemin actuel.
#       4. Configure .gitignore pour ignorer ces deux √©l√©ments.
#
command_init() {
  # --- D√©claration des variables ---
  AKLO_CHARTE_PATH="$(dirname "$(readlink -f "$0")")/../charte"
  TARGET_CHARTE_PATH="./docs/CHARTE_IA"
  LOCAL_CONFIG_FILE="./.aklo.conf"
  GITIGNORE_FILE="./.gitignore"
  IGNORE_ENTRY_CHARTE="docs/CHARTE_IA"
  IGNORE_ENTRY_CONFIG=".aklo.conf"

  # --- √âtape 1 : V√©rifications Pr√©liminaires ---
  if [ -e "$TARGET_CHARTE_PATH" ] || [ -f "$LOCAL_CONFIG_FILE" ]; then
    echo "Warning: Aklo seems to be already initiated in this project." >&2
    exit 1
  fi

  # --- √âtape 2 : Confirmation de l'Utilisateur ---
  echo "This ritual will fully prepare your project for the Aklo Protocol:"
  echo "  1. Link the central Charte IA into './docs/CHARTE_IA'."
  echo "  2. Create a local '.aklo.conf' file."
  echo "  3. Automatically set 'PROJECT_WORKDIR' in this new file."
  echo "  4. Update '.gitignore' to ignore both elements."
  printf "\nProceed? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then echo "Invocation aborted."; exit 0; fi
  echo ""

  # --- √âtape 3 : Cr√©ation du Lien Symbolique et Mise √† Jour du .gitignore ---
  echo "‚Ä∫ Linking the Charte..."
  mkdir -p ./docs
  ln -s "$AKLO_CHARTE_PATH" "$TARGET_CHARTE_PATH"
  touch "$GITIGNORE_FILE"
  if ! grep -q "^${IGNORE_ENTRY_CHARTE}$" "$GITIGNORE_FILE"; then
    echo "\n# Ignore the Aklo Protocol Charte linked locally" >> "$GITIGNORE_FILE"
    echo "${IGNORE_ENTRY_CHARTE}" >> "$GITIGNORE_FILE"
  fi
  echo "  ‚úÖ Charte linked and ignored."

  # --- √âtape 4 : Cr√©ation du Fichier de Configuration Local ---
  echo "‚Ä∫ Creating local configuration file..."
  touch "$LOCAL_CONFIG_FILE"
  if ! grep -q "^${IGNORE_ENTRY_CONFIG}$" "$GITIGNORE_FILE"; then
    echo "\n# Ignore project-specific Aklo configuration" >> "$GITIGNORE_FILE"
    echo "${IGNORE_ENTRY_CONFIG}" >> "$GITIGNORE_FILE"
  fi
  echo "  ‚úÖ .aklo.conf created and ignored."

  # --- √âtape 5 : Pr√©-remplissage du WORKDIR ---
  echo "‚Ä∫ Setting project working directory..."
  # 'pwd' r√©cup√®re le chemin absolu du r√©pertoire courant.
  CURRENT_WORKDIR=$(pwd)
  # On √©crit la configuration directement dans le fichier local.
  echo "# Auto-generated by 'aklo init'" > "$LOCAL_CONFIG_FILE"
  echo "PROJECT_WORKDIR=${CURRENT_WORKDIR}" >> "$LOCAL_CONFIG_FILE"
  echo "  ‚úÖ PROJECT_WORKDIR set to: ${CURRENT_WORKDIR}"

  # --- √âtape 6 : Message de Fin ---
  echo ""
  echo "üéâ Aklo Protocol is now fully initiated. Your project is ready."
  echo "You can now use other Aklo commands like 'aklo propose-pbi'."
}

# Commande: propose-pbi
# R√¥le: Cr√©e un nouvel artefact Product Backlog Item en lisant sa structure
#       directement depuis le protocole 00-PRODUCT-OWNER.md.
#
# Usage: aklo propose-pbi "<titre du pbi>"
#
command_propose_pbi() {
  # --- √âtape 1 : V√©rification de l'environnement ---
  # On s'assure que le projet a bien √©t√© initialis√© avec 'aklo init'.
  # La pr√©sence du lien symbolique est notre indicateur.
  if [ ! -L "./docs/CHARTE_IA" ]; then
      echo "Erreur : Aklo n'est pas initialis√© dans ce projet." >&2
      echo "Veuillez lancer 'aklo init' avant toute autre commande." >&2
      exit 1
  fi
  # On v√©rifie que l'utilisateur a bien fourni un titre pour le PBI.
  if [ -z "$1" ]; then
    echo "Erreur : Le titre du PBI est requis." >&2
    echo "Usage: aklo propose-pbi \"<titre du pbi>\"" >&2
    exit 1
  fi
  
  # --- √âtape 2 : Assignation des variables ---
  PBI_TITLE="$1"
  # Le chemin vers le r√©pertoire des PBI
  PBI_PATH="./docs/backlog/00-pbi"
  # On appelle notre fonction utilitaire pour obtenir un nouvel ID unique.
  PBI_ID=$(get_next_id "$PBI_PATH" "PBI-")
  # On construit le nom de fichier final.
  FILENAME="${PBI_PATH}/PBI-${PBI_ID}-PROPOSED.md"
  
  # --- √âtape 3 : Extraction du Template depuis la Charte ---
  # 1. On d√©finit le chemin vers le protocole source et le titre de la section √† trouver.
  PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/00-PRODUCT-OWNER.md"
  SECTION_TO_EXTRACT="Structure Obligatoire Du Fichier PBI"

  # 2. On appelle notre fonction 'get_template_from_protocol' pour extraire le template brut.
  echo "‚Ä∫ Lecture de la structure depuis le protocole ${PROTOCOL_FILE}..."
  RAW_TEMPLATE=$(get_template_from_protocol "$PROTOCOL_FILE" "$SECTION_TO_EXTRACT")

  # On v√©rifie que l'extraction a bien fonctionn√©.
  if [ -z "$RAW_TEMPLATE" ]; then
    echo "Erreur : Impossible d'extraire la structure depuis le protocole." >&2
    echo "V√©rifiez que la section '${SECTION_TO_EXTRACT}' existe et est correctement format√©e." >&2
    exit 1
  fi

  # --- √âtape 4 : Cr√©ation de l'Artefact ---
  echo "‚Ä∫ Cr√©ation de l'artefact..."
  # Cr√©er le r√©pertoire parent s'il n'existe pas
  mkdir -p "$(dirname "$FILENAME")"
  # On utilise 'sed' pour remplacer les placeholders s√©mantiques (ex: [ID])
  # par les valeurs r√©elles directement. Les expressions r√©guli√®res sont
  # √©chapp√©es (\[, \]) pour correspondre aux crochets litt√©raux.
  echo "$RAW_TEMPLATE" | \
    sed -e "s/%%ID%%/${PBI_ID}/g" \
        -e "s/%%TITLE%%/${PBI_TITLE}/g" \
        -e "s/\[ID\]/${PBI_ID}/g" \
        -e "s/\$(date +'%Y-%m-%d')/$(date +'%Y-%m-%d')/g" > "$FILENAME"
  
  echo "‚úÖ Artefact cr√©√© : ${FILENAME}"
}

# Commande: plan
# R√¥le: D√©compose un PBI en une ou plusieurs t√¢ches de mani√®re interactive,
#       en lisant la structure des t√¢ches directement depuis le protocole de planification.
#
# Usage: aklo plan <PBI_ID>
#
command_plan() {
  # --- √âtape 1 : Validation des arguments ---
  if [ -z "$1" ]; then
    echo "Erreur : L'ID du PBI est requis (ex: 42)." >&2
    exit 1
  fi
  PBI_ID="$1"

  # On trouve le fichier PBI, quel que soit son statut (PROPOSED, AGREED, etc.)
  # en utilisant un glob (*).
  PBI_FILE=$(ls ./docs/CHARTE_IA/../backlog/00-pbi/PBI-${PBI_ID}-*.md 2>/dev/null)
  if [ ! -f "$PBI_FILE" ]; then
    echo "Erreur : Impossible de trouver le PBI ${PBI_ID}." >&2
    exit 1
  fi

  # --- √âtape 2 : Boucle de Cr√©ation Interactive ---
  echo "--- Planification des t√¢ches pour le PBI-${PBI_ID} ---"
  echo "Entrez le titre de chaque t√¢che. Laissez vide et appuyez sur Entr√©e pour terminer."
  
  # On entre dans une boucle infinie 'while true' qui ne sera rompue
  # que lorsque l'utilisateur entrera une ligne vide.
  while true; do
    # 'printf' est utilis√© pour un affichage propre sans retour √† la ligne.
    # 'read' stocke l'entr√©e de l'utilisateur dans la variable TASK_TITLE.
    printf "  ‚Ä∫ Titre de la nouvelle t√¢che : "
    read -r TASK_TITLE
    
    # Si l'utilisateur n'a rien tap√©, on sort de la boucle avec 'break'.
    if [ -z "$TASK_TITLE" ]; then
      break
    fi

    # --- √âtape 2a : Pr√©paration des variables pour la nouvelle t√¢che ---
    TASK_PATH="./docs/CHARTE_IA/../backlog/01-tasks"
    TASK_PREFIX="TASK-${PBI_ID}-"
    # On obtient un nouvel ID de t√¢che unique DANS LE SCOPE du PBI parent.
    TASK_ID=$(get_next_id "$TASK_PATH" "$TASK_PREFIX")
    TASK_FILENAME="${TASK_PATH}/${TASK_PREFIX}${TASK_ID}-TODO.md"
    
    # --- √âtape 2b : Extraction du template de t√¢che ---
    PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/01-PLANIFICATION.md"
    SECTION_TO_EXTRACT="Structure Obligatoire Du Fichier Task"
    RAW_TEMPLATE=$(get_template_from_protocol "$PROTOCOL_FILE" "$SECTION_TO_EXTRACT")
    if [ -z "$RAW_TEMPLATE" ]; then
        echo "Erreur : Impossible d'extraire la structure de la T√¢che depuis le protocole." >&2
        # On ne quitte pas, on permet de continuer √† cr√©er d'autres t√¢ches.
        continue
    fi
    
    # --- √âtape 2c : Cr√©ation de l'artefact TASK ---
    # On remplace tous les placeholders du template avec les bonnes valeurs.
    echo "$RAW_TEMPLATE" | \
      sed -e "s/\[PBI_ID\]/${PBI_ID}/g" \
          -e "s/\[Task_ID\]/${TASK_ID}/g" \
          -e "s/\[Titre technique de la t√¢che\]/${TASK_TITLE}/g" > "$TASK_FILENAME"
    
    # --- √âtape 2d : Mise √† jour du PBI parent ---
    # On ajoute un lien vers la t√¢che nouvellement cr√©√©e dans la section "Tasks Associ√©es" du PBI.
    # '${TASK_FILENAME#./}' retire le './' du d√©but pour un lien plus propre.
    echo "- [ ] [${TASK_PREFIX}${TASK_ID}](${TASK_FILENAME#./})" >> "$PBI_FILE"

    echo "    ‚úÖ T√¢che ${TASK_PREFIX}${TASK_ID} cr√©√©e."
  done

  echo "Planification termin√©e pour le PBI-${PBI_ID}."
}

# Commande: start-task
# R√¥le: Pr√©pare l'environnement pour commencer √† travailler sur une t√¢che.
#       Elle cr√©e la branche, se synchronise, et met √† jour le statut de la t√¢che.
#
# Usage: aklo start-task <ID_de_la_tache>
# Ex: aklo start-task 42-1
#
command_start_task() {
  # --- √âtape 1 : Validation des arguments ---
  if [ -z "$1" ]; then
    echo "Erreur : L'ID de la TASK est requis (ex: 42-1)." >&2
    exit 1
  fi
  TASK_FULL_ID="$1"

  # --- √âtape 2 : Localisation de l'artefact ---
  # On cherche le fichier de la t√¢che qui correspond √† l'ID fourni ET
  # qui a le statut 'TODO'. C'est une s√©curit√© pour ne pas d√©marrer
  # une t√¢che d√©j√† en cours ou termin√©e.
  TASK_FILE=$(ls ./docs/CHARTE_IA/../backlog/01-tasks/TASK-${TASK_FULL_ID}-TODO.md 2>/dev/null)
  if [ ! -f "$TASK_FILE" ]; then
    echo "Erreur : Impossible de trouver la TASK ${TASK_FULL_ID} avec le statut TODO." >&2
    exit 1
  fi

  echo "--- Activation du protocole [DEVELOPPEMENT] pour la t√¢che ${TASK_FULL_ID} ---"
  
  # --- √âtape 3 : Lecture des configurations ---
  # On utilise nos fonctions utilitaires pour r√©cup√©rer les informations
  # n√©cessaires depuis la configuration et l'artefact lui-m√™me.
  MAIN_BRANCH=$(get_config "MAIN_BRANCH")
  TASK_BRANCH=$(get_artefact_header "$TASK_FILE" "Branche Git")
  
  # S√©curit√© suppl√©mentaire : on v√©rifie que les informations ont bien √©t√© trouv√©es.
  if [ -z "$MAIN_BRANCH" ] || [ -z "$TASK_BRANCH" ]; then
    echo "Erreur : Impossible de lire la branche principale ou la branche de la t√¢che." >&2
    echo "V√©rifiez project.conf et l'en-t√™te de la TASK." >&2
    exit 1
  fi
  
  # --- √âtape 4 : Ex√©cution des op√©rations Git ---
  echo "‚Ä∫ Pr√©paration de l'environnement Git..."
  # 1. On se place sur la branche principale pour √™tre s√ªr de partir d'une base saine.
  git checkout "$MAIN_BRANCH"
  # 2. On la met √† jour avec les derniers changements du d√©p√¥t distant.
  git pull
  # 3. On cr√©e la nouvelle branche de fonctionnalit√©.
  git checkout -b "$TASK_BRANCH"
  
  # --- √âtape 5 : Mise √† jour du statut de l'artefact ---
  echo "‚Ä∫ Mise √† jour du statut de l'artefact de TODO √† IN_PROGRESS..."
  # On construit le nouveau nom de fichier en rempla√ßant le statut.
  NEW_TASK_FILE=$(echo "$TASK_FILE" | sed 's/TODO\.md$/IN_PROGRESS.md/')
  # On renomme le fichier, ce qui acte le changement de statut.
  mv "$TASK_FILE" "$NEW_TASK_FILE"
  
  echo ""
  echo "‚úÖ Environnement pr√™t. Vous √™tes sur la branche '${TASK_BRANCH}'."
  echo "Bon d√©veloppement !"
}

# Commande: submit-task
# R√¥le: Finalise le d√©veloppement d'une t√¢che, la commite, la pousse sur le
#       d√©p√¥t distant et la soumet officiellement pour revue.
#
# Usage: aklo submit-task
#        (La commande est intelligente et ne n√©cessite pas d'argument)
#
command_submit_task() {
  # --- √âtape 1 : D√©tection du Contexte ---
  # On d√©tecte la branche Git actuelle pour en d√©duire la t√¢che en cours.
  # 'git rev-parse --abbrev-ref HEAD' est la commande standard pour cela.
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  
  # On extrait l'ID de la t√¢che depuis le nom de la branche en utilisant sed.
  # Ex: 'feature/task-42-1-nouveau-bouton' -> '42-1'
  TASK_FULL_ID=$(echo "$CURRENT_BRANCH" | sed -n 's/.*task-\([0-9-]*\).*/\1/p')
  
  # Si l'ID n'a pas pu √™tre extrait, on est probablement pas sur une branche de t√¢che.
  if [ -z "$TASK_FULL_ID" ]; then
    echo "Erreur : Impossible de d√©tecter l'ID de la t√¢che depuis la branche actuelle." >&2
    echo "Assurez-vous d'√™tre sur une branche de feature (ex: feature/task-42-1)." >&2
    exit 1
  fi
  
  # --- √âtape 2 : Localisation de l'Artefact ---
  # On cherche la t√¢che correspondante qui a le statut 'IN_PROGRESS'.
  TASK_FILE=$(ls ./docs/CHARTE_IA/../backlog/01-tasks/TASK-${TASK_FULL_ID}-IN_PROGRESS.md 2>/dev/null)
  if [ ! -f "$TASK_FILE" ]; then
    echo "Erreur : Impossible de trouver la TASK ${TASK_FULL_ID} avec le statut IN_PROGRESS." >&2
    exit 1
  fi

  echo "--- Activation du protocole [REVUE DE CODE] pour la t√¢che ${TASK_FULL_ID} ---"
  
  # --- √âtape 3 : Pr√©paration du Commit ---
  # On extrait le titre de la t√¢che pour pr√©-remplir le message de commit.
  TASK_TITLE=$(get_artefact_header "$TASK_FILE" "TASK-${TASK_FULL_ID}")
  # On formate un message de commit s√©mantique (convention 'feat:' pour une nouvelle fonctionnalit√©).
  COMMIT_MSG="feat: ${TASK_TITLE}"

  # On demande confirmation √† l'utilisateur avant d'effectuer des op√©rations Git.
  printf "Message de commit propos√© : '%s'\n" "$COMMIT_MSG"
  printf "Validez-vous ce commit et la soumission de la t√¢che ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Soumission annul√©e."
    exit 0
  fi
  
  # --- √âtape 4 : Ex√©cution des Op√©rations Git ---
  echo "‚Ä∫ Pr√©paration du commit et envoi sur le d√©p√¥t distant..."
  # 1. Ajoute tous les fichiers modifi√©s √† l'index.
  git add .
  # 2. Cr√©e le commit avec le message pr√©-format√©.
  git commit -m "$COMMIT_MSG"
  # 3. Pousse la branche sur le d√©p√¥t distant ('origin').
  #    '--set-upstream' √©tablit le lien de suivi pour la branche.
  git push --set-upstream origin "$CURRENT_BRANCH"
  
  # --- √âtape 5 : Mise √† jour du Statut ---
  echo "‚Ä∫ Mise √† jour du statut de l'artefact de IN_PROGRESS √† AWAITING_REVIEW..."
  NEW_TASK_FILE=$(echo "$TASK_FILE" | sed 's/IN_PROGRESS\.md$/AWAITING_REVIEW.md/')
  mv "$TASK_FILE" "$NEW_TASK_FILE"
  
  echo ""
  echo "‚úÖ T√¢che soumise pour revue."
  echo "   Vous pouvez maintenant cr√©er votre Pull/Merge Request sur la plateforme Git."
}

# Commande: merge-task
# R√¥le: Fusionne une branche de t√¢che valid√©e dans la branche de d√©veloppement principale.
#       Cette commande finalise le cycle de vie d'une t√¢che en nettoyant les branches
#       et en archivant l'artefact.
#
# Usage: aklo merge-task <ID_de_la_tache>
# Ex: aklo merge-task 42-1
#
command_merge_task() {
  # --- √âtape 1 : Validation des arguments ---
  if [ -z "$1" ]; then
    echo "Erreur : L'ID de la TASK est requis (ex: 42-1)." >&2
    exit 1
  fi
  TASK_FULL_ID="$1"

  # --- √âtape 2 : Localisation de l'artefact ---
  # On cherche la t√¢che correspondante qui a le statut 'AWAITING_REVIEW'.
  TASK_FILE=$(ls ./docs/CHARTE_IA/../backlog/01-tasks/TASK-${TASK_FULL_ID}-AWAITING_REVIEW.md 2>/dev/null)
  if [ ! -f "$TASK_FILE" ]; then
    echo "Erreur : Impossible de trouver la TASK ${TASK_FULL_ID} avec le statut AWAITING_REVIEW." >&2
    exit 1
  fi

  # --- √âtape 3 : Lecture des configurations et Confirmation ---
  MAIN_BRANCH=$(get_config "MAIN_BRANCH")
  TASK_BRANCH=$(get_artefact_header "$TASK_FILE" "Branche Git")

  echo "--- Fusion de la t√¢che ${TASK_FULL_ID} ---"
  printf "La branche '%s' va √™tre fusionn√©e dans '%s' et supprim√©e.\n" "$TASK_BRANCH" "$MAIN_BRANCH"
  printf "Cette action est irr√©versible. Continuer ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Fusion annul√©e."
    exit 0
  fi

  # --- √âtape 4 : Ex√©cution de la s√©quence Git ---
  echo "‚Ä∫ Synchronisation de la branche principale..."
  # 1. On se place sur la branche principale.
  git checkout "$MAIN_BRANCH"
  # 2. On la met √† jour.
  git pull origin "$MAIN_BRANCH"

  echo "‚Ä∫ Fusion de la branche de la t√¢che..."
  # 3. On fusionne. '--no-ff' cr√©e un commit de merge explicite, ce qui
  #    garde l'historique de Git plus lisible en montrant clairement d'o√π vient la fonctionnalit√©.
  git merge --no-ff "$TASK_BRANCH"
  # 4. On pousse la branche principale mise √† jour.
  git push origin "$MAIN_BRANCH"

  echo "‚Ä∫ Nettoyage des branches..."
  # 5. On supprime la branche de fonctionnalit√© sur la machine locale.
  git branch -d "$TASK_BRANCH"
  # 6. On supprime la branche de fonctionnalit√© sur le d√©p√¥t distant ('origin').
  git push origin --delete "$TASK_BRANCH"

  # --- √âtape 5 : Mise √† jour du statut de l'artefact ---
  echo "‚Ä∫ Mise √† jour du statut de l'artefact de AWAITING_REVIEW √† DONE..."
  NEW_TASK_FILE=$(echo "$TASK_FILE" | sed 's/AWAITING_REVIEW\.md$/DONE.md/')
  mv "$TASK_FILE" "$NEW_TASK_FILE"

  echo ""
  echo "‚úÖ T√¢che ${TASK_FULL_ID} fusionn√©e et archiv√©e avec succ√®s."
}

# Commande: release
# R√¥le: Orchestre le processus complet de cr√©ation d'une nouvelle release.
#       Elle g√®re le versioning, les branches, les fusions et le tagging.
#
# Usage: aklo release <major|minor|patch>
#
command_release() {
  # --- √âtape 1 : Validation des arguments ---
  if [ -z "$1" ]; then
    echo "Erreur : Le type de release est requis (major, minor, patch)." >&2
    exit 1
  fi
  BUMP_TYPE="$1"

  echo "--- Lancement du rituel de RELEASE ---"
  
  # --- √âtape 2: D√©termination des versions ---
  # On utilise nos fonctions utilitaires pour obtenir les informations de version.
  CURRENT_VERSION=$(get_current_version)
  NEW_VERSION=$(bump_version "$CURRENT_VERSION" "$BUMP_TYPE")
  echo "‚Ä∫ Version actuelle : ${CURRENT_VERSION}"
  echo "‚Ä∫ Nouvelle version : ${NEW_VERSION}"

  # --- √âtape 3: Pr√©paration de la branche et de l'artefact ---
  MAIN_BRANCH=$(get_config "MAIN_BRANCH")
  PRODUCTION_BRANCH=$(get_config "PRODUCTION_BRANCH")
  RELEASE_BRANCH="release/v${NEW_VERSION}"
  # Note : La cr√©ation de l'artefact de release sera aussi automatis√©e ici.
  RELEASE_ARTEFACT_PATH="./docs/CHARTE_IA/../backlog/07-releases"
  RELEASE_ARTEFACT="${RELEASE_ARTEFACT_PATH}/RELEASE-${NEW_VERSION}-PREPARING.md"

  echo "‚Ä∫ La branche de release '${RELEASE_BRANCH}' va √™tre cr√©√©e depuis '${MAIN_BRANCH}'."
  printf "Continuer ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then echo "Release annul√©e."; exit 0; fi

  # Cr√©ation de la branche et de l'artefact.
  git checkout "$MAIN_BRANCH"; git pull; git checkout -b "$RELEASE_BRANCH"
  mkdir -p "$RELEASE_ARTEFACT_PATH"
  # On pourrait utiliser 'get_template_from_protocol' ici si un template de release √©tait d√©fini.
  echo "# RAPPORT DE RELEASE : v${NEW_VERSION}" > "$RELEASE_ARTEFACT"
  echo "‚Ä∫ Artefact de release cr√©√© : ${RELEASE_ARTEFACT}"
  
  # --- √âtape 4: Mise √† jour des fichiers de version ---
  echo "‚Ä∫ Mise √† jour de la version dans package.json..."
  # 'sed -i.bak' cr√©e un backup avant d'√©diter le fichier, c'est plus s√ªr.
  sed -i.bak "s/\"version\": \"${CURRENT_VERSION}\"/\"version\": \"${NEW_VERSION}\"/" package.json && rm package.json.bak
  git add package.json
  git commit -m "chore(release): bump version to ${NEW_VERSION}"

  # --- √âtape 5: Validation Humaine ---
  # C'est une √©tape CRUCIALE. Le script se met en pause et attend que
  # l'humain valide manuellement que tout est en ordre (tests, changelog, etc.).
  echo ""
  echo "‚ÄºÔ∏è ACTION REQUISE ‚ÄºÔ∏è"
  echo "La release est maintenant pr√©par√©e sur la branche '${RELEASE_BRANCH}'."
  echo "Veuillez v√©rifier les changements, g√©n√©rer le CHANGELOG.md et valider les tests d'int√©gration."
  printf "Une fois que tout est valid√©, confirmez la finalisation de la release. (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then
    echo "Finalisation annul√©e. La branche de release '${RELEASE_BRANCH}' est conserv√©e pour une action manuelle."
    exit 0
  fi

  # --- √âtape 6: Finalisation (Merge, Tag, Push) ---
  echo "‚Ä∫ Finalisation de la release..."
  
  # 1. Fusion dans la branche de production
  git checkout "$PRODUCTION_BRANCH"; git pull; git merge --no-ff "$RELEASE_BRANCH"
  
  # 2. Cr√©ation du tag Git annot√©.
  git tag -a "v${NEW_VERSION}" -m "Release v${NEW_VERSION}"
  
  # 3. Push de la branche de production ET des tags.
  git push origin "$PRODUCTION_BRANCH"; git push origin --tags

  # 4. Synchronisation de la branche de d√©veloppement avec la nouvelle version.
  git checkout "$MAIN_BRANCH"; git merge "$PRODUCTION_BRANCH"; git push origin "$MAIN_BRANCH"
  
  # 5. Nettoyage de la branche de release.
  git branch -d "$RELEASE_BRANCH"

  # 6. Mise √† jour de l'artefact de release.
  mv "$RELEASE_ARTEFACT" "$(echo "$RELEASE_ARTEFACT" | sed 's/PREPARING/SHIPPED/')"

  echo ""
  echo "üéâ Release v${NEW_VERSION} publi√©e avec succ√®s !"
}

# Commande: hotfix
# R√¥le: D√©marre OU publie un processus de correction d'urgence (hotfix).
#       Cette fonction agit comme un routeur :
#       - 'aklo hotfix "description"' appelle la logique de d√©marrage.
#       - 'aklo hotfix publish' appelle la logique de finalisation.
#
# Usage: aklo hotfix "<description>" OU aklo hotfix publish
#
command_hotfix() {
  # --- √âtape 1 : Routage ---
  # On v√©rifie si le premier argument est "publish".
  # Si c'est le cas, on appelle la fonction d√©di√©e et on arr√™te l'ex√©cution de celle-ci.
  if [ "$1" = "publish" ]; then
    command_hotfix_publish
    return
  fi

  # Si l'argument n'est pas "publish", on continue avec la logique de d√©marrage.
  if [ -z "$1" ]; then
    echo "Erreur : Une description du hotfix est requise (ou 'publish' pour finaliser)." >&2
    exit 1
  fi
  
  # --- √âtape 2 : Pr√©paration du D√©marrage ---
  DESCRIPTION="$1"
  # On cr√©e un 'slug' (un identifiant textuel simple) et un ID d'artefact.
  SLUG=$(echo "$DESCRIPTION" | tr '[:upper:]' '[:lower:]' | tr -s ' ' '-')
  HOTFIX_ID="${SLUG}-$(date +'%Y%m%d')"
  
  echo "--- Lancement du protocole d'urgence [HOTFIX] ---"
  
  # On r√©cup√®re les informations critiques.
  LATEST_TAG=$(get_latest_production_tag)
  HOTFIX_BRANCH="hotfix/${SLUG}"
  
  # On demande confirmation avant toute action sur Git.
  echo "‚Ä∫ Le dernier tag de production est : ${LATEST_TAG}"
  echo "‚Ä∫ La branche de hotfix '${HOTFIX_BRANCH}' va √™tre cr√©√©e depuis ce tag."
  printf "Continuer ? (y/n) "
  read -r reply
  if [ "$reply" != "y" ]; then echo "Hotfix annul√©."; exit 0; fi

  # --- √âtape 3 : Ex√©cution du D√©marrage ---
  # 1. Cr√©ation de la branche de hotfix depuis le dernier tag stable.
  git checkout -b "$HOTFIX_BRANCH" "$LATEST_TAG"
  
  # 2. Cr√©ation de l'artefact de suivi.
  PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/10-HOTFIX.md"
  SECTION_TO_EXTRACT="Structure Obligatoire du Fichier Hotfix"
  RAW_TEMPLATE=$(get_template_from_protocol "$PROTOCOL_FILE" "$SECTION_TO_EXTRACT")
  ARTEFACT_PATH="./docs/CHARTE_IA/../backlog/08-hotfixes"
  ARTEFACT_FILE="${ARTEFACT_PATH}/HOTFIX-${HOTFIX_ID}-INVESTIGATING.md"
  mkdir -p "$ARTEFACT_PATH"
  echo "$RAW_TEMPLATE" | \
      sed -e "s/\[ID\]/${HOTFIX_ID}/g" \
          -e "s/Impact Critique:.*$/Impact Critique: ${DESCRIPTION}/g" \
          -e "s/Version Affect√©e:.*$/Version Affect√©e: ${LATEST_TAG}/g" > "$ARTEFACT_FILE"
      
  echo "‚úÖ Environnement de hotfix pr√™t sur la branche '${HOTFIX_BRANCH}'."
  echo "   Artefact de suivi cr√©√© : ${ARTEFACT_FILE}"
}

# Sous-commande: hotfix publish
# R√¥le: Finalise et publie une correction d'urgence termin√©e.
# Note: Cette fonction est appel√©e par 'command_hotfix' et n'est pas
#       directement dans le dispatcher principal.
command_hotfix_publish() {
  # --- √âtape 1 : V√©rification du Contexte ---
  CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
  if ! echo "$CURRENT_BRANCH" | grep -q "^hotfix/"; then
    echo "Erreur : Vous devez √™tre sur une branche de hotfix pour publier." >&2
    exit 1
  fi

  echo "--- Finalisation et publication du hotfix ---"
  
  # --- √âtape 2 : Calcul du Nouveau Tag ---
  LATEST_TAG=$(get_latest_production_tag)
  # On retire le "v" pour pouvoir utiliser notre fonction 'bump_version'.
  VERSION_NUMBER=$(echo "$LATEST_TAG" | sed 's/^v//')
  # Un hotfix r√©sulte TOUJOURS en une nouvelle version de 'patch'.
  NEW_VERSION_NUMBER=$(bump_version "$VERSION_NUMBER" "patch")
  NEW_TAG="v${NEW_VERSION_NUMBER}"

  # --- √âtape 3 : Confirmation Finale ---
  printf "Le nouveau tag de patch sera '%s'.\n" "$NEW_TAG"
  printf "La branche '%s' sera fusionn√©e dans main et develop. Continuer ? (y/n) " "$CURRENT_BRANCH"
  read -r reply
  if [ "$reply" != "y" ]; then echo "Publication annul√©e."; exit 0; fi

  # --- √âtape 4 : Ex√©cution de la S√©quence Git de Publication ---
  MAIN_BRANCH=$(get_config "MAIN_BRANCH")
  PRODUCTION_BRANCH=$(get_config "PRODUCTION_BRANCH")
  
  # 1. Fusion dans la branche de production.
  git checkout "$PRODUCTION_BRANCH"; git merge --no-ff "$CURRENT_BRANCH"
  # 2. Cr√©ation du tag annot√©.
  git tag -a "$NEW_TAG" -m "Hotfix: ${CURRENT_BRANCH#hotfix/}"
  # 3. Push de la branche de production ET du nouveau tag.
  git push origin "$PRODUCTION_BRANCH" --tags
  
  # 4. Synchronisation de la branche de d√©veloppement avec la correction.
  git checkout "$MAIN_BRANCH"; git merge "$PRODUCTION_BRANCH"; git push origin "$MAIN_BRANCH"
  
  # 5. Nettoyage de la branche de hotfix (uniquement en local, la distante sera nettoy√©e par la plateforme Git).
  git branch -d "$CURRENT_BRANCH"
  
  echo ""
  echo "‚úÖ Hotfix publi√© avec succ√®s sous le tag ${NEW_TAG}."
}

# Commande: new
# R√¥le: Cr√©e un nouvel artefact de support (debug, refactor, etc.) en lisant
#       la structure directement depuis le protocole correspondant dans la Charte.
#       C'est un dispatcher intelligent qui applique des r√®gles sp√©cifiques
#       pour chaque type d'artefact.
#
# Usage: aklo new <type> [arguments...]
#
command_new() {
  # --- √âtape 1 : Validation des arguments ---
  # On v√©rifie que Aklo est bien initialis√© dans le projet.
  if [ ! -L "./docs/CHARTE_IA" ]; then
    echo "Erreur : Aklo n'est pas initialis√©. Lancez 'aklo init' d'abord." >&2
    exit 1
  fi
  # On v√©rifie que l'utilisateur a au moins fourni un type d'artefact.
  if [ -z "$1" ]; then
    echo "Erreur : Le type d'artefact est requis." >&2
    echo "Usage: aklo new <type> [arguments...]" >&2
    exit 1
  fi

  # --- √âtape 2 : Pr√©paration et Routage ---
  ARTEFACT_TYPE="$1"
  shift # On d√©cale les arguments pour que chaque 'case' puisse g√©rer ses propres arguments.
  
  # Ce 'case' est le c≈ìur de la fonction. Chaque type d'artefact
  # d√©finit ses propres chemins, son nom de fichier final, et ses
  # propres expressions de remplacement 'sed' pour √™tre contextuel.
  case "$ARTEFACT_TYPE" in
    "debug" | "refactor" | "optim" | "experiment" | "competition" | "deprecation" | "fast-track" | "scratchpad")
      # Ce bloc g√®re tous les artefacts dont l'ID est bas√© sur un titre et une date.
      if [ -z "$1" ]; then echo "Erreur: Un titre est requis pour le type '${ARTEFACT_TYPE}'." >&2; exit 1; fi
      ARTEFACT_TITLE="$1"
      # On cr√©e un 'slug' : un identifiant textuel simple pour le nom de fichier.
      ARTEFACT_SLUG=$(echo "$ARTEFACT_TITLE" | tr '[:upper:]' '[:lower:]' | tr -s ' ' '-')
      # On cr√©e un ID unique en combinant le slug et la date.
      ARTEFACT_ID="${ARTEFACT_SLUG}-$(date +'%Y%m%d')"
      
      # On utilise un second 'case' pour d√©finir les variables sp√©cifiques √† chaque type.
      case "$ARTEFACT_TYPE" in
          "debug")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/04-DEBOGAGE.md"
            SECTION="Structure Obligatoire Du Fichier Debug"
            PATH_DIR="./docs/CHARTE_IA/../backlog/04-debug"
            FILENAME="${PATH_DIR}/DEBUG-${ARTEFACT_ID}-INVESTIGATING.md"
            # R√®gle de substitution sp√©cifique pour ce template :
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g -e s/Probl√®me Constat√©.*$/Probl√®me Constat√©: ${ARTEFACT_TITLE}/g"
            ;;
          "refactor")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/05-REFACTORING.md"
            SECTION="Structure Obligatoire Du Fichier Refactor"
            PATH_DIR="./docs/CHARTE_IA/../backlog/05-refactor"
            FILENAME="${PATH_DIR}/REFACTOR-${ARTEFACT_ID}-ANALYSIS.md"
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g -e s/Probl√®me identifi√©.*$/Probl√®me identifi√©: ${ARTEFACT_TITLE}/g"
            ;;
          "optim")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/06-OPTIMISATION.md"
            SECTION="Structure Obligatoire Du Fichier Optim"
            PATH_DIR="./docs/CHARTE_IA/../backlog/06-optim"
            FILENAME="${PATH_DIR}/OPTIM-${ARTEFACT_ID}-BENCHMARKING.md"
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g -e s/M√©trique cibl√©e.*$/M√©trique cibl√©e: ${ARTEFACT_TITLE}/g"
            ;;
          "experiment")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/11-EXPERIMENTATION.md"
            SECTION="Structure Obligatoire Du Fichier Experiment"
            PATH_DIR="./docs/CHARTE_IA/../backlog/09-experiments"
            FILENAME="${PATH_DIR}/EXPERIMENT-${ARTEFACT_ID}-PLANNING.md"
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g -e s/Nous croyons que.*$/Nous croyons que ${ARTEFACT_TITLE}/g"
            ;;
          "competition")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/12-ANALYSE-CONCURRENCE.md"
            SECTION="Structure Obligatoire du Fichier d'Analyse"
            PATH_DIR="./docs/CHARTE_IA/../backlog/10-competition"
            FILENAME="${PATH_DIR}/COMPETITION-${ARTEFACT_ID}-ANALYSIS.md"
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g -e s/Sujet de l'Analyse.*$/Sujet de l'Analyse: ${ARTEFACT_TITLE}/g"
            ;;
          "deprecation")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/15-DEPRECATION.md"
            SECTION="Structure Obligatoire du Fichier de D√©pr√©ciation"
            PATH_DIR="./docs/CHARTE_IA/../backlog/12-deprecations"
            FILENAME="${PATH_DIR}/DEPRECATION-${ARTEFACT_ID}-ANALYSIS.md"
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g -e s/Fonctionnalit√© √† D√©pr√©cier.*$/Fonctionnalit√© √† D√©pr√©cier: ${ARTEFACT_TITLE}/g"
            ;;
          "fast-track")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/20-FAST-TRACK.md"
            SECTION="Structure Obligatoire du Fichier Fast-Track"
            PATH_DIR="./docs/CHARTE_IA/../backlog/17-fast-track"
            FILENAME="${PATH_DIR}/FAST-${ARTEFACT_ID}-TODO.md"
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g -e s/Justification du Fast-Track.*$/Justification du Fast-Track: ${ARTEFACT_TITLE}/g"
            ;;
          "scratchpad")
            PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/19-SCRATCHPAD.md"
            SECTION="Structure Recommand√©e (Flexible)"
            PATH_DIR="./docs/CHARTE_IA/../backlog/16-scratchpads"
            FILENAME="${PATH_DIR}/SCRATCHPAD-${ARTEFACT_ID}-ACTIVE.md"
            # Ce template ne remplace que l'ID pour garder le reste flexible.
            SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g"
            ;;
      esac
      ;;
      
    "meta-improvement")
      if [ -z "$1" ]; then echo "Erreur: Un sujet est requis pour 'meta-improvement'." >&2; exit 1; fi
      ARTEFACT_TITLE="$1"; ARTEFACT_SLUG=$(echo "$ARTEFACT_TITLE" | tr '[:upper:]' '[:lower:]' | tr -s ' ' '-'); ARTEFACT_ID="${ARTEFACT_SLUG}-$(date +'%Y%m%d')"
      PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/21-META-IMPROVEMENT.md"
      SECTION="Structure Obligatoire du Fichier Improve"
      PATH_DIR="./docs/CHARTE_IA/../backlog/18-improvements"
      FILENAME="${PATH_DIR}/IMPROVE-${ARTEFACT_ID}-PROPOSED.md"
      # Ce template ne remplace que l'ID, car le titre est le sujet m√™me du document.
      SED_EXPRESSIONS="-e s/\[ID\]/${ARTEFACT_ID}/g"
      ;;
      
    "tracking-plan" | "user-docs")
      # Ce bloc g√®re les artefacts qui d√©pendent d'un artefact parent.
      if [ -z "$1" ]; then echo "Erreur: L'ID du PBI/Task/Release parent est requis pour '${ARTEFACT_TYPE}'." >&2; exit 1; fi
      PARENT_ID="$1"
      case "$ARTEFACT_TYPE" in
        "tracking-plan")
          PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/16-TRACKING-PLAN.md"
          SECTION="Structure Obligatoire du Fichier de Tracking"
          PATH_DIR="./docs/CHARTE_IA/../backlog/13-tracking"
          FILENAME="${PATH_DIR}/TRACKING-PLAN-${PARENT_ID}-DRAFT.md"
          SED_EXPRESSIONS="-e s/\[ID\]/${PARENT_ID}/g"
          ;;
        "user-docs")
          PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/17-USER-DOCS.md"
          SECTION="Structure Obligatoire du Fichier de Documentation"
          PATH_DIR="./docs/CHARTE_IA/../backlog/14-user-docs"
          FILENAME="${PATH_DIR}/USER-DOCS-${PARENT_ID}-DRAFT.md"
          SED_EXPRESSIONS="-e s/\[ID\]/${PARENT_ID}/g"
          ;;
      esac
      ;;

    "security-audit")
      # Ce cas est unique : il n'a pas besoin d'argument car son ID est la date.
      ARTEFACT_ID=$(date +'%Y-%m-%d')
      PROTOCOL_FILE="./docs/CHARTE_IA/PROTOCOLES/13-SECURITE-AUDIT.md"
      SECTION="Structure Obligatoire du Fichier d'Audit"
      PATH_DIR="./docs/CHARTE_IA/../backlog/11-security"
      FILENAME="${PATH_DIR}/AUDIT-SECURITY-${ARTEFACT_ID}-SCANNING.md"
      SED_EXPRESSIONS="-e s/\[DATE\]/${ARTEFACT_ID}/g"
      ;;

    *)
      echo "Erreur : Type d'artefact inconnu '${ARTEFACT_TYPE}'." >&2
      exit 1
      ;;
  esac

  # --- √âtape finale : Extraction et Cr√©ation ---
  RAW_TEMPLATE=$(get_template_from_protocol "$PROTOCOL_FILE" "$SECTION")
  if [ -z "$RAW_TEMPLATE" ]; then echo "Erreur : Impossible d'extraire la structure '${SECTION}'." >&2; exit 1; fi

  mkdir -p "$PATH_DIR"
  # 'eval' est utilis√© pour que le shell interpr√®te correctement la cha√Æne
  # de commande 'sed' qui peut contenir des espaces et des guillemets.
  eval "echo \"\$RAW_TEMPLATE\" | sed $SED_EXPRESSIONS" > "$FILENAME"

  echo "‚úÖ Artefact '${ARTEFACT_TYPE}' cr√©√© : ${FILENAME}"
}

#==============================================================================
# SECTION 3 : POINT D'ENTR√âE (Le "Dispatcher" de Rituels)
#==============================================================================

if [ -z "$1" ]; then
  echo "The Aklo Protocol - A Charte Automation Tool (v1.5)"
  echo ""
  echo "Usage: aklo <command> [arguments]"
  echo ""
  echo "Available Commands:"
  echo "  init                    Links the Aklo Charte to the current project."
  echo "  propose-pbi <title>     Creates a new Product Backlog Item."
  echo "  plan <PBI_ID>           Interactively plans the tasks for a PBI."
  echo "  start-task <TASK_ID>    Prepares the environment to work on a task."
  echo "  submit-task             Commits and submits the current task for review."
  echo "  merge-task <TASK_ID>    Merges a reviewed task into the main branch."
  echo "  release <type>          Starts the release process (type: major, minor, patch)."
  echo "  hotfix <description>    Starts the hotfix process from production."
  echo "  hotfix publish          Publishes a completed hotfix."
  echo "  new <type> [args...]    Creates a new support artefact (e.g., 'debug', 'refactor')."
  exit 1
fi

COMMAND="$1"
shift

case "$COMMAND" in
  init) command_init "$@";;
  propose-pbi) command_propose_pbi "$@";;
  plan) command_plan "$@";;
  start-task) command_start_task "$@";;
  submit-task) command_submit_task "$@";;
  merge-task) command_merge_task "$@";;
  release) command_release "$@";;
  hotfix) command_hotfix "$@";;
  new) command_new "$@";;
  *) echo "Error: Unknown command '${COMMAND}'." >&2; exit 1;;
esac