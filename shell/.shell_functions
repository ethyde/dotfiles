#!/bin/bash

# ==============================================================================
#                 Fonctions Shell pour les alias Git
#
# Pour utiliser ce fichier, ajoutez la ligne suivante à votre ~/.bashrc ou ~/.zshrc :
#
#   source ~/.git_functions
#
# ==============================================================================

# ==============================================================================
#                      Logs & Historique
# ==============================================================================

# Affiche les changements réalisés depuis le dernier pull
# Usage: git lc
git_log_since_last_pull() {
  # Utilise ORIG_HEAD, qui est une référence créée par git pull
  git log --pretty=oneline --abbrev-commit --graph ORIG_HEAD.. --stat --no-merges
}

# Affiche les commits qui n'ont pas encore été push vers le remote
# Usage: git ups
git_log_unpushed() {
  git log --branches --not --remotes --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit
}

# Affiche une liste de tags formatée et triée par date
# Usage: git tags-l
git_list_tags_formatted() {
  # 1. 'git for-each-ref' récupère les tags avec un format personnalisé
  #    Le séparateur "_,,,_" est utilisé pour être parsé par awk de manière fiable.
  # 2. 'awk' formate ensuite la sortie en colonnes propres.
  git for-each-ref \
    --sort=taggerdate \
    --format '%(tag)_,,,_%(taggerdate:raw)_,,,_%(taggername)_,,,_%(subject)' refs/tags \
    | awk '
      BEGIN { 
        FS = "_,,,_"  
      }
      { 
        # Convertit le timestamp unix en date lisible
        t = strftime("%Y-%m-%d  %H:%M", $2); 
        # Imprime les colonnes formatées
        printf "%-20s %-18s %-25s %s\n", t, $1, $4, $3
      }'
}

# ==============================================================================
#                      Workflow & Sauvegardes
# ==============================================================================

# Ajoute tous les fichiers et crée un commit.
# Si aucun message n'est fourni via -m, il le génère à partir du nom de la branche.
# La branche doit suivre le format : type/JIRA-ISSUE/description-en-kebab-case
# Usage: git aac
#     ou: git aac -m "Message manuel"
git_add_all_and_commit() {
  # 1. Ajoute tous les fichiers au "stage"
  git add --all

  # 2. Vérifie si des arguments (comme -m "...") ont été passés à la commande
  if [ $# -gt 0 ]; then
    # Si oui, on utilise le comportement normal de git commit
    echo "Arguments détectés, utilisation du commit manuel..."
    git commit "$@"
  else
    # Si non, on génère le message à partir du nom de la branche
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    # 3. On tente de parser le nom de la branche
    local type jira_issue desc formatted_desc commit_message
    # On utilise IFS (Internal Field Separator) pour découper la chaîne par le caractère "/"
    IFS='/' read -r type jira_issue desc <<< "$current_branch"

    # 4. On vérifie que les 3 parties ont bien été extraites
    if [[ -n "$type" && -n "$jira_issue" && -n "$desc" ]]; then
      # On transforme la description de kebab-case en phrase normale
      formatted_desc=$(echo "$desc" | sed 's/-/ /g')
      
      # On assemble le message de commit au format "Conventional Commit"
      commit_message="${type}(${jira_issue}): ${formatted_desc}"
      
      echo "Commit message généré automatiquement :"
      echo "  => ${commit_message}"
      
      # 5. On exécute le commit avec le message généré
      git commit -m "${commit_message}"
    else
      # 6. Si le nom de la branche ne correspond pas, on ouvre l'éditeur par défaut
      echo "Le nom de la branche ne suit pas le format 'type/JIRA/desc'."
      echo "Ouverture de l'éditeur pour le message de commit..."
      git commit
    fi
  fi
}

# Crée un commit "SAVEPOINT" sans vérification des hooks
# Usage: git save
git_savepoint() {
  git add --all && git commit --no-verify -m 'SAVEPOINT'
}

# Crée un commit WIP (Work In Progress) avec un message
# Usage: git wip "mon message"
git_work_in_progress() {
  git add --all && git commit --no-verify -m "$@"
}

# Crée un point de sauvegarde temporaire, puis le supprime immédiatement
# Utile pour réinitialiser l'état de la branche de manière "sûre" via le reflog
# Usage: git wipe "message optionnel"
git_wipe_savepoint() {
  local message=${1:-"WIPE-SAVEPOINT"}
  git add --all && git commit --no-verify -q -m "$message" && git reset HEAD~1 --hard
}

# ==============================================================================
#                      Gestion des Branches & Synchronisation
# ==============================================================================

# Définit la branche amont (upstream) pour la branche actuelle sur 'origin'
# Usage: git su
git_set_upstream() {
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  if [[ -n "$current_branch" ]]; then
    git branch --set-upstream-to="origin/$current_branch"
  else
    echo "Erreur : Impossible de déterminer la branche actuelle." >&2
    return 1
  fi
}

# Synchronise la branche actuelle avec le remote (pull --rebase) et met à jour les submodules
# Usage: git sync
git_branch_sync() {
    git pull --rebase=preserve --prune "$@" && git submodule update --init --recursive
}

# Démarre une nouvelle branche, la push sur origin et configure le suivi amont
# Usage: git b-start ma-nouvelle-branche
git_branch_start() {
  local branch_name=${1:-newBranch}
  git checkout -b "$branch_name" && git push origin "$branch_name" && git_set_upstream && git_npm_clean
}

# Supprime une branche en local ET sur le remote 'origin'
# Usage: git b-del ma-branche
git_branch_delete() {
  local branch_name=$1
  if [[ -z "$branch_name" ]]; then
    echo "Erreur : Nom de la branche manquant." >&2
    return 1
  fi
  git branch --delete "$branch_name" && git push origin --delete "$branch_name"
}

# Force la suppression d'une branche en local ET sur le remote 'origin'
# Usage: git b-del-f ma-branche
git_branch_delete_force() {
  local branch_name=$1
  if [[ -z "$branch_name" ]]; then
    echo "Erreur : Nom de la branche manquant." >&2
    return 1
  fi
  git branch --delete --force "$branch_name" && git push origin --delete "$branch_name"
}

# Lance un rebase interactif depuis le point de divergence avec la branche cible
# Usage: git b-squash [branche_cible]
git_branch_squash() {
    local target_branch=${1:-master}
    local fork_point
    fork_point=$(git merge-base --fork-point "$target_branch")

    if [[ -z "$fork_point" ]]; then
        echo "Erreur : Impossible de trouver un point de divergence avec la branche '$target_branch'." >&2
        echo "La branche est peut-être déjà à jour ou n'a pas d'historique commun." >&2
        return 1
    fi

    echo "Lancement du rebase interactif depuis le commit $fork_point..."
    git rebase -i "$fork_point"
}

# ==============================================================================
#                      Nettoyage & Finalisation
# ==============================================================================

# Nettoie les branches locales qui ont déjà été fusionnées dans la branche cible (master par défaut)
# Usage: git b-clean [branche_cible]
git_branch_clean() {
  local target_branch=${1:-master}
  git branch --merged "$target_branch" | grep -v -E "(^\*|${target_branch}$)" | xargs git branch --delete
}

# Routine complète de fin de tâche : se place sur master, met à jour, nettoie les branches et les dépendances
# Usage: git b-done [branche_cible]
git_branch_done() {
    local target_branch=${1:-master}
    git checkout "$target_branch" && git_branch_sync && git_branch_clean "$target_branch" && git_npm_clean
}

# Nettoie les dépendances NPM pour un environnement de production
# Usage: git n-clean
git_npm_clean() {
  if [[ -f "package.json" ]]; then
    npm install --no-package-lock --production && npm prune
  else
    echo "Pas de fichier package.json trouvé, nettoyage npm ignoré."
  fi
}

# ==============================================================================
#                      Pull Requests & Aide
# ==============================================================================

# Récupère une Pull Request depuis GitHub, Bitbucket ou GitLab
# Usage: git pr <gh|bb|gl> <numéro_pr> [préfixe_branche]
git_pull_request() {
  local provider=$1
  local pr_number=$2
  local branch_prefix=${3:-pr}
  local remote_name
  local ref_path=""

  remote_name=$(git remote | grep ^upstream || echo origin)

  if [[ -z "$pr_number" ]]; then
    echo "Erreur : Numéro de Pull Request manquant." >&2
    return 1
  fi

  case "$provider" in
    gh) ref_path="refs/pull/$pr_number/head" ;;
    bb) ref_path="refs/pull-requests/$pr_number/head" ;;
    gl) ref_path="refs/merge-requests/$pr_number/head" ;;
    *) echo "Fournisseur non supporté : $provider. Utilisez 'gh', 'bb', ou 'gl'." >&2; return 1 ;;
  esac

  git fetch -fu "$remote_name" "$ref_path:$branch_prefix/$pr_number" && git checkout "$branch_prefix/$pr_number"
}

# Affiche une aide-mémoire formatée de tous les alias Git
# en lisant les commentaires de catégorie directement depuis le .gitconfig
# Usage: git aliases
git_display_help() {
  (
    # Exécution dans une sous-shell pour isoler les variables et les couleurs
    in_alias_section=0
    current_category="Alias Généraux"
    C_CAT=$(printf '\033[1;34m')
    C_ALIAS=$(printf '\033[1;33m')
    C_CMD=$(printf '\033[0;37m')
    C_RST=$(printf '\033[0m')

    # Lecture du fichier .gitconfig ligne par ligne de manière portable
    while IFS= read -r line || [ -n "$line" ]; do
      # Utilisation de 'case' pour une meilleure portabilité (Bash, Zsh, sh)
      case "$line" in
        # Note: Les guillemets autour de [alias] sont importants pour 'case'
        "["alias"]"*)
          in_alias_section=1
          printf "\n%s---- %s ----%s\n" "$C_CAT" "$current_category" "$C_RST"
          ;;
        "["*)
          # Si on rencontre une autre section, on arrête de traiter les alias
          if [ "$in_alias_section" -eq 1 ]; then
            in_alias_section=0
          fi
          ;;
        *)
          # Traitement des lignes uniquement si on est dans la section [alias]
          if [ "$in_alias_section" -eq 1 ]; then
            # Recherche d'une ligne de catégorie, ex: #   Nom Catégorie  =====
            if echo "$line" | grep -q '^\s*#\s*.*\s\+=====$'; then
              current_category=$(echo "$line" | sed -e 's/^\s*#\s*//' -e 's/\s\+=====.*$//')
              printf "\n%s---- %s ----%s\n" "$C_CAT" "$current_category" "$C_RST"
            # Recherche d'une ligne d'alias valide (non commentée)
            elif echo "$line" | grep -q '^\s*[a-zA-Z0-9-]\+\s*=.*'; then
              key=$(echo "$line" | sed -e 's/\s*=.*//' -e 's/^\s*//')
              value=$(echo "$line" | sed 's/.*=\s*//')
              printf "  %s%-12s%s %s%s\n" "$C_ALIAS" "$key" "$C_RST" "$C_CMD" "$value"
            fi
          fi
          ;;
      esac
    done
  ) < ~/.gitconfig
}

# ==============================================================================
#                      Gestion /etc/hosts
# ==============================================================================

removehost() {
    if [[ "$1" ]]; then
        local HOSTNAME=$1
        if [ -n "$(grep "$HOSTNAME" /etc/hosts)" ]; then
            echo "$HOSTNAME Trouvé dans /etc/hosts, suppression..."
            sudo sed -i".bak" "/$HOSTNAME/d" /etc/hosts
        else
            echo "$HOSTNAME non trouvé dans /etc/hosts"
        fi
    else
        echo "Erreur: paramètre manquant. Usage: removehost <domaine>"
    fi
}

addhost() {
    if [[ "$1" && "$2" ]]; then
        local IP=$1
        local HOSTNAME=$2
        if [ -n "$(grep "$HOSTNAME" /etc/hosts)" ]; then
            echo "$HOSTNAME existe déjà:"
            grep "$HOSTNAME" /etc/hosts
        else
            echo "Ajout de $HOSTNAME dans /etc/hosts"
            printf "%s\t%s\n" "$IP" "$HOSTNAME" | sudo tee -a /etc/hosts > /dev/null
        fi
    else
        echo "Erreur: paramètres manquants. Usage: addhost <ip> <domaine>"
    fi
}

# ==============================================================================
#                      Gestion de l'agent SSH
# ==============================================================================

# Vérifie si l'agent est en cours d'exécution
agent_is_running() {
  if [ "$SSH_AUTH_SOCK" ]; then
    # ssh-add retourne 0 ou 1 si l'agent tourne (avec ou sans clés), 2 sinon
    ssh-add -l >/dev/null 2>&1 || [ $? -eq 1 ]
  else
    false
  fi
}

# Vérifie si l'agent a des clés chargées
agent_has_keys() {
  ssh-add -l >/dev/null 2>&1
}

# Charge l'environnement de l'agent depuis le fichier
agent_load_env() {
  local env_file=~/.ssh/agent.env
  [ -f "$env_file" ] && . "$env_file" >/dev/null
}

# Démarre un nouvel agent et sauvegarde son environnement
agent_start() {
  local env_file=~/.ssh/agent.env
  (umask 077; ssh-agent >"$env_file")
  . "$env_file" >/dev/null
}

# Ajoute toutes les clés SSH du type id_rsa_*
add_all_keys() {
  ls ~/.ssh | grep id_rsa_ | sed "s:^:`echo ~`/.ssh/:" | xargs -n 1 ssh-add
}

# ==============================================================================
#                      NVM & Navigation
# ==============================================================================

# Redéfinit la commande `cd` pour une gestion automatique de la version de Node.
# Cette fonction est compatible avec Bash et Zsh.
cd() {
  # Exécute la commande `cd` originale. `builtin` garantit qu'on appelle la
  # commande de base du shell, évitant ainsi une boucle infinie.
  # Si `cd` échoue (ex: dossier non trouvé), la fonction s'arrête ici.
  builtin cd "$@" || return $?

  # Si la commande `nvm` n'existe pas, on ne fait rien.
  if ! command -v nvm &> /dev/null; then
    return 0
  fi

  # `nvm_find_up` cherche un fichier `.nvmrc` dans le répertoire actuel
  # et dans les répertoires parents.
  local nvmrc_path
  nvmrc_path=$(nvm_find_up .nvmrc)

  if [[ -n "$nvmrc_path" ]]; then
    # Un .nvmrc a été trouvé. On utilise `nvm install`, qui est une commande
    # très robuste :
    # 1. Lit le .nvmrc.
    # 2. Si la version n'est pas installée, il l'installe.
    # 3. Active la version demandée.
    # La sortie est masquée pour ne pas polluer le terminal.
    nvm install >/dev/null
  else
    # Aucun .nvmrc n'a été trouvé. On revient à la version par défaut.
    local default_version
    default_version=$(nvm version default)

    # On change uniquement si une version par défaut est définie et
    # si ce n'est pas déjà la version actuelle.
    if [[ "$default_version" != "N/A" ]] && [[ "$(nvm current)" != "$default_version" ]]; then
      nvm use default >/dev/null
    fi
  fi
}

# ==============================================================================
#                      Rechargement du Shell
# ==============================================================================

# Supprime un éventuel alias 'reload' pour éviter les conflits avant de
# définir la fonction. Le '2>/dev/null || true' assure que la commande
# ne génère pas d'erreur si l'alias n'existe pas.
unalias reload 2>/dev/null || true

# Recharge le shell en cours d'exécution de manière fiable.
# Détecte s'il s'agit de Bash ou Zsh et utilise 'exec' pour un
# rechargement complet, équivalent à un redémarrage.
reload() {
    echo "Rechargement du shell..."
    if [ -n "$BASH_VERSION" ]; then
        exec bash
    elif [ -n "$ZSH_VERSION" ]; then
        exec zsh
    else
        echo "Shell non supporté pour le rechargement automatique."
    fi
}