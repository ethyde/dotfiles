# ==============================================================================
#                      SystÃ¨me de SÃ©curitÃ© et Validation Git
# ==============================================================================

# Validation avancÃ©e des noms de branches
git_branch_validate() {
    local branch_name="$1"
    
    if [[ -z "$branch_name" ]]; then
        echo "âŒ Nom de branche requis"
        return 1
    fi
    
    # VÃ©rifications de sÃ©curitÃ©
    if [[ ${#branch_name} -gt 100 ]]; then
        echo "âŒ Nom trop long (max 100 caractÃ¨res, actuel: ${#branch_name})"
        return 1
    fi
    
    if [[ "$branch_name" =~ [[:space:]] ]]; then
        echo "âŒ Espaces interdits dans les noms de branches"
        return 1
    fi
    
    if [[ "$branch_name" =~ ^(master|main|develop|staging|production)$ ]]; then
        echo "âŒ Nom de branche protÃ©gÃ©: $branch_name"
        return 1
    fi
    
    if [[ "$branch_name" =~ ^- ]] || [[ "$branch_name" =~ -$ ]]; then
        echo "âŒ Ne peut pas commencer ou finir par un tiret"
        return 1
    fi
    
    if [[ "$branch_name" =~ \.\. ]]; then
        echo "âŒ Double points interdits (conflit Git)"
        return 1
    fi
    
    if [[ "$branch_name" =~ [@{^~:?*\[] ]]; then
        echo "âŒ CaractÃ¨res interdits: @ { ^ ~ : ? * [ ]"
        return 1
    fi
    
    # VÃ©rifications de format recommandÃ©
    if [[ ! "$branch_name" =~ ^(feat|fix|docs|style|refactor|test|chore)/ ]]; then
        echo "âš ï¸  Format recommandÃ©: type/JIRA-123/description"
        echo "   Types valides: feat, fix, docs, style, refactor, test, chore"
    fi
    
    if [[ "$branch_name" =~ ^[^/]+/[^/]+/[^/]+$ ]]; then
        local type=$(echo "$branch_name" | cut -d'/' -f1)
        local jira=$(echo "$branch_name" | cut -d'/' -f2)
        local desc=$(echo "$branch_name" | cut -d'/' -f3)
        
        if [[ ! "$jira" =~ ^[A-Z]+-[0-9]+$ ]]; then
            echo "âš ï¸  Format JIRA recommandÃ©: PROJ-123 (actuel: $jira)"
        fi
        
        if [[ ${#desc} -lt 3 ]]; then
            echo "âš ï¸  Description trop courte (min 3 caractÃ¨res)"
        fi
    fi
    
    echo "âœ… Nom de branche valide: $branch_name"
    return 0
}

# Backup automatique avant opÃ©rations destructives
git_safe_operation() {
    local operation="$1"
    local branch_name="$2"
    
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "âŒ Pas dans un dÃ©pÃ´t Git"
        return 1
    fi
    
    local timestamp=$(date +%Y%m%d-%H%M%S)
    local backup_ref="refs/backups/$timestamp-$operation"
    
    # CrÃ©er un backup de l'Ã©tat actuel
    if git update-ref "$backup_ref" HEAD 2>/dev/null; then
        echo "ğŸ”’ Backup crÃ©Ã©: $backup_ref"
        
        # Garder seulement les 10 derniers backups
        local backup_count=$(git for-each-ref refs/backups/ | wc -l)
        if [[ $backup_count -gt 10 ]]; then
            local oldest_backup=$(git for-each-ref refs/backups/ --sort=committerdate --format='%(refname)' | head -1)
            git update-ref -d "$oldest_backup"
            echo "ğŸ—‘ï¸  Ancien backup supprimÃ©: $(basename "$oldest_backup")"
        fi
        
        return 0
    else
        echo "âŒ Impossible de crÃ©er le backup"
        return 1
    fi
}

# VÃ©rification de l'Ã©tat du dÃ©pÃ´t avant opÃ©rations
git_repo_check() {
    local operation="$1"
    
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "âŒ Pas dans un dÃ©pÃ´t Git"
        return 1
    fi
    
    # VÃ©rifier s'il y a des changements non commitÃ©s
    if ! git diff --quiet || ! git diff --cached --quiet; then
        case "$operation" in
            branch_create|branch_switch)
                echo "âš ï¸  Changements non commitÃ©s dÃ©tectÃ©s"
                echo "   Voulez-vous les stasher automatiquement? [y/N]"
                read -r response
                if [[ "$response" =~ ^[Yy]$ ]]; then
                    local stash_message="Auto-stash avant $operation - $(date)"
                    git stash push -m "$stash_message"
                    echo "ğŸ’¾ Changements stashÃ©s: $stash_message"
                else
                    echo "âŒ OpÃ©ration annulÃ©e - commitez ou stashez vos changements"
                    return 1
                fi
                ;;
            branch_delete)
                echo "âŒ Changements non commitÃ©s - commitez avant de supprimer une branche"
                return 1
                ;;
        esac
    fi
    
    # VÃ©rifier la connexion au remote
    if ! git ls-remote origin HEAD >/dev/null 2>&1; then
        echo "âš ï¸  Impossible de contacter le remote 'origin'"
        echo "   Continuer en mode local uniquement? [y/N]"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "âŒ OpÃ©ration annulÃ©e"
            return 1
        fi
    fi
    
    echo "âœ… Ã‰tat du dÃ©pÃ´t vÃ©rifiÃ©"
    return 0
}

# Protection contre la suppression de branches importantes
git_branch_protection_check() {
    local branch_name="$1"
    local current_branch=$(git branch --show-current 2>/dev/null)
    
    # Branches protÃ©gÃ©es
    local protected_branches="master main develop staging production release"
    
    for protected in $protected_branches; do
        if [[ "$branch_name" == "$protected" ]]; then
            echo "ğŸš« INTERDIT: Suppression de la branche protÃ©gÃ©e '$branch_name'"
            return 1
        fi
    done
    
    # VÃ©rifier si la branche a Ã©tÃ© mergÃ©e
    if git branch --merged | grep -q "^[* ] $branch_name$"; then
        echo "âœ… Branche '$branch_name' dÃ©jÃ  mergÃ©e - suppression sÃ©curisÃ©e"
    else
        echo "âš ï¸  ATTENTION: Branche '$branch_name' non mergÃ©e"
        echo "   Cette branche contient des commits non fusionnÃ©s"
        echo "   Forcer la suppression? [y/N]"
        read -r response
        if [[ ! "$response" =~ ^[Yy]$ ]]; then
            echo "âŒ Suppression annulÃ©e"
            return 1
        fi
        echo "âš ï¸  Suppression forcÃ©e confirmÃ©e"
    fi
    
    # VÃ©rifier si on est sur la branche Ã  supprimer
    if [[ "$current_branch" == "$branch_name" ]]; then
        echo "âš ï¸  Vous Ãªtes sur la branche Ã  supprimer"
        echo "   Basculer vers 'main' automatiquement? [Y/n]"
        read -r response
        if [[ ! "$response" =~ ^[Nn]$ ]]; then
            git checkout main 2>/dev/null || git checkout master 2>/dev/null || {
                echo "âŒ Impossible de basculer vers main/master"
                return 1
            }
            echo "âœ… BasculÃ© vers la branche principale"
        else
            echo "âŒ Impossible de supprimer la branche courante"
            return 1
        fi
    fi
    
    return 0
}

# Validation des messages de commit
git_commit_validate() {
    local commit_message="$1"
    
    if [[ -z "$commit_message" ]]; then
        echo "âŒ Message de commit requis"
        return 1
    fi
    
    local message_length=${#commit_message}
    
    # VÃ©rifications de longueur
    if [[ $message_length -lt 10 ]]; then
        echo "âš ï¸  Message trÃ¨s court (${message_length} chars, min recommandÃ©: 10)"
    fi
    
    if [[ $message_length -gt 72 ]]; then
        echo "âš ï¸  PremiÃ¨re ligne longue (${message_length} chars, max recommandÃ©: 72)"
    fi
    
    # VÃ©rifications de format
    if [[ "$commit_message" =~ ^[a-z] ]]; then
        echo "âš ï¸  Commencer par une majuscule est recommandÃ©"
    fi
    
    if [[ "$commit_message" =~ \.$  ]]; then
        echo "âš ï¸  Ã‰viter le point final dans le titre"
    fi
    
    # VÃ©rifier le format Conventional Commits
    if [[ "$commit_message" =~ ^(feat|fix|docs|style|refactor|test|chore)(\(.+\))?: ]]; then
        echo "âœ… Format Conventional Commits dÃ©tectÃ©"
    else
        echo "ğŸ’¡ Format Conventional Commits recommandÃ©: type(scope): description"
    fi
    
    return 0
}

# Restauration depuis les backups
git_restore_backup() {
    echo "ğŸ”’ Backups disponibles:"
    git for-each-ref refs/backups/ --sort=-committerdate --format='%(refname:short) - %(committerdate:short)' | nl
    
    echo ""
    read -p "NumÃ©ro du backup Ã  restaurer (0 pour annuler): " backup_num
    
    if [[ "$backup_num" == "0" ]] || [[ -z "$backup_num" ]]; then
        echo "âŒ Restauration annulÃ©e"
        return 1
    fi
    
    local backup_ref=$(git for-each-ref refs/backups/ --sort=-committerdate --format='%(refname:short)' | sed -n "${backup_num}p")
    
    if [[ -z "$backup_ref" ]]; then
        echo "âŒ Backup invalide"
        return 1
    fi
    
    echo "âš ï¸  ATTENTION: Ceci va rÃ©initialiser votre branche actuelle"
    echo "   Backup sÃ©lectionnÃ©: $backup_ref"
    read -p "Confirmer la restauration? [y/N]: " confirm
    
    if [[ "$confirm" =~ ^[Yy]$ ]]; then
        git reset --hard "$backup_ref"
        echo "âœ… Backup restaurÃ©: $backup_ref"
    else
        echo "âŒ Restauration annulÃ©e"
    fi
}

# Nettoyage des backups anciens
git_cleanup_backups() {
    local backup_count=$(git for-each-ref refs/backups/ | wc -l)
    
    if [[ $backup_count -eq 0 ]]; then
        echo "â„¹ï¸  Aucun backup Ã  nettoyer"
        return 0
    fi
    
    echo "ğŸ“Š $backup_count backup(s) trouvÃ©(s)"
    
    if [[ $backup_count -gt 20 ]]; then
        echo "ğŸ§¹ Nettoyage automatique des backups anciens..."
        local backups_to_delete=$((backup_count - 20))
        
        git for-each-ref refs/backups/ --sort=committerdate --format='%(refname)' | head -$backups_to_delete | while read -r backup_ref; do
            git update-ref -d "$backup_ref"
            echo "ğŸ—‘ï¸  SupprimÃ©: $(basename "$backup_ref")"
        done
        
        echo "âœ… $backups_to_delete backup(s) ancien(s) supprimÃ©(s)"
    else
        echo "âœ… Nombre de backups acceptable ($backup_count/20)"
    fi
}

# Aliases pour les fonctions de sÃ©curitÃ©
alias git-validate='git_branch_validate'
alias git-backup='git_safe_operation'
alias git-restore='git_restore_backup'
alias git-cleanup='git_cleanup_backups' 