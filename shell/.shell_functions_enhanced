#!/bin/bash

# ==============================================================================
#                 Fonctions Shell Am√©lior√©es avec Affichage Sympa
# ==============================================================================

# Source les fonctions d'affichage
# Essayer d'abord le chemin relatif (pour d√©veloppement), puis le chemin absolu (pour utilisation)
if [ -f "$(dirname "${BASH_SOURCE[0]}")/.shell_display" ]; then
    source "$(dirname "${BASH_SOURCE[0]}")/.shell_display"
elif [ -f ~/.shell_display ]; then
    source ~/.shell_display
else
    echo "‚ö†Ô∏è  Attention: fichier .shell_display non trouv√©"
fi

# ==============================================================================
#                      Workflow & Sauvegardes (Version Am√©lior√©e)
# ==============================================================================

# Version am√©lior√©e de git_add_all_and_commit
git_add_all_and_commit_enhanced() {
  start_operation "Pr√©paration du commit"
  
  # 1. Ajoute tous les fichiers au "stage"
  print_step "Ajout de tous les fichiers au stage..."
  git add --all

  # V√©rifier s'il y a des changements √† committer
  if git diff --cached --quiet; then
    print_warning "Aucun changement √† committer"
    return 0
  fi

  # Afficher un r√©sum√© des changements
  local changes=$(git diff --cached --stat | tail -1)
  print_info "Changements: $changes"

  # 2. V√©rifie si des arguments ont √©t√© pass√©s
  if [ $# -gt 0 ]; then
    print_step "Utilisation du message de commit manuel..."
    git commit "$@"
    if [ $? -eq 0 ]; then
      print_success "Commit cr√©√© avec succ√®s !"
    else
      print_error "√âchec du commit"
      return 1
    fi
  else
    # G√©n√©ration automatique du message
    local current_branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)
    print_branch "$current_branch"

    local type jira_issue desc formatted_desc commit_message
    IFS='/' read -r type jira_issue desc <<< "$current_branch"

    if [[ -n "$type" && -n "$jira_issue" && -n "$desc" ]]; then
      formatted_desc=$(echo "$desc" | sed 's/-/ /g')
      commit_message="${type}(${jira_issue}): ${formatted_desc}"
      
      print_info "Message g√©n√©r√© automatiquement:"
      echo -e "   ${C_BOLD}${C_GREEN}‚Üí ${commit_message}${C_RESET}"
      
      git commit -m "${commit_message}"
      if [ $? -eq 0 ]; then
        print_success "Commit cr√©√© avec le message g√©n√©r√© !"
      else
        print_error "√âchec du commit"
        return 1
      fi
    else
      print_warning "Format de branche non reconnu (attendu: type/JIRA/desc)"
      print_step "Ouverture de l'√©diteur pour le message de commit..."
      git commit
    fi
  fi
  
  end_operation "Commit"
}

# Version am√©lior√©e de git_branch_start
git_branch_start_enhanced() {
  local branch_name=${1:-newBranch}
  
  start_operation "Cr√©ation de la nouvelle branche '$branch_name'"
  
  print_step "Cr√©ation de la branche locale..."
  if git checkout -b "$branch_name"; then
    print_success "Branche '$branch_name' cr√©√©e localement"
  else
    print_error "√âchec de la cr√©ation de la branche"
    return 1
  fi
  
  print_step "Push de la branche vers origin..."
  if git push origin "$branch_name"; then
    print_success "Branche push√©e vers origin"
  else
    print_error "√âchec du push vers origin"
    return 1
  fi
  
  print_step "Configuration du suivi amont..."
  if git_set_upstream_enhanced; then
    print_success "Suivi amont configur√©"
  else
    print_warning "√âchec de la configuration du suivi amont"
  fi
  
  print_step "Nettoyage des d√©pendances NPM..."
  git_npm_clean_enhanced
  
  end_operation "Cr√©ation de branche '$branch_name'"
}

# Version am√©lior√©e de git_set_upstream
git_set_upstream_enhanced() {
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  
  if [[ -n "$current_branch" ]]; then
    if git branch --set-upstream-to="origin/$current_branch"; then
      print_success "Suivi amont configur√© pour '$current_branch'"
      return 0
    else
      print_error "√âchec de la configuration du suivi amont"
      return 1
    fi
  else
    print_error "Impossible de d√©terminer la branche actuelle"
    return 1
  fi
}

# Version am√©lior√©e de git_npm_clean
git_npm_clean_enhanced() {
  if [[ -f "package.json" ]]; then
    print_step "Nettoyage des d√©pendances NPM..."
    if npm install --no-package-lock --production && npm prune; then
      print_success "D√©pendances NPM nettoy√©es"
    else
      print_warning "Probl√®me lors du nettoyage NPM"
    fi
  else
    print_info "Pas de package.json trouv√©, nettoyage NPM ignor√©"
  fi
}

# Version am√©lior√©e de git_branch_delete
git_branch_delete_enhanced() {
  local branch_name=$1
  
  if [[ -z "$branch_name" ]]; then
    print_error "Nom de la branche manquant"
    echo -e "${C_DIM}Usage: git_branch_delete_enhanced <nom_branche>${C_RESET}"
    return 1
  fi
  
  start_operation "Suppression de la branche '$branch_name'"
  
  # V√©rifier que ce n'est pas la branche actuelle
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  
  if [[ "$current_branch" == "$branch_name" ]]; then
    print_error "Impossible de supprimer la branche actuelle '$branch_name'"
    print_info "Changez de branche d'abord avec: git checkout master"
    return 1
  fi
  
  print_step "Suppression de la branche locale..."
  if git branch --delete "$branch_name"; then
    print_success "Branche locale '$branch_name' supprim√©e"
  else
    print_warning "√âchec de la suppression locale (branche peut-√™tre non fusionn√©e)"
  fi
  
  print_step "Suppression de la branche distante..."
  if git push origin --delete "$branch_name"; then
    print_success "Branche distante '$branch_name' supprim√©e"
  else
    print_warning "√âchec de la suppression distante (branche peut-√™tre inexistante)"
  fi
  
  end_operation "Suppression de branche '$branch_name'"
}

# Version am√©lior√©e de git_branch_sync
git_branch_sync_enhanced() {
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  
  start_operation "Synchronisation de la branche '$current_branch'"
  
  print_step "Pull avec rebase..."
  if git pull --rebase=preserve --prune "$@"; then
    print_success "Branche synchronis√©e avec le remote"
  else
    print_error "√âchec de la synchronisation"
    return 1
  fi
  
  print_step "Mise √† jour des submodules..."
  if git submodule update --init --recursive; then
    print_success "Submodules mis √† jour"
  else
    print_warning "Probl√®me avec les submodules"
  fi
  
  end_operation "Synchronisation de '$current_branch'"
}

# ==============================================================================
#                      Gestion /etc/hosts (Version Am√©lior√©e)
# ==============================================================================

removehost_enhanced() {
    if [[ "$1" ]]; then
        local HOSTNAME=$1
        
        start_operation "Suppression de '$HOSTNAME' du fichier hosts"
        
        if [ -n "$(grep "$HOSTNAME" /etc/hosts)" ]; then
            print_step "Suppression de '$HOSTNAME' de /etc/hosts..."
            if sudo sed -i".bak" "/$HOSTNAME/d" /etc/hosts; then
                print_success "'$HOSTNAME' supprim√© de /etc/hosts"
                print_info "Sauvegarde cr√©√©e: /etc/hosts.bak"
            else
                print_error "√âchec de la suppression"
                return 1
            fi
        else
            print_warning "'$HOSTNAME' non trouv√© dans /etc/hosts"
        fi
        
        end_operation "Suppression de host"
    else
        print_error "Param√®tre manquant"
        echo -e "${C_DIM}Usage: removehost_enhanced <domaine>${C_RESET}"
        return 1
    fi
}

addhost_enhanced() {
    if [[ "$1" && "$2" ]]; then
        local IP=$1
        local HOSTNAME=$2
        
        start_operation "Ajout de '$HOSTNAME' au fichier hosts"
        
        if [ -n "$(grep "$HOSTNAME" /etc/hosts)" ]; then
            print_warning "'$HOSTNAME' existe d√©j√† dans /etc/hosts:"
            echo -e "${C_DIM}$(grep "$HOSTNAME" /etc/hosts)${C_RESET}"
        else
            print_step "Ajout de '$IP $HOSTNAME' dans /etc/hosts..."
            if printf "%s\t%s\n" "$IP" "$HOSTNAME" | sudo tee -a /etc/hosts > /dev/null; then
                print_success "'$HOSTNAME' ajout√© √† /etc/hosts"
                print_info "Mapping: $IP ‚Üí $HOSTNAME"
            else
                print_error "√âchec de l'ajout"
                return 1
            fi
        fi
        
        end_operation "Configuration de host"
    else
        print_error "Param√®tres manquants"
        echo -e "${C_DIM}Usage: addhost_enhanced <ip> <domaine>${C_RESET}"
        return 1
    fi
}

# ==============================================================================
#                      Fonction de d√©monstration
# ==============================================================================

demo_enhanced_functions() {
    print_header "D√©monstration des fonctions am√©lior√©es"
    
    print_info "Fonctions disponibles avec affichage am√©lior√©:"
    echo -e "${C_YELLOW}  ‚Ä¢ git_add_all_and_commit_enhanced${C_RESET} - Commit avec affichage sympa"
    echo -e "${C_YELLOW}  ‚Ä¢ git_branch_start_enhanced${C_RESET}       - Cr√©ation de branche avec suivi"
    echo -e "${C_YELLOW}  ‚Ä¢ git_branch_delete_enhanced${C_RESET}      - Suppression de branche s√©curis√©e"
    echo -e "${C_YELLOW}  ‚Ä¢ git_branch_sync_enhanced${C_RESET}        - Synchronisation avec feedback"
    echo -e "${C_YELLOW}  ‚Ä¢ addhost_enhanced${C_RESET}                - Gestion /etc/hosts avec couleurs"
    echo -e "${C_YELLOW}  ‚Ä¢ removehost_enhanced${C_RESET}             - Suppression hosts avec feedback"
    
    print_separator
    
    print_info "Fonctions d'affichage disponibles:"
    echo -e "${C_GREEN}  ‚Ä¢ print_success${C_RESET} 'message'    - ‚úÖ Message de succ√®s"
    echo -e "${C_RED}  ‚Ä¢ print_error${C_RESET} 'message'      - ‚ùå Message d'erreur"
    echo -e "${C_YELLOW}  ‚Ä¢ print_warning${C_RESET} 'message'    - ‚ö†Ô∏è  Message d'avertissement"
    echo -e "${C_BLUE}  ‚Ä¢ print_info${C_RESET} 'message'       - ‚ÑπÔ∏è  Message d'information"
    echo -e "${C_CYAN}  ‚Ä¢ print_step${C_RESET} 'message'       - üîÑ √âtape en cours"
    echo -e "${C_PURPLE}  ‚Ä¢ print_git${C_RESET} 'message'        - üåø Message Git"
    
    print_separator
    print_success "Syst√®me d'affichage am√©lior√© pr√™t √† l'emploi !"
}

# ==============================================================================
#                      Gestion SSH am√©lior√©e
# ==============================================================================

# V√©rifie si l'agent SSH est en cours d'ex√©cution avec un bel affichage
ssh_agent_status() {
    print_header "üîê Statut de l'agent SSH"
    
    if agent_is_running; then
        print_success "Agent SSH en cours d'ex√©cution"
        if agent_has_keys; then
            local key_count=$(ssh-add -l 2>/dev/null | wc -l | tr -d ' ')
            print_info "üîë $key_count cl√©(s) charg√©e(s)"
            echo ""
            ssh-add -l | while read -r line; do
                local key_file=$(echo "$line" | awk '{print $NF}')
                local key_type=$(echo "$line" | awk '{print $4}' | sed 's/[()]//g')
                print_step "  ‚Ä¢ $key_file ($key_type)"
            done
        else
            print_warning "Aucune cl√© charg√©e"
        fi
    else
        print_error "Agent SSH non d√©marr√©"
    fi
    echo ""
}

# D√©marre l'agent SSH avec feedback
ssh_agent_start_enhanced() {
    print_header "üöÄ D√©marrage de l'agent SSH"
    
    if agent_is_running; then
        print_warning "Agent SSH d√©j√† en cours d'ex√©cution"
        return 0
    fi
    
    print_step "D√©marrage de l'agent SSH..."
    agent_start
    
    if agent_is_running; then
        print_success "Agent SSH d√©marr√© avec succ√®s"
        print_info "PID: $SSH_AGENT_PID"
    else
        print_error "√âchec du d√©marrage de l'agent SSH"
        return 1
    fi
}

# Charge toutes les cl√©s SSH avec feedback d√©taill√©
ssh_keys_load_enhanced() {
    print_header "üîë Chargement des cl√©s SSH"
    
    if ! agent_is_running; then
        print_warning "Agent SSH non d√©marr√©, d√©marrage automatique..."
        ssh_agent_start_enhanced
    fi
    
    local ssh_dir="$HOME/.ssh"
    local keys_found=0
    local keys_loaded=0
    
    print_step "Recherche des cl√©s dans $ssh_dir..."
    
    for key_file in "$ssh_dir"/id_*; do
        # Ignorer les fichiers .pub et v√©rifier que le fichier existe
        if [[ -f "$key_file" && "$key_file" != *.pub ]]; then
            keys_found=$((keys_found + 1))
            local key_name=$(basename "$key_file")
            
            print_step "Chargement de $key_name..."
            
            if ssh-add "$key_file" 2>/dev/null; then
                print_success "  ‚úÖ $key_name charg√©e"
                keys_loaded=$((keys_loaded + 1))
            else
                print_error "  ‚ùå √âchec du chargement de $key_name"
            fi
        fi
    done
    
    echo ""
    if [ $keys_found -eq 0 ]; then
        print_warning "Aucune cl√© SSH trouv√©e dans $ssh_dir"
    else
        print_info "üìä R√©sum√©: $keys_loaded/$keys_found cl√©(s) charg√©e(s)"
    fi
}

# Recharge l'environnement SSH avec feedback
ssh_env_reload_enhanced() {
    print_header "üîÑ Rechargement de l'environnement SSH"
    
    print_step "Chargement de l'environnement depuis ~/.ssh/agent.env..."
    agent_load_env
    
    if agent_is_running; then
        print_success "Environnement SSH recharg√© avec succ√®s"
        ssh_agent_status
    else
        print_warning "Agent SSH non trouv√©, d√©marrage d'un nouvel agent..."
        ssh_agent_start_enhanced
        ssh_keys_load_enhanced
    fi
}

# ==============================================================================
#                      NVM/Node.js am√©lior√©
# ==============================================================================

# Affiche la version Node actuelle avec style
node_version_enhanced() {
    print_header "üü¢ Version Node.js"
    
    if command -v node &> /dev/null; then
        local node_version=$(node --version)
        local npm_version=$(npm --version 2>/dev/null || echo "non install√©")
        
        print_success "Node.js: $node_version"
        print_info "npm: $npm_version"
        
        if command -v nvm &> /dev/null; then
            local nvm_current=$(nvm current 2>/dev/null)
            local nvm_default=$(nvm version default 2>/dev/null)
            
            print_step "NVM actuel: $nvm_current"
            if [[ "$nvm_default" != "N/A" ]]; then
                print_step "NVM d√©faut: $nvm_default"
            fi
        fi
    else
        print_error "Node.js n'est pas install√©"
    fi
    echo ""
}

# Liste les versions NVM avec style
nvm_list_enhanced() {
    print_header "üìã Versions Node.js disponibles"
    
    if ! command -v nvm &> /dev/null; then
        print_error "NVM n'est pas install√©"
        return 1
    fi
    
    print_step "Versions install√©es:"
    nvm list
    echo ""
}

# Installe une version Node avec feedback
nvm_install_enhanced() {
    local version="$1"
    
    if [[ -z "$version" ]]; then
        print_error "Usage: nvm_install_enhanced <version>"
        print_info "Exemples: nvm_install_enhanced lts/jod, nvm_install_enhanced 18.17.0"
        return 1
    fi
    
    print_header "üì¶ Installation Node.js $version"
    
    if ! command -v nvm &> /dev/null; then
        print_error "NVM n'est pas install√©"
        return 1
    fi
    
    print_step "Installation de Node.js $version..."
    
    if nvm install "$version"; then
        print_success "Node.js $version install√© avec succ√®s"
        node_version_enhanced
    else
        print_error "√âchec de l'installation de Node.js $version"
        return 1
    fi
}

# Utilise une version Node avec feedback
nvm_use_enhanced() {
    local version="$1"
    
    if [[ -z "$version" ]]; then
        print_error "Usage: nvm_use_enhanced <version>"
        print_info "Exemples: nvm_use_enhanced lts/jod, nvm_use_enhanced 18.17.0"
        return 1
    fi
    
    print_header "üîÑ Changement vers Node.js $version"
    
    if ! command -v nvm &> /dev/null; then
        print_error "NVM n'est pas install√©"
        return 1
    fi
    
    if nvm use "$version" 2>/dev/null; then
        print_success "Utilisation de Node.js $version"
        node_version_enhanced
    else
        print_warning "Version $version non install√©e"
        print_step "Installation automatique..."
        nvm_install_enhanced "$version"
    fi
}

# Fonction cd am√©lior√©e avec feedback NVM
cd_enhanced() {
    # Ex√©cute la commande cd originale
    builtin cd "$@" || return $?
    
    # Si nvm n'est pas disponible, on s'arr√™te l√†
    if ! command -v nvm &> /dev/null; then
        return 0
    fi
    
    local nvmrc_path
    nvmrc_path=$(nvm_find_up .nvmrc)
    
    if [[ -n "$nvmrc_path" ]]; then
        local nvmrc_version
        nvmrc_version=$(<"$nvmrc_path/.nvmrc")
        
        print_info "üìÅ .nvmrc d√©tect√©: $nvmrc_version"
        
        if nvm use 2>/dev/null; then
            print_success "üü¢ Node.js $nvmrc_version activ√©"
        else
            print_warning "‚ö†Ô∏è  Version $nvmrc_version non install√©e"
            print_step "Installation automatique..."
            if nvm install; then
                print_success "‚úÖ Node.js $nvmrc_version install√© et activ√©"
            else
                print_error "‚ùå √âchec de l'installation"
            fi
        fi
    else
        # Retour √† la version par d√©faut si n√©cessaire
        local default_version
        default_version=$(nvm version default 2>/dev/null)
        local current_version
        current_version=$(nvm current 2>/dev/null)
        
        if [[ "$default_version" != "N/A" ]] && [[ "$current_version" != "$default_version" ]]; then
            print_info "üîÑ Retour √† la version par d√©faut: $default_version"
            nvm use default >/dev/null
        fi
    fi
}

# ==============================================================================
#                      Fonctions Git am√©lior√©es
# ==============================================================================

# Commit am√©lior√© avec de beaux messages
git_add_all_and_commit_super_enhanced() {
    print_header "üìù Commit Git"
    
    # V√©rifier qu'on est dans un repo git
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_error "Pas dans un d√©p√¥t Git"
        return 1
    fi
    
    # V√©rifier s'il y a des changements
    if git diff --quiet && git diff --cached --quiet; then
        print_warning "Aucun changement √† commiter"
        return 0
    fi
    
    print_step "Ajout de tous les fichiers modifi√©s..."
    git add -A
    
    if [[ "$1" ]]; then
        print_info "üîÑ Utilisation du message de commit manuel..."
        local commit_message="$*"
        print_step "Message: \"$commit_message\""
    else
        # G√©n√©ration automatique du message bas√© sur la branche
        local branch_name
        branch_name=$(git branch --show-current 2>/dev/null)
        
        if [[ -z "$branch_name" ]]; then
            print_error "Impossible de d√©terminer la branche actuelle"
            return 1
        fi
        
        print_step "Branche actuelle: $branch_name"
        
        if [[ "$branch_name" =~ ^(feat|fix|docs|style|refactor|test|chore)/([A-Z]+-[0-9]+)/(.+)$ ]]; then
            local type="${BASH_REMATCH[1]}"
            local jira="${BASH_REMATCH[2]}"
            local desc="${BASH_REMATCH[3]}"
            
            local formatted_desc
            formatted_desc=$(echo "$desc" | sed 's/-/ /g')
            
            local commit_message
            case "$type" in
                feat) commit_message="‚ú® feat($jira): $formatted_desc" ;;
                fix) commit_message="üêõ fix($jira): $formatted_desc" ;;
                docs) commit_message="üìö docs($jira): $formatted_desc" ;;
                style) commit_message="üíÑ style($jira): $formatted_desc" ;;
                refactor) commit_message="‚ôªÔ∏è refactor($jira): $formatted_desc" ;;
                test) commit_message="üß™ test($jira): $formatted_desc" ;;
                chore) commit_message="üîß chore($jira): $formatted_desc" ;;
                *) commit_message="$type($jira): $formatted_desc" ;;
            esac
            
            print_success "Message g√©n√©r√© automatiquement:"
            print_info "  => $commit_message"
        else
            print_warning "Le nom de la branche ne suit pas le format 'type/JIRA/desc'"
            print_step "Ouverture de l'√©diteur pour le message de commit..."
            git commit
            return $?
        fi
    fi
    
    print_step "Cr√©ation du commit..."
    if git commit -m "$commit_message"; then
        print_success "‚úÖ Commit cr√©√© avec succ√®s !"
        
        # Afficher le hash du commit
        local commit_hash
        commit_hash=$(git rev-parse --short HEAD)
        print_info "üîó Hash: $commit_hash"
        
        # Afficher les stats
        local stats
        stats=$(git show --stat --format="" HEAD)
        if [[ -n "$stats" ]]; then
            print_step "üìä Statistiques:"
            echo "$stats" | sed 's/^/    /'
        fi
    else
        print_error "‚ùå √âchec de la cr√©ation du commit"
        return 1
    fi
}

# Cr√©ation de branche am√©lior√©e
git_branch_start_super_enhanced() {
    local branch_name="$1"
    
    if [[ -z "$branch_name" ]]; then
        print_error "Usage: git_branch_start_super_enhanced <nom-branche>"
        print_info "Format recommand√©: type/JIRA-123/description"
        return 1
    fi
    
    print_header "üåø Cr√©ation de branche Git"
    
    # V√©rifier qu'on est dans un repo git
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_error "Pas dans un d√©p√¥t Git"
        return 1
    fi
    
    print_step "V√©rification de l'√©tat du d√©p√¥t..."
    
    # V√©rifier s'il y a des changements non commit√©s
    if ! git diff --quiet || ! git diff --cached --quiet; then
        print_warning "‚ö†Ô∏è  Changements non commit√©s d√©tect√©s"
        print_step "Stash des changements en cours..."
        git stash push -m "Auto-stash avant cr√©ation de branche $branch_name"
        print_info "üíæ Changements sauvegard√©s dans le stash"
    fi
    
    print_step "Mise √† jour de la branche principale..."
    local main_branch
    main_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
    
    git checkout "$main_branch" 2>/dev/null || git checkout main 2>/dev/null || git checkout master
    git pull origin "$main_branch" 2>/dev/null || git pull
    
    print_step "Cr√©ation de la nouvelle branche: $branch_name"
    
    if git checkout -b "$branch_name"; then
        print_success "‚úÖ Branche '$branch_name' cr√©√©e avec succ√®s"
        print_info "üìç Branche bas√©e sur: $main_branch"
        
        # Validation du format de branche
        if [[ "$branch_name" =~ ^(feat|fix|docs|style|refactor|test|chore)/([A-Z]+-[0-9]+)/(.+)$ ]]; then
            local type="${BASH_REMATCH[1]}"
            local jira="${BASH_REMATCH[2]}"
            local desc="${BASH_REMATCH[3]}"
            
            print_step "üè∑Ô∏è  Format d√©tect√©:"
            print_info "  Type: $type"
            print_info "  JIRA: $jira"
            print_info "  Description: $desc"
        else
            print_warning "‚ö†Ô∏è  Format de branche non standard"
            print_info "Format recommand√©: type/JIRA-123/description"
        fi
    else
        print_error "‚ùå √âchec de la cr√©ation de la branche"
        return 1
    fi
}

# Suppression de branche am√©lior√©e
git_branch_delete_super_enhanced() {
    local branch_name="$1"
    
    if [[ -z "$branch_name" ]]; then
        print_error "Usage: git_branch_delete_super_enhanced <nom-branche>"
        return 1
    fi
    
    print_header "üóëÔ∏è  Suppression de branche Git"
    
    # V√©rifier qu'on est dans un repo git
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_error "Pas dans un d√©p√¥t Git"
        return 1
    fi
    
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null)
    
    if [[ "$current_branch" == "$branch_name" ]]; then
        print_warning "‚ö†Ô∏è  Vous √™tes sur la branche √† supprimer"
        print_step "Basculement vers la branche principale..."
        
        local main_branch
        main_branch=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@' || echo "main")
        git checkout "$main_branch" 2>/dev/null || git checkout main 2>/dev/null || git checkout master
    fi
    
    print_step "V√©rification de l'existence de la branche..."
    
    if ! git show-ref --verify --quiet "refs/heads/$branch_name"; then
        print_error "‚ùå La branche '$branch_name' n'existe pas localement"
        return 1
    fi
    
    print_step "Suppression de la branche locale: $branch_name"
    
    if git branch -d "$branch_name" 2>/dev/null; then
        print_success "‚úÖ Branche locale '$branch_name' supprim√©e"
    elif git branch -D "$branch_name"; then
        print_warning "‚ö†Ô∏è  Branche locale '$branch_name' supprim√©e (force)"
    else
        print_error "‚ùå √âchec de la suppression de la branche locale"
        return 1
    fi
    
    # V√©rifier et supprimer la branche distante
    print_step "V√©rification de la branche distante..."
    
    if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        print_step "Suppression de la branche distante..."
        if git push origin --delete "$branch_name"; then
            print_success "‚úÖ Branche distante '$branch_name' supprim√©e"
        else
            print_warning "‚ö†Ô∏è  √âchec de la suppression de la branche distante"
        fi
    else
        print_info "‚ÑπÔ∏è  Aucune branche distante √† supprimer"
    fi
    
    print_success "üéâ Nettoyage termin√© !"
}

# Rebase interactif am√©lior√©
git_rebase_interactive_super_enhanced() {
    local target_branch="${1:-main}"
    
    print_header "üîÑ Rebase interactif Git"
    
    # V√©rifier qu'on est dans un repo git
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        print_error "Pas dans un d√©p√¥t Git"
        return 1
    fi
    
    local current_branch
    current_branch=$(git branch --show-current 2>/dev/null)
    
    if [[ -z "$current_branch" ]]; then
        print_error "Impossible de d√©terminer la branche actuelle"
        return 1
    fi
    
    print_step "Branche actuelle: $current_branch"
    print_step "Branche cible: $target_branch"
    
    print_step "Recherche du point de divergence..."
    local fork_point
    fork_point=$(git merge-base "$current_branch" "$target_branch")
    
    if [[ -z "$fork_point" ]]; then
        print_error "Impossible de trouver un point de divergence avec '$target_branch'"
        print_info "La branche est peut-√™tre d√©j√† √† jour ou n'a pas d'historique commun"
        return 1
    fi
    
    local fork_point_short
    fork_point_short=$(git rev-parse --short "$fork_point")
    print_info "üìç Point de divergence: $fork_point_short"
    
    # Compter les commits √† rebaser
    local commit_count
    commit_count=$(git rev-list --count "$fork_point..$current_branch")
    print_step "üìä $commit_count commit(s) √† rebaser"
    
    if [[ "$commit_count" -eq 0 ]]; then
        print_success "‚úÖ La branche est d√©j√† √† jour"
        return 0
    fi
    
    print_step "Lancement du rebase interactif..."
    print_info "üéØ Depuis le commit: $fork_point_short"
    
    git rebase -i "$fork_point"
}

# Rechargement du shell am√©lior√©
reload_enhanced() {
    print_header "üîÑ Rechargement du shell"
    
    print_step "D√©tection du shell en cours..."
    
    # Marquer que c'est un reload manuel pour afficher les statuts SSH/NVM
    export DOTFILES_MANUAL_RELOAD=true
    
    if [ -n "$BASH_VERSION" ]; then
        print_info "üêö Shell d√©tect√©: Bash $BASH_VERSION"
        print_step "Rechargement de Bash..."
        exec bash
    elif [ -n "$ZSH_VERSION" ]; then
        print_info "üêö Shell d√©tect√©: Zsh $ZSH_VERSION"
        print_step "Rechargement de Zsh..."
        exec zsh
    else
        print_warning "‚ö†Ô∏è  Shell non reconnu"
        print_error "Shell non support√© pour le rechargement automatique"
        return 1
    fi
}

# ==============================================================================
#                      Aliases pour les fonctions am√©lior√©es
# ==============================================================================

# Aliases SSH
alias ssh-status='ssh_agent_status'
alias ssh-start='ssh_agent_start_enhanced'
alias ssh-load='ssh_keys_load_enhanced'
alias ssh-reload='ssh_env_reload_enhanced'

# Aliases NVM/Node
alias node-version='node_version_enhanced'
alias nvm-list='nvm_list_enhanced'
alias nvm-install='nvm_install_enhanced'
alias nvm-use='nvm_use_enhanced'

# Aliases Git (versions super am√©lior√©es)
alias gac='git_add_all_and_commit_super_enhanced'
alias gbs='git_branch_start_super_enhanced'
alias gbd='git_branch_delete_super_enhanced'
alias gri='git_rebase_interactive_super_enhanced'

# Alias reload
alias reload='reload_enhanced'

# Remplacer la fonction cd par la version am√©lior√©e
alias cd='cd_enhanced' 